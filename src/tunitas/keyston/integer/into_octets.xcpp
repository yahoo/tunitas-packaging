// This is -*- c++ -*- nearly C++2a with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <hpp>
#import std.endian
#import tunitas.array.Fixed
#import tunitas.integer.required.Unsigned
#import tunitas.integer.SizeOf
#import tunitas.keyston.integer.required.iterator.Sink
namespace tunitas::keyston::integer {
  //
  // See the documentariat in tunitas.keyston.integer.to_octets
  //
  template<std::endian, required::Unsigned UNSIGNED> inline constexpr auto into_octets(UNSIGNED, [[out]] array::Fixed<Octet, SizeOf<UNSIGNED>.count()> &) -> void;
  template<std::endian, required::Unsigned UNSIGNED, required::iterator::Sink ITERATOR> inline constexpr auto into_octets(UNSIGNED, [[out]] ITERATOR sink) -> ITERATOR;
}
#endiv
#divert <ipp>
#import nonstd.exception.Unreachable
namespace tunitas::keyston {
  template<std::endian ENDIAN, integer::required::Unsigned UNSIGNED> constexpr auto integer::into_octets(UNSIGNED source, array::Fixed<Octet, SizeOf<UNSIGNED>.count()> &sink) -> void {
    into_octets<ENDIAN>(source, sink.begin());
  }
  template<std::endian ENDIAN, integer::required::Unsigned UNSIGNED, integer::required::iterator::Sink ITERATOR> constexpr auto integer::into_octets(UNSIGNED source, ITERATOR sink) -> ITERATOR {
    constexpr auto const SIZE = SizeOf<UNSIGNED>.count();
    if constexpr (std::endian::little == ENDIAN) {
      for (auto i{0uz}; SIZE != i; ++i) {
        *sink++ = Octet(source & 0xffu);
        source >>= 8;
      }
    } else if (std::endian::big == ENDIAN) {
      constexpr auto const SIZEm1 = SIZE - 1u;
      for (auto i{0uz}; SIZE != i; ++i) {
        auto const shift = (SIZEm1-i) << 3;
        auto const mask = UNSIGNED{0xffu} << shift;
        auto const each = (source & mask) >> shift;
        *sink++ = Octet(each & 0xffu);
      }
    } else {
      throw exception::Unreachable{};
    }
    return sink;
  }
}
#endiv
