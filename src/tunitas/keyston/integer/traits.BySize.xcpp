// This is -*- c++ -*- nearly C++2a with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
#import std.size_t
#import std.has_single_bit
namespace tunitas::keyston::integer::traits {
  //
  // Given the size (in bytes) what is the integer type?
  // 
  template<std::size_t WIDTH> requires (std::has_single_bit(WIDTH) && 4 < WIDTH) struct BySize;
  template<> struct BySize<8uz> { using Type = uint8_t; };
  template<> struct BySize<16uz> { using Type = uint16_t; };
  template<> struct BySize<32uz> { using Type = uint32_t; };
  template<> struct BySize<64uz> { using Type = uint64_t; };
  template<> struct BySize<128uz> { using Type = uint128_t; };
  template<> struct BySize<256uz> { using Type = uint256_t; };
  template<> struct BySize<512uz> { using Type = uint512_t; };
  template<> struct BySize<1024uz> { using Type = uint1024_t; };
  // n.b. these aren't usable in SP 800-185 encodings where x < 2^2040
  template<> struct BySize<2048uz> { using Type = uint2048_t; };
  template<> struct BySize<4096uz> { using Type = uint4096_t; };
  template<> struct BySize<8192uz> { using Type = uint8192_t; };
}
#endiv
