// This is -*- c++ -*- nearly C++2a with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <hpp>
#import tunitas.array.Fixed
#import tunitas.array.Variable
#import tunitas.keyston.octets.Fixed
#import tunitas.keyston.octets.Variable
#import tunitas.view.Fixed
#import tunitas.view.Variable
namespace tunitas::keyston::octets {
  //
  // Concatenation of octet "strings"
  //
  // Specification:
  //
  //   Obvious.  Rhymes with perl's join(...)
  //
  // Design:
  //
  //   Obvious.
  //   constexpr-when-fixed (thus constexpr
  //   The magic is in the argument signautre becuase, obviously, anyone can figure out how to call std::copy(...)
  // 
  //   The multiple overloads here are because we can't both infer the template argument SIZE and also induce an implicit conversion in the same step.
  //
  // Nomenclature:
  //
  //   join-an-array
  //   concatenate-some-buffers
  //
  // Usage:
  //
  //   Pretty much what you'd expect.
  //
  template<Size SIZE> inline auto join(view::Variable<octets::Fixed<SIZE>> const &) -> Variable;
  template<Size SIZE> inline auto join(array::Variable<octets::Fixed<SIZE>> const &a) -> Variable { return join(static_cast<view::Variable<octets::Fixed<SIZE>>>(a)); }
  //
  template<Size SIZE1, Size SIZE2> inline constexpr auto join(view::Fixed<octets::Fixed<SIZE2>, SIZE1> a) -> Fixed<SIZE1*SIZE2>;
  template<Size SIZE1, Size SIZE2> inline constexpr auto join(array::Fixed<octets::Fixed<SIZE2>, SIZE1> const &a) -> Fixed<SIZE1*SIZE2> { return join(static_cast<view::Fixed<octets::Fixed<SIZE2>, SIZE1>>(a)); }
}
#endiv
#divert <ipp>
#import std.copy
namespace tunitas::keyston {
  template<Size SIZE> auto octets::join(view::Variable<octets::Fixed<SIZE>> const &source) -> Variable {
    auto ret = Variable(SIZE*source.size());
    auto sink = ret.begin();
    for (auto const &each : source) {
      sink = std::copy(each.begin(), each.end(), sink);
    }
    return ret;
  }
  template<Size SIZE1, Size SIZE2> constexpr auto octets::join(view::Fixed<octets::Fixed<SIZE2>, SIZE1> source) -> Fixed<SIZE1*SIZE2> {
    auto ret = Fixed<SIZE1*SIZE2>{};
    auto sink = ret.begin();
    for (auto const &each : source) {
      sink = std::copy(each.begin(), each.end(), sink);
    }
    return ret;
  }
}
#endiv
