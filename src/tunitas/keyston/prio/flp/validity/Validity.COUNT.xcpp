// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
#import tunitas.keyston.prio.flp.validity.Validity.template
namespace tunitas::keyston::prio::flp::validity {
  //
  // The validity bundle for PRIO COUNT
  //
  // Authorities:
  //
  //   draft-irtf-cfrg-vdaf Verifiable Distributed Aggregation Functions (VDAFs)
  //   https://www.ietf.org/archive/id/draft-irtf-cfrg-vdaf-06.html#name-a-general-purpose-flp
  //
  // Specification:
  //
  //   Section 7.4.1. Prio3Count
  //   Sure, right there in the Section.
  //
  // Design:
  //
  //   Transliterated from the standard (draft)
  //
  // Usage:
  //
  //   Yes.
  //
  template<> struct Definition<COUNT>;
  template<> struct Validity<COUNT>;
}
#endiv
#divert <hpp>
#import tunitas.keyston.measurement.Specimen
#import tunitas.keyston.aggregation.Count
namespace tunitas::keyston::prio::flp::validity {
  template<> struct Definition<COUNT> : public Prototype {
    using Field = keyston::Field<64>;
    using Measurement = measurement::Specimen; // yet reduced down to uint1_t (sic)
    using Aggregation = aggregation::Count;
    inline static constexpr auto const INPUT_LENGTH            = Input{1u};
    inline static constexpr auto const OUTPUT_LENGTH           = Output{1u};
    inline static constexpr auto const JOINT_RANDOMNESS_LENGTH = Joint{0u};
    using Gadgets = flp::Gadgets<flp::Gadget<RANGE1>>;
    inline static constexpr auto const CALLS = gadget::calls(1u);
  };
  template<> class Validity<COUNT> : public Definition<COUNT>, public Lengths<Definition<COUNT>>, public Codeckie<COUNT, Definition<COUNT>> {
    using Face = Interface<Definition<COUNT>>;
    using Mul = flp::Gadget<RANGE1>;
  public:
    inline static constexpr auto circuit(Face::Input, [[unused]] Face::Randomness, [[unused]] Face::Records) -> Field::Element;
    inline static constexpr auto circuit(Face::Input input) -> Field::Element { return circuit(input, {}, {}); }
  };
}
#endiv
#divert <ipp>
namespace tunitas::keyston::prio::flp::validity {
  constexpr auto Validity<COUNT>::circuit(Face::Input input, Face::Randomness, Face::Records) -> Field::Element {
    auto item = input.at(0u);
    return Mul{}(item, item) - item;
  }
}
#endiv
#divert <cpp>
#import tunitas.keyston.prio.flp.validity.usage.Validity
namespace {
  namespace testate {
    namespace usage = tunitas::keyston::prio::flp::validity::usage;
    using namespace tunitas::keyston::prio::flp::validity;
    static_assert(usage::Validity<Validity<COUNT>>);
  }
}
#endiv
