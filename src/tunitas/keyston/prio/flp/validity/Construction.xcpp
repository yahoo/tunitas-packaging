// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
#import tunitas.keyston.prio.flp.validity.required.Validity
namespace tunitas::keyston::prio::flp::validity {
  //
  // Convenient formula fragments to assemble the "circuit"s
  //
  // Authorities:
  //
  //   draft-irtf-cfrg-vdaf Verifiable Distributed Aggregation Functions (VDAFs)
  //   https://www.ietf.org/archive/id/draft-irtf-cfrg-vdaf-06.html#name-a-general-purpose-flp
  //
  // Specification:
  //
  //   Section 7.3. A General-Purpose FLP
  //   Section 7.3.3. Construction
  //
  // Design:
  //
  //   Wow, such design.
  //
  //   Follow the one-letter notational convention of Section 7.3.3 Construction
  //
  //   <quote>
  //     Let H = len(Valid.GADGETS)
  //     For each i in [H]:
  //     Let G_i = Valid.GADGETS[i]
  //     Let L_i = Valid.GADGETS[i].ARITY
  //     Let M_i = Valid.GADGET_CALLS[i]
  //     Let P_i = next_power_of_2(M_i+1)
  //     Let alpha_i = Field.gen()^(Field.GEN_ORDER / P_i)
  //   </quote>
  //
  //   Also:
  //     seed[H] of spans viewing onto the prove_randomness
  //     wire[H][L][M] of field elements
  //     poly_wire[H][L] of "polynomial" degree M+1
  //     poly_gadget[H] of gadget-evaluated polynomials
  //     proof = something about vector addition
  //
  // Usage:
  //
  //   See system::System<...>::prove(...), query(...), decode(...)
  //
  template<required::Validity> struct Construction;
}
#endiv
#divert <hpp>
#import tunitas.array.Fixed
#import tunitas.array.md.Fixed
#import tunitas.keyston.prio.flp.validity.usage.Validity
#import tunitas.view.Variable
#import tunitas.view.md.Variable
#import tunitas.view.Fixed
#import tunitas.view.md.Fixed
#import tunitas.integer.bit
#include <ipp/tunitas.integer.bit>
#import tunitas.keyston.prio.flp.validity.maximum
#include <ipp/tunitas.keyston.prio.flp.validity.maximum>
namespace tunitas::keyston::prio::flp {
  template<validity::required::Validity VALIDITY> struct validity::Construction {
    static_assert(usage::Validity<VALIDITY>);
    using Validity = VALIDITY;
    using Field = typename Validity::Field;
    using Element = typename Field::Element;
    using Polynomial = int;
    //
    using G = typename Validity::Gadgets;
    inline static constexpr auto const H = Validity::CALLS.size();
    struct Max {
      inline static constexpr auto const L = maximum::arity<typename Validity::Gadgets>();
      inline static constexpr auto const M = maximum::calls(Validity::CALLS);
      Max() = delete;
    };
    struct Scalar {
      struct Seeds {
        using Declaration = view::Variable<Element> /**/[H]; // mostly unusable 
        using View = view::Fixed<view::Variable<Element>, H>;
        using Storage = array::Fixed<view::Variable<Element>, H>;
        Seeds() = delete;
      };
      struct Wires {
        using Declaration = Element /**/[H][Max::L][Max::M];
        using View = view::md::Fixed<Element, std::extents<Size, H, Max::L, Max::M>>;
        using Storage = array::md::Fixed<Element, std::extents<Size, H, Max::L, Max::M>>;
        Wires() = delete;
      };
      Scalar() = delete;
    };
    struct Poly {
      using Wires = Polynomial /**/[H][Max::L];
      using Gadgets = Polynomial /**/[H];
      Poly() = delete;
    };
    template<Size INDEX> struct Each {
      using G = typename tuple::Element<INDEX, typename Validity::Gadgets>::type;
      inline static constexpr auto const L = G::ARITY;
      inline static constexpr auto const M = Validity::CALLS.at(INDEX);
      inline static constexpr auto const P = integer::bit_ceil(1u+M);
      inline static constexpr auto const alpha = Field::generator() * (Field::Generator::ORDER / P); // with parenthesis as in the draft
    };
  };
}
#endiv
