// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
#import tunitas.keyston.prio.flp.validity.required.Validity
namespace tunitas::keyston::prio::flp::validity {
  //
  // [[REMOVETHIS]] ... the types are presented differently now in system::System<...>
  //
  // Convenient formula fragments to assemble the "circuit"s
  //
  // Authorities:
  //
  //   I-D.irtf-cfrg-vdaf
  //   https://www.ietf.org/archive/id/draft-irtf-cfrg-vdaf-06.html
  //   Verifiable Distributed Aggregation Functions (VDAFs)
  //
  //   [BBCGGI19] <https://ia.cr/2019/188>
  //   D, Boneh, E, Boyle, H. Corrigan-Gibbs, N, Gilboa, Y. Ishai.
  //   "Zero-Knowledge Proofs on Secret-Shared Data via Fully Linear PCPs", In CRYPTO 2019, 2019.
  //   
  // Specification:
  //
  //   draft-irtf-cfrg-vdaf
  //   Section 7.3. A General-Purpose FLP
  //   Section 7.3.3. Construction
  //
  //   BBCGGI19
  //   Section 4.2. A New Fully Linear PCP with Short Proofs for Structured Circuits
  //
  // Design:
  //
  //   Wow, such design.
  //
  //   Follow the one-letter notational convention of Section 7.3.3 Construction
  //
  //   <quote>
  //     Let H = len(Valid.GADGETS) ... WATCHOUT - this abstracts (loses) the order of evaluation
  //     For each i in [H]:
  //     Let G_i = Valid.GADGETS[i]
  //     Let L_i = Valid.GADGETS[i].ARITY
  //     Let M_i = Valid.GADGET_CALLS[i]
  //     Let P_i = next_power_of_2(M_i+1)
  //     Let alpha_i = Field.gen()^(Field.GEN_ORDER / P_i)
  //   </quote>
  //
  //   Also:
  //     seed[H] of spans viewing onto the prove_randomness
  //     wire[H][L][M] of field elements
  //     poly_wire[H][L] of "polynomial" degree M+1
  //     poly_gadget[H] of gadget-evaluated polynomials
  //     proof = something about vector addition
  //
  // Usage:
  //
  //   See system::System<...>::prove(...), query(...), decode(...)
  //
  template<required::Validity> struct Construction;
}
#endiv
#divert <hpp>
#import tunitas.array.Fixed
#import tunitas.array.md.Fixed
#import tunitas.keyston.prio.flp.validity.usage.Validity
#import tunitas.span.md.Fixed
#import tunitas.view.Variable
#import tunitas.view.md.Variable
#import tunitas.view.Fixed
#import tunitas.view.md.Fixed
#import tunitas.integer.bit
#include <ipp/tunitas.integer.bit>
#import tunitas.tuple.Size
#import tunitas.tuple.Element
#import tunitas.keyston.prio.flp.validity.maximum
#include <ipp/tunitas.keyston.prio.flp.validity.maximum>
namespace tunitas::keyston::prio::flp {
  template<validity::required::Validity VALIDITY> struct validity::Construction {
    static_assert(usage::Validity<VALIDITY>);
    using Validity = VALIDITY;
    using Field = typename Validity::Field;
    using Element = typename Field::Element;
    template<Size DEGREE> using Polynomial = typename Field::template Polynomial<DEGREE>;
    //
    using G = typename Validity::Gadgets;
    inline static constexpr auto const H = Validity::CALLS.size();
    static_assert(H == tuple::Size<G>::value);
    template<Size I> struct Each {
      using G = typename tuple::Element<I, typename Validity::Gadgets>::type; // ... iteration on i of [H]
      inline static constexpr auto const degG = G::DEGREE;
      inline static constexpr auto const L = G::ARITY; // .......................... iteration on j of [L_i]
      inline static constexpr auto const M = Validity::CALLS.at(I); // ............. iteration on k of [M_i]
      inline static constexpr auto const P = integer::bit_ceil(1u+M);
      using Axis = typename Field::template Series<P>;
      inline static constexpr auto x_axis() -> Axis;
      inline static constexpr auto alpha(Size) -> Element;
      struct Wires {
        using Declaration = Element /**/[L][P];
        using Span    =  span::md::Fixed<Element, std::extents<Size, L, P>>;
        using View    =  view::md::Fixed<Element, std::extents<Size, L, P>>;
        using Storage = array::md::Fixed<Element, std::extents<Size, L, P>>;
        Wires() = delete;
      };
    };
    struct Seeds {
      using Declaration = view::Variable<Element> /**/[H]; // mostly unusable 
      using Span    =  span::Fixed<view::Variable<Element>, H>;
      using View    =  view::Fixed<view::Variable<Element>, H>;
      using Storage = array::Fixed<view::Variable<Element>, H>;
      Seeds() = delete;
    };
    struct Max {
      inline static constexpr auto const degG = maximum::degree<typename Validity::Gadgets>();
      inline static constexpr auto const L = maximum::arity<typename Validity::Gadgets>();
      inline static constexpr auto const M = maximum::calls(Validity::CALLS);
      Max() = delete;
    };
    struct Scalar {
      struct Wires {
        using Declaration = Element /**/[H][Max::L][Max::M];
        using Span    =  span::md::Fixed<Element, std::extents<Size, H, Max::L, Max::M>>;
        using View    =  view::md::Fixed<Element, std::extents<Size, H, Max::L, Max::M>>;
        using Storage = array::md::Fixed<Element, std::extents<Size, H, Max::L, Max::M>>;
        Wires() = delete;
      };
      Scalar() = delete;
    };
    struct Poly {
      template<Size DEGREE> struct Wires {
        using Declaration = Polynomial<DEGREE> /**/[H][Max::L];
        using Span    =  span::md::Fixed<Polynomial<DEGREE>, std::extents<Size, H, Max::L>>;
        using View    =  view::md::Fixed<Polynomial<DEGREE>, std::extents<Size, H, Max::L>>;
        using Storage = array::md::Fixed<Polynomial<DEGREE>, std::extents<Size, H, Max::L>>;
        Wires() = delete;
      };
      template<Size DEGREE> struct Gadgets {
        using Declaration = Polynomial<DEGREE> /**/[H];
        using Span    =  span::md::Fixed<Polynomial<DEGREE>, std::extents<Size, H>>;
        using View    =  view::md::Fixed<Polynomial<DEGREE>, std::extents<Size, H>>;
        using Storage = array::md::Fixed<Polynomial<DEGREE>, std::extents<Size, H>>;
        Gadgets() = delete;
      };
      Poly() = delete;
    };
  };
}
#endiv
#divert <ipp>
#import tunitas.sequence.Sequence
namespace tunitas::keyston::prio::flp::validity {
  template<required::Validity _> template<Size I> constexpr auto Construction<_>::Each<I>::alpha(Size k) -> Element {
    return pow(pow(Field::generator(), k), Field::Generator::ORDER / P);
  }
  template<required::Validity _> template<Size I> constexpr auto Construction<_>::Each<I>::x_axis() -> Axis {
    return []<Size... K>(sequence::Sequence::Pack<K...>) {
      return Axis{alpha(K)...};
    }(sequence::Sequence::make<M>());
  }
}
#endiv
      inline static constexpr auto const alpha(Size k) { return pow(pow(Field::generator(), k), Field::Generator::ORDER / P); }
     inline static constexpr auto const alpha(Size k) { return pow(pow(Field::generator(), k), Field::Generator::ORDER / P); }
       inline static constexpr auto axis() { return []<Size... K>(Access::Sequence::Pack<K...>) -> Gadget::Axis::X { return {Gadget::alpha(k)...}; }(Access::Sequence::make<Gadget::P>());

