// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
#import tunitas.keyston.prio.flp.gadget.recorder.required.Element
namespace tunitas::keyston::prio::flp::gadget::recorder {
  //
  // The sink is a span with and "advance" operation
  //
  // Specification:
  //
  //   Advance
  //   throw if exhausted
  //
  //   The arity is the stride.
  //   Distinguish between null-sink (allowed) and valid-but-exahsuted (error upon advancement)
  //
  // Design:
  //
  //   Sure, why do you ask?  We are using the Best Available Means and Methods (UBAMM)  We uuse patterns and behavior-driven- design and design-driven-behavior and scrum, and agile and we are agnostic to whether requirements-driven waterfall chains are tied scoped into our the best practices of our continuous integration.  Our practice statement is available in the department office along with the many compliance certifications that we have achieved.
  //
  template<required::Element ELEMENT, Arity ARITY> struct Sink;
}
#endiv
#divert <hpp>
#import tunitas.span.md.Variable
namespace tunitas::keyston::prio::flp::gadget {
  template<recorder::required::Element ELEMENT, Arity THE_ARITY> struct recorder::Sink : public span::md::Variable<ELEMENT, std::extents<Size, std::dynamic_extent, underlying(THE_ARITY)>> {
    using Ancestor = span::md::Variable<ELEMENT, std::extents<Size, std::dynamic_extent, underlying(THE_ARITY)>>;
  public:
    Sink() = default;
    using Ancestor::mdspan; // and yes, you "just have to know" that the ancestor's constructor is named "mdspan"
    inline constexpr auto operator++() -> Sink &;
    inline constexpr auto operator++(int) -> Sink;
  };
}
#endiv
#divert <ipp>
#import tunitas.keyston.exception.Invalid
namespace tunitas::keyston::prio::flp::gadget::recorder {
  template<required::Element E, Arity A> constexpr auto Sink<E,A>::operator++() -> Sink & {
    auto size = Ancestor::size();
    auto data = Ancestor::data();
    if (0u == size) {
      if (nullptr == data) {
        // means null-sink; this is an allowed & expected behavior.
      } else {
        throw exception::Invalid{"exhausted"};
      }
    } else {
      Ancestor::operator=({1+data, size-1u});
      return *this;
    }
  }
  template<required::Element E, Arity A> constexpr auto Sink<E,A>::operator++(int) -> Sink {
    auto old = *this;
    operator++();
    return old;
  }
}
#endiv
