!// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
#import tunitas.keyston.prio.required.Definition
namespace tunitas::keyston::prio {
  //
  // We're doing encoding & decoding; there are many ways to view the same data
  //
  namespace [[eponymous]] role {
    enum class Name { PUBLIC, LEADER, HELPER };
    using enum Name;
    template<required::Definition> struct Count;
    namespace shapedlike {
      template<required::Definition, Size> struct Seed;
      template<Size> struct Count;
    }
    template<Name, required::Definition> struct Uncoded;
    template<Name, required::Definition> struct Outline;
    template<Name, required::Definition> struct Role;
  }
  using role::Role;
}
#endiv
#divert <hpp>
#import std.conditional
#import std.same_as
#import tunitas.Tuple
#import tunitas.array.Fixed
#import tunitas.keyston.field.required.Element
#import tunitas.keyston.octets.Fixed
#import tunitas.view.Fixed
#import tunitas.view.Variable
namespace tunitas::keyston::prio {
  template<required::Definition DEFINITION, Size THE_SIZE> struct role::shapedlike::Seed {
    // always octets but may be size 0uz
    inline static constexpr auto const SIZE = THE_SIZE;
    using Storage = octets::Fixed<SIZE>;
    struct View {
      using Fixed = view::Fixed<Octet, SIZE>;
    };
  };
  namespace role {
    template<required::Definition DEFINITION> using Blind = shapedlike::Seed<DEFINITION, DEFINITION::use_joint_randomness() ? DEFINITION::Amplifier::Seed::SIZE.count() : 0uz>;
    template<required::Definition DEFINITION> using Seed = shapedlike::Seed<DEFINITION, DEFINITION::Amplifier::Seed::SIZE.count()>;
  }
  template<required::Definition DEFINITION> struct role::Count {
    struct Input {
      inline static constexpr auto const COUNT = DEFINITION::Prover::Message::Input::VALUE.count();
    };
    struct Proof {
      inline static constexpr auto const COUNT = DEFINITION::Prover::Message::Proof::VALUE.count();
    };
  };
  template<Size THE_COUNT> struct role::shapedlike::Count {
    struct Input {
      inline static constexpr auto const COUNT = THE_COUNT;
    };
    struct Proof {
      inline static constexpr auto const COUNT = THE_COUNT;
    };
  };
  template<role::Name ROLE, required::Definition DEFINITION> struct role::Outline {
    struct Decoded {
      using Input = typename Uncoded<LEADER, DEFINITION>::Input;
      using Proof = typename Uncoded<LEADER, DEFINITION>::Proof;
      using Blind = typename Uncoded<LEADER, DEFINITION>::Blind;
      using Triple = tunitas::Tuple<typename Input::Storage, typename Proof::Storage, typename Blind::Storage>;
    };
    // The Leader, Helper & Public vary the size.
    template<Size EACH, typename COUNTSHAPE> struct Encoded {
      struct Input {
        inline static constexpr auto const SIZE = EACH * COUNTSHAPE::Input::COUNT;
        struct View {
          using Fixed = view::Fixed<Octet, SIZE>;
        };
      };
      struct Proof {
        inline static constexpr auto const SIZE = EACH * COUNTSHAPE::Proof::COUNT;
        struct View {
          using Fixed = view::Fixed<Octet, SIZE>;
        };
      };
      using Blind = typename Uncoded<ROLE, DEFINITION>::Blind;
      using Storage = octets::Fixed<Input::SIZE + Proof::SIZE + Blind::SIZE>;
      struct View {
        // use Variable here because it's coming in off-the-wire and ew don't know anythin about it; decoding validates the length.
        using Variable = view::Variable<Octet>;
      };
    };
  };
}
// Because all the descendants will need these
#import tunitas.keyston.prio.exception.Decode
#import tunitas.keyston.prio.binder
#import tunitas.keyston.prio.Usage
#import tunitas.keyston.octets.concatenate
#import tunitas.keyston.octets.slice_off
#endiv
