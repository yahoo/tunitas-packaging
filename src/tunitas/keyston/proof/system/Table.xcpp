// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
#import tunitas.keyston.proof.system.required.Field
namespace tunitas::keyston::proof::system {
  //
  // That table for a proof system.
  //
  // Specification:
  //
  //   See Table 4 https://www.ietf.org/archive/id/draft-irtf-cfrg-vdaf-05.html#flp-param
  //
  // Usage:
  //
  //   see System<FIELD, TABLE>
  //
  enum class Prove : unsigned;
  enum class Query : unsigned;
  enum class Joint : unsigned;
  enum class Input : unsigned;
  enum class Output : unsigned;
  enum class Proof : unsigned;
  enum class Verifier : unsigned;
  template<required::Field, Prove, Query, Joint, Input, Output, Proof, Verifier> struct Table;
}
#endiv
#divert <hpp>
#import tunitas.keyston.Field
#import tunitas.keyston.proof.system.Length
#import std.underlying_type
namespace tunitas::keyston::proof {
  template<system::required::Field FIELD, system::Prove PROVE, system::Query QUERY, system::Joint JOINT, system::Input INPUT, system::Output OUTPUT, system::Proof PROOF, system::Verifier VERIFIER> class system::Table {
    using Field = FIELD;
    template<auto COUNT> requires required::Enumeration<decltype(COUNT)> struct [[FIXTHIS("this should be in nonstd::units as a Constant similar to std::integral_constnat<...>")]] Constant_Of_Bytes {
      inline static constexpr auto const VALUE = nonstd::units::memory::Bytes{std::underlying_type_t<decltype(COUNT)>(COUNT)};
    };
  public:
    struct Randomness {
      using Prove = Length<Field, Constant_Of_Bytes<PROVE>>;
      using Query = Length<Field, Constant_Of_Bytes<QUERY>>;
      using Joint = Length<Field, Constant_Of_Bytes<JOINT>>;
    };
    struct Message {
      using Input    = Length<Field, Constant_Of_Bytes<INPUT>>;
      using Output   = Length<Field, Constant_Of_Bytes<OUTPUT>>;
      using Proof    = Length<Field, Constant_Of_Bytes<PROOF>>;
      using Verifier = Length<Field, Constant_Of_Bytes<VERIFIER>>;
    };
  };
}
#endiv
