// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
namespace tunitas::keyston::protocol::query::batch {
  //
  // A batch query (query specification object).
  //
  // Specification:
  //
  //   https://ietf-wg-ppm.github.io/draft-ietf-ppm-dap/draft-ietf-ppm-dap.html
  //   Section 4.1. Queries
  //
  //     struct Query
  //
  //   Section 4.1.1.2 Helper Initialization
  //
  //     struct BatchSelector
  //
  // Design:
  //
  //   Obvious
  //
  // Usage:
  //
  //   Yes.
  //
  struct Batch;
}
#import std.variant_size.tunitas.keyston.protocol.query.batch.Batch
#import std.variant_alternative.N.tunitas.keyston.protocol.query.batch.Batch
#import std.visit.tunitas.keyston.protocol.query.batch.Batch
#endiv
#divert <hpp>
#import tunitas.keyston.protocol.query.batch.Variant
#forward tunitas.keyston.protocol.query.Partial
#import tunitas.keyston.protocol.query.Type
#import tunitas.keyston.protocol.query.Visitor
namespace tunitas::keyston::protocol::query {
  namespace batch {
    using std::move;
    inline auto swap(Batch &, Batch &) noexcept -> void;
    inline auto partialize(Batch const &) -> Partial;
  }
  class batch::Batch : public Variant {
    using Ancestor = Variant;
    friend auto swap(Batch &, Batch &) noexcept -> void;
    friend auto partialize(Batch const &) -> Partial;
    template<typename... THUNKS> using Visitor = query::Visitor<THUNKS...>;
  public:
    Batch() = default;
    using Ancestor::variant;
    using Ancestor::operator=;
    Batch &operator=(Batch const &) = default;
    inline auto type() const -> Type;
  };
}
#endiv
#divert <ipp>
#import tunitas.keyston.protocol.query.Partial
#import tunitas.keyston.protocol.query.batch.Record
#import tunitas.keyston.protocol.exception.Invalid
namespace tunitas::keyston::protocol::query {
  auto batch::swap(Batch &a, Batch &b) noexcept -> void {
    Batch::Ancestor &aa{a}, &bb{b};
    swap(aa, bb);
  }
  auto batch::partialize(Batch const &source) -> Partial {
    // This looks likecopy-pasta but the Record<Type>SOMETHING> is different in namespace batch and namespace partial
    auto visitor = Visitor{[](Record<Type::RESERVED> const &)      -> Partial { return partial::Record<Type::RESERVED>{}; },
                           [](Record<Type::TIME_INTERVAL> const &) -> Partial { return partial::Record<Type::TIME_INTERVAL>{}; },
                           [](Record<Type::FIXED_SIZE> const &f)   -> Partial { return partial::Record<Type::FIXED_SIZE>{f}; },
                           [](auto const &)                                   { throw exception::Invalid{"query::Batch"}; }};
    return visit(visitor, static_cast<Batch::Ancestor const &>(source));
  }
  namespace batch {
    auto Batch::type() const -> Type {
      auto visitor = Visitor{[](Record<Type::RESERVED> const &)      { return Type::RESERVED; },
                             [](Record<Type::TIME_INTERVAL> const &) { return Type::TIME_INTERVAL; },
                             [](Record<Type::FIXED_SIZE> const &)    { return Type::FIXED_SIZE; },
                             [](auto const &)                        { throw exception::Invalid{"query::Batch"}; }};
      return visit(visitor, static_cast<Ancestor const &>(*this));
    }
  }
}
#endiv
#divert <cpp>
namespace {
  namespace testate {
    using namespace tunitas::keyston::protocol::query::batch;
    static_assert(std::is_default_constructible_v<Batch>);
    static_assert(std::is_copy_constructible_v<Batch>);
    static_assert(std::is_move_constructible_v<Batch>);
    static_assert(std::is_copy_assignable_v<Batch>);
    static_assert(std::is_move_assignable_v<Batch>);
    static_assert(std::is_swappable_v<Batch>);
  }
}
#endiv
