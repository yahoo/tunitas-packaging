// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc, 2022.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
namespace tunitas::keyston::protocol::preparation::step {
  namespace package_cast {
    namespace body::exported { }
    namespace interface = body::exported;
  }
  using namespace package_cast::interface;
}
#forward tunitas.keyston.protocol.preparation.step.Step
#import tunitas.keyston.protocol.required // ctcnr (cascade that certain 'namespace required')
#import std.same_as
#import std.is_const
#import std.remove_const
#import nonstd.required.Pointer
#import nonstd.required.Reference
namespace tunitas::keyston::protocol::preparation::step::package_cast::body {
  template<typename> struct Conjugations;
  template<> struct Conjugations<Step>;
  template<> struct Conjugations<Step const>;
  using namespace std; // at least same_as, remove_const, is_const and _v _t
  namespace pointer {
    template<required::Pointer RESULT, typename ACTUAL, typename MATCH> struct Each;
    template<required::Pointer RESULT, typename ACTUAL, typename... MATCHES> struct Conjugator;
    template<required::Pointer RESULT, typename ACTUAL, typename CONJUGATIONS> struct Selector;
  }
  namespace reference {
    template<required::Reference RESULT, typename ACTUAL, typename MATCH> struct Each;
    template<required::Reference RESULT, typename ACTUAL, typename... MATCHES> struct Conjugator;
    template<required::Reference RESULT, typename ACTUAL, typename CONJUGATIONS> struct Selector;
  }
}
#endiv
#divert <hpp>
#forward tunitas.keyston.protocol.preparation.step.Continued
#forward tunitas.keyston.protocol.preparation.step.Finished
#forward tunitas.keyston.protocol.preparation.step.Failed
#import tunitas.keyston.protocol.preparation.step.required.Castable
#import tunitas.variant.Visitor
#import tunitas.keyston.protocol.exception.Cast
namespace tunitas::keyston::protocol::preparation::step {
  namespace package_cast::body {
    namespace exported {
      // 
      // The variant cast
      //
      // Specification:
      //
      //   Conjugations for all of them: Continued, Finished, Failed.
      //   Conjugations for constie and mutable variants.
      //
      // Exceptions:
      //
      //   The reference-returning variants throw an exception::Cast if the cast cannot be performed.
      //   The pointer-returning variants merely return nullptr.
      //
      // Design:
      //
      //   Carefully to avoid copy pasta
      //
      //   the predicates: is_continued(...), is_finished(...), is_failed(...) should be discoverable by ADL.
      //   cast<RESULT>(...) need not be discoverable by ADL because you'll be uttering preparation::step::cast<RESULT(...) anyway.
      //
      // Usage:
      //
      //   Both constie and mutable variants following this pattern of usage
      //
      //   auto const &cont = step::cast<step::Continued const &>(candidate);
      //   auto const &fini = step::cast<step::Finished const &>(candidate);
      //   auto const &fali = step::cast<step::Failed const &>(candidate);
      //
      //   auto const *emp = step::cast<step::Continued const *>(candidate);
      //   auto const *tim = step::cast<step::Finished const *>(candidate);
      //   auto const *fix = step::cast<step::Failed const *>(candidate);
      //
      template<typename EXACT> inline auto is(Step const &) -> bool;
      inline auto is_continued(Step const &) -> bool;
      inline auto is_finished(Step const &) -> bool;
      inline auto is_failed(Step const &) -> bool;
      inline auto is_valid(Step const &) -> bool;
      //
      template<typename RESULT> inline auto cast(Step const &) -> RESULT requires required::Castable<RESULT>;
      template<typename RESULT> inline auto cast(Step &) -> RESULT requires required::Castable<RESULT>;
    }
    template<typename CONJUGATIONS, typename RESULT, typename VARIANT> inline auto conjugate(VARIANT &) -> RESULT;
    template<> struct Conjugations<Step> {
      using Continued = step::Continued;
      using Finished  = step::Finished;
      using Failed    = step::Failed;
    };
    template<> struct Conjugations<Step const> {
      using Continued = step::Continued const;
      using Finished  = step::Finished const;
      using Failed    = step::Failed const;
    };
    template<required::Pointer RESULT, typename ACTUAL, typename MATCH> struct pointer::Each {
      static_assert(!is_const_v<RESULT>);
      static_assert(!is_const_v<ACTUAL>);
      // MATCH may or may not be constie
      auto operator()(MATCH &candidate) -> RESULT {
        if constexpr (same_as<ACTUAL, remove_const_t<MATCH>>) {
          return &candidate;
        } else {
          return nullptr;
        }
      }
    };
    template<required::Reference RESULT, typename ACTUAL, typename MATCH> struct reference::Each {
      static_assert(!is_const_v<RESULT>);
      static_assert(!is_const_v<ACTUAL>);
      // MATCH may or may not be constie
      auto operator()(MATCH &candidate) -> RESULT {
        if constexpr (same_as<ACTUAL, remove_const_t<MATCH>>) {
          return candidate;
        } else {
          throw exception::Cast{typeid(remove_const_t<MATCH>)};
        }
      }
    };
    template<required::Pointer RESULT, typename ACTUAL, typename... MATCHES> struct pointer::Conjugator : public variant::Visitor<Each<RESULT, ACTUAL, MATCHES>...> { };
    template<required::Reference RESULT, typename ACTUAL, typename... MATCHES> struct reference::Conjugator : public variant::Visitor<Each<RESULT, ACTUAL, MATCHES>...> { };
    //
    template<required::Pointer RESULT, typename ACTUAL, typename CONJUGATIONS> struct pointer::Selector : public Conjugator<RESULT, ACTUAL,
                                                                                                                            typename CONJUGATIONS::Continued,
                                                                                                                            typename CONJUGATIONS::Finished,
                                                                                                                            typename CONJUGATIONS::Failed> { };
    template<required::Reference RESULT, typename ACTUAL, typename CONJUGATIONS> struct reference::Selector : public Conjugator<RESULT, ACTUAL,
                                                                                                                                typename CONJUGATIONS::Continued,
                                                                                                                                typename CONJUGATIONS::Finished,
                                                                                                                                typename CONJUGATIONS::Failed> { };
  }
  //
  // Must import the declarations directly so that ADL will find them from the argument Step
  //
  using package_cast::body::exported::is;
  using package_cast::body::exported::is_continued;
  using package_cast::body::exported::is_finished;
  using package_cast::body::exported::is_failed;
  using package_cast::body::exported::is_valid;
}
#endiv
#divert <ipp>
#import tunitas.keyston.protocol.exception.Cast
#import tunitas.keyston.protocol.preparation.step.Continued
#import tunitas.keyston.protocol.preparation.step.Finished
#import tunitas.keyston.protocol.preparation.step.Failed
#import tunitas.keyston.protocol.preparation.step.traits.Cast
#import tunitas.keyston.protocol.preparation.step.Step
#import tunitas.variant.visit
#import nonstd.exception.Unreachable
#import nonstd.required.Pointer
#import nonstd.required.Reference
namespace tunitas::keyston::protocol::preparation::step::package_cast {
  template<typename EXACT> auto interface::is(Step const &candidate) -> bool {
    auto visitor = variant::Visitor{[](EXACT const &) { return true; },
                                    [](auto const &)  { return false; }};
    return visit(visitor, candidate);
  }
  auto interface::is_continued(Step const &candidate) -> bool { return is<Continued>(candidate); }
  auto interface::is_finished(Step const &candidate) -> bool  { return is<Finished>(candidate); }
  auto interface::is_failed(Step const &candidate) -> bool    { return is<Failed>(candidate); }
  auto interface::is_valid(Step const &candidate) -> bool {
    auto visitor = variant::Visitor{[](Continued const &) { return true; },
                                    [](Finished const &)  { return true; },
                                    [](Failed const &)    { return true; },
                                    [](auto const &)      { return false; }};
    return visit(visitor, candidate);
  }
  template<typename RESULT> auto interface::cast(Step const &candidate) -> RESULT requires required::Castable<RESULT> { return conjugate<Conjugations<Step const>, RESULT>(candidate); }
  template<typename RESULT> auto interface::cast(Step &candidate) -> RESULT requires required::Castable<RESULT>       { return conjugate<Conjugations<Step>, RESULT>(candidate); }
  template<typename CONJUGATIONS, typename RESULT, typename VARIANT> auto body::conjugate(VARIANT &candidate) -> RESULT {
    using Actual = typename traits::Cast<RESULT>::Basis;
    if constexpr (required::Pointer<RESULT>) {
      return visit(pointer::Selector<RESULT, Actual, CONJUGATIONS>{}, candidate);
    } else if constexpr (required::Reference<RESULT>) {
      return visit(reference::Selector<RESULT, Actual, CONJUGATIONS>{}, candidate);
    } else {
      throw exception::Unreachable{};
    }
  }
}
#endiv
#divert <cpp>
namespace {
  namespace testate {
    using namespace tunitas::keyston::protocol::preparation::step;
    // The constie
    static_assert(sizeof (cast<Continued const &>(Step{})));
    static_assert(sizeof (cast<Finished const &>(Step{})));
    static_assert(sizeof (cast<Failed const &>(Step{})));
    //
    static_assert(sizeof (cast<Continued const *>(Step{})));
    static_assert(sizeof (cast<Finished const *>(Step{})));
    static_assert(sizeof (cast<Failed const *>(Step{})));
    //
    // And the mutable
    static_assert(sizeof (cast<Continued &>(Step{})));
    static_assert(sizeof (cast<Finished &>(Step{})));
    static_assert(sizeof (cast<Failed &>(Step{})));
    //
    static_assert(sizeof (cast<Continued *>(Step{})));
    static_assert(sizeof (cast<Finished *>(Step{})));
    static_assert(sizeof (cast<Failed *>(Step{})));
  }
}
#endiv
