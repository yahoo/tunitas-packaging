// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
#import tunitas.keyston.daf.generic.required.Configuration
namespace tunitas::keyston::daf::generic {
  //
  // The definition of a generic (Distributed Aggregation) Function
  //
  // Specification:
  //
  //   I-D.irtf-cfrg-daf
  //   https://www.ietf.org/archive/id/draft-irtf-cfrg-daf-03.html
  //   https://www.ietf.org/archive/id/draft-irtf-cfrg-daf-04.html
  //   https://www.ietf.org/archive/id/draft-irtf-cfrg-daf-05.html
  //   Verifiable Distributed Aggregation Function
  //   Section 4. Distributed Aggregation Functions
  //
  //   The interface, as stated:
  //
  //   (a noun form)
  //   disassembly ........... Daf.measurement_to_input_shares(measurement: Measurement) -> (Bytes, Vec[Bytes])
  //   preparation ........... Daf.prep(agg_id: Unsigned, agg_param: AggParam, public_share: Bytes, input_share: Bytes) -> Vec[OutShare];
  //   amalgamation .......... Daf.out_shares_to_agg_share(agg_param: AggParam, out_shares: Vec[OutShare]) -> agg_share: Bytes
  //   reassembly ............ Daf.agg_shares_to_result(agg_param: AggParam, agg_shares: Vec[Bytes], num_measurements: Unsigned) -> AggResult
  //
  //   The interface terminology in the I-D.irtf-cfrg-daf is clunky. clangy, <audio> Clang, ClAnG, cLaNg, CLANG</audio>
  //
  // Obligations:
  //
  //   The call site (user) provide an explicit specializations as follows
  //
  //     template<> tunitas::keyston::daf::generic::Core<...somehow...>
  //     template<> tunitas::keyston::daf::generic::Configuration<Core, ...somehow...>
  //     template<> tunitas::keyston::daf::generic::Definition<Configuration>::Definition(Name); which is a constructor
  //
  // Design:
  //
  //   Just what you see.
  //   Definitions don't carry state.
  //
  // Usage:
  //
  //   Yes.
  //
  template<required::Configuration> struct Definition;
}
#endiv
#divert <hpp>
#import tunitas.keyston.daf.Name
#import tunitas.keyston.daf.generic.usage.Configuration
namespace tunitas::keyston::daf {
  namespace generic {
    using std::move;
    template<required::Configuration CONFIGURATION> inline auto swap(Definition<CONFIGURATION> &, Definition<CONFIGURATION> &) noexcept -> void;
  }
  template<generic::required::Configuration CONFIGURATION> struct generic::Definition {
    static_assert(usage::Configuration<CONFIGURATION>);
    using Name = daf::Name;
    using enum Name;
    //
    // Descendants will need these
    using Parameters = typename CONFIGURATION::Parameters;
    using Randomness = typename CONFIGURATION::Randomness;;
    using Processed = typename CONFIGURATION::Processed;;
    template<Slice SLICE> using Measurement = typename CONFIGURATION::template Measurement<SLICE>;
    template<Slice SLICE> using Public = typename CONFIGURATION::template Public<SLICE>;
    template<Slice SLICE> using Input = typename CONFIGURATION::template Input<SLICE>;
    template<Slice SLICE> using Output = typename CONFIGURATION::template Output<SLICE>;
    template<Slice SLICE> using Aggregation = typename CONFIGURATION::template Aggregation<SLICE>;
    //
    using Disassembled = typename CONFIGURATION::Disassembled;
    using Disassembly = typename CONFIGURATION::Disassembly;
    //
    using Computed = typename CONFIGURATION::Computed;
    using Computation = typename CONFIGURATION::Computation;
    //
    using Amalgamated = typename CONFIGURATION::Amalgamated;
    using Amalgamation = typename CONFIGURATION::Amalgamation;
    //
    using Reassembled = typename CONFIGURATION::Reassembled;
    using Reassembly = typename CONFIGURATION::Reassembly;
    //
    explicit Definition() = default;
    explicit Definition(Name); // callers MUST specialize this
  protected:
    friend auto generic::swap<>(Definition &, Definition &) noexcept -> void;
    Disassembly disassembly{};
    Computation computation{};
    Amalgamation amalgamation{};
    Reassembly reassembly{};
  };
}
#endiv
#divert <ipp>
namespace tunitas::keyston::daf {
  template<generic::required::Configuration CONFIGURATION> auto generic::swap(Definition<CONFIGURATION> &a, Definition<CONFIGURATION> &b) noexcept -> void {
    // These are pointers so the standard swap will be fone; the ADL-found swap(s) will be dubious-ambiguous-whatever.
    std::swap(a.disassembly, b.disassembly);
    std::swap(a.computation, b.computation);
    std::swap(a.amalgamation, b.amalgamation);
    std::swap(a.reassembly, b.reassembly);
  }
}
#endiv
