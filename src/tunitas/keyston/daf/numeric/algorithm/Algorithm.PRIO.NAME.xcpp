g// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
#import tunitas.keyston.daf.numeric.algorithm.Algorithm.template
namespace tunitas::keyston::daf::numeric::algorithm {
  //
  // The Distributed Aggregation Function Algorithm - PRIO
  //
  // Specification:
  //
  //   https://www.ietf.org/archive/id/draft-irtf-cfrg-vdaf-05.html
  //   There's some section in there that covers this.
  //   And there's papers in the references section; e.g. CGB2017
  //
  //   COUNT, SUM, HISTOGRAM
  //
  // Design:
  //
  //   Right out of the manual.
  //
  // Usage:
  //
  //   Within Definition<NAME> and Executor<NAME>
  //
  template<Name NAME> struct Algorithm<PRIO, NAME>;
}
#endiv
#divert <hpp>
#import tunitas.Tuple
#import tunitas.keyston.daf.numeric.algorithm.traits.Name
#import tunitas.keyston.prio.Algorithm
#import tunitas.keyston.daf.numeric.algorithm.Prototype
namespace tunitas::keyston::daf::numeric::algorithm {
  template<Name NAME> class Algorithm<PRIO, NAME> : public prio::Algorithm<traits::Name<NAME>::PRIO>, public Prototype {
    struct Ancestors {
      using Algorithm = prio::Algorithm<traits::Name<NAME>::PRIO>;
      using Prototype = algorithm::Prototype;
    };
  public:
    using Encoded = typename Ancestors::Algorithm::Encoded;
    using Field = typename Ancestors::Algorithm::Field;
#if 1
    // Otherwise it's too lugubrious to reference these in the ancestry
    template<shards::required::Shardable TYPE> using Shards = typename Ancestors::Prototype::Shards<TYPE>;
    template<array::required::Arrayable TYPE> using Series = typename Ancestors::Prototype::Series<TYPE>;
    using Randomness   = typename Ancestors::Prototype::Randomness;
    using Disassembled = typename Ancestors::Prototype::Disassembled;
    using Computed     = typename Ancestors::Prototype::Computed;
    using Amalgamated  = typename Ancestors::Prototype::Amalgamated;
    using Reassembled  = typename Ancestors::Prototype::Reassembled;
    using Processed    = typename Ancestors::Prototype::Processed;
    //
    template<Slice SLICE> using Measurement = typename Ancestors::Prototype::Measurement<SLICE>;
    template<Slice SLICE> using Input       = typename Ancestors::Prototype::Input<SLICE>;
    template<Slice SLICE> using Public      = typename Ancestors::Prototype::Public<SLICE>;
    template<Slice SLICE> using Output      = typename Ancestors::Prototype::Output<SLICE>;
    template<Slice SLICE> using Aggregation = typename Ancestors::Prototype::Aggregation<SLICE>;
#else
    template<shards::required::Shardable TYPE> using Shards = keyston::Shards<TYPE>;
    template<array::required::Arrayable TYPE> using Series = components::Series<TYPE>;
    using Randomness   = components::Randomness;
    using Disassembled = components::Disassembled;
    using Computed     = components::Computed;
    using Amalgamated  = components::Amalgamated;
    using Reassembled  = components::Reassembled;
    using Processed    = components::Processed;
    //
    template<Slice SLICE> using Measurement = components::Measurement<SLICE>;
    template<Slice SLICE> using Input       = components::Input<SLICE>;
    template<Slice SLICE> using Public      = components::Public<SLICE>;
    template<Slice SLICE> using Output      = components::Output<SLICE>;
    template<Slice SLICE> using Aggregation = components::Aggregation<SLICE>;
#endif
    //
    // Section 4.1 Sharding
    // a.k.a. measurement_to_input_shares(...)
    static auto disassembly(Parameters const &, Measurement<WHOLE> const &, Randomness const &) -> Disassembled;
    // Section 4.2 Preparation
    // a.k.a. prep(...)
    static auto computation(Parameters const &, Shard, Public<SHARE> const &, Input<SHARE> const &) -> Computed;
    // Section 4.4 Aggregation
    // a.k.a. out_shares_to_agg_share(...)
    static auto amalgamation(Parameters const &, Series<Output<SHARE>> const &) -> Amalgamated;
    // Section 4.5 Unsharding
    // a.k.a. agg_shares_to_result(...)
    static auto reassembly(Parameters const &, Shards<Aggregation<SHARE>> const &, Processed) -> Reassembled;
  private:
    static auto split(Parameters const &, Randomness const &, Encoded const &) -> Tuple<Encoded, Encoded>;
    static auto expand(typename Field::Underlying) -> Encoded;
  };
}
#endiv
#divert <tpp>
#import std.accumulate
#import tunitas.Tuple
#import tunitas.keyston.daf.exception.Invariant
#import tunitas.keyston.nonce.ennumerate // and ennumerate2(...)
#import tunitas.keyston.numeric.Augmentment
#import tunitas.keyston.numeric.Treatment
namespace tunitas::keyston::daf::numeric::algorithm {
  template<Name NAME> auto Algorithm<PRIO, NAME>::expand(typename Field::Underlying init) -> Encoded {
    auto ret = Encoded{};
    std::fill(ret.begin(), ret.end(), typename Field::Element{init});
    return ret;
  }
  template<Name NAME> auto Algorithm<PRIO, NAME>::split(Parameters const &parameters, Randomness const &randomness, Encoded const &original) -> Tuple<Encoded, Encoded> {
    auto [left_scalar, right_scalar] = nonce::ennumerate2(randomness);
    auto left = expand(left_scalar);
    auto right = expand(right_scalar);
#if 0
    // but some #imports are missing (above)
    std::cerr << "random " << left_scalar << ' ' << right_scalar << '\n';
    runtime_assert(Encoded{} == left - left);
    runtime_assert(Encoded{} == right - right);
    runtime_assert(original == original + Encoded{});
    runtime_assert(original == original + Encoded{} + left);
    using nonstd::int128::operator<<;
    std::cerr << "original " << underlying(original.at(0)) << '\n';
    std::cerr << "left " << underlying(left.at(0)) << '\n';
    std::cerr << "right " << underlying(right.at(0)) << '\n';
    std::cerr << "Encoded " << underlying((Encoded{}).at(0)) << '\n';
    std::cerr << "summation " << underlying((original).at(0)) << '\n';
    std::cerr << "summation " << underlying((original+Encoded{}).at(0)) << '\n';
    std::cerr << "summation " << underlying((original+Encoded{} + left).at(0)) << '\n';
    std::cerr << "summation " << underlying((original+Encoded{} + left - right).at(0)) << '\n';
    std::cerr << "subtract " << underlying((Encoded{} - right).at(0)) << '\n';
    std::cerr << "subtract " << underlying((left - right).at(0)) << '\n';
    std::cerr << "each " << underlying(original.at(0) - right.at(0)) << '\n';
    std::cerr << "both " << underlying((original - right).at(0)) << '\n';
    // this will only "work" when randomness is zero (in development test mode)
    runtime_assert(original == original + Encoded{} + left - right);
#endif
    return {original + left - right, Encoded{} - left + right};
  }
  template<Name NAME> auto Algorithm<PRIO, NAME>::disassembly(Parameters const &parameters, Measurement<WHOLE> const &wrapped, Randomness const &randomness) -> Disassembled {
    auto encode = [&parameters](measurement::Specimen specimen) -> Encoded {
      if constexpr (Name::HISTOGRAM == NAME) {
        return Ancestors::Algorithm::encode(specimen, parameters.boundaries.value());
      } else {
        return Ancestors::Algorithm::encode(specimen);
      }
    };
    auto [left, right] = split(parameters, randomness, encode(wrapped.value));
    auto publick = Public<SHARE>{};
    return {move(publick), Shards<Input<SHARE>>(move(left), move(right))};
  }
  template<Name _> auto Algorithm<PRIO, _>::computation(Parameters const &parameters, Shard, Public<SHARE> const &, Input<SHARE> const &input) -> Computed {
    auto treatment = Treatment{[&parameters](Encoded const &encoded) -> typename Ancestors::Algorithm::Truncated {
      return Ancestors::Algorithm::truncate(encoded);
    }};
    return Output<SHARE>{visit(treatment, input)};
  }
  template<Name _> auto Algorithm<PRIO, _>::amalgamation(Parameters const &, Series<Output<SHARE>> const &outputs) -> Amalgamated {
    if (outputs.empty()) { throw exception::Invariant{"empty amalgamation"}; }
    auto accumulate = [](typename Ancestors::Algorithm::Truncated &&accumulator, Output<SHARE> const &each) -> typename Ancestors::Algorithm::Truncated {
      auto treatment = Treatment{[](typename Ancestors::Algorithm::Truncated const &truncated) -> typename Ancestors::Algorithm::Truncated { return truncated; }};
      accumulator += visit(treatment, each);
      return move(accumulator);
    };
    auto accumulated = std::accumulate(outputs.begin(), outputs.end(), typename Ancestors::Algorithm::Truncated{}, accumulate);
    return Aggregation<SHARE>{move(accumulated)};
  }
  template<Name _> auto Algorithm<PRIO, _>::reassembly(Parameters const &parameters, Shards<Aggregation<SHARE>> const &aggregations, Processed count) -> Reassembled {
    if (aggregations.empty()) { throw exception::Invariant{"empty reassembly"}; }
    using Decoded = typename Ancestors::Algorithm::Decoded;
    auto accumulate = [count](Decoded &&accumulator, Aggregation<SHARE> const &each) -> Decoded {
      auto treatment = Treatment{[count](typename Ancestors::Algorithm::Truncated const &truncated) -> Decoded { return Ancestors::Algorithm::decode(truncated, count); }};
      accumulator += visit(treatment, each);
      return move(accumulator);
    };
    auto accumulated = std::accumulate(aggregations.begin(), aggregations.end(), Decoded{}, accumulate);
    return Aggregation<WHOLE>{move(accumulated)};
  }
}
#endiv
