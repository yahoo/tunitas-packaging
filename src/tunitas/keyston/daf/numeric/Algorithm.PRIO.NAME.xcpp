g// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
#import tunitas.keyston.daf.numeric.Algorithm.template
namespace tunitas::keyston::daf::numeric {
  //
  // The Distributed Aggregation Function Algorithm - PRIO
  //
  // Specification:
  //
  //   https://www.ietf.org/archive/id/draft-irtf-cfrg-vdaf-05.html
  //   There's some section in there that covers this.
  //   And there's papers in the references section; e.g. CGB2017
  //
  //   COUNT, SUM, HISTOGRAM
  //
  // Design:
  //
  //   Right out of the manual.
  //
  // Usage:
  //
  //   Within Definition<NAME> and Executor<NAME>
  //
  template<Name NAME> struct Algorithm<PRIO, NAME>;
}
#endiv
#divert <hpp>
#import tunitas.keyston.daf.numeric.traits.Algorithm
#import tunitas.keyston.prio.Algorithm
#import tunitas.keyston.daf.numeric.components
namespace tunitas::keyston::daf::numeric {
  template<Name NAME> class Algorithm<PRIO, NAME> : public prio::Algorithm<traits::Algorithm<NAME>::PRIO> {
    using Ancestor = prio::Algorithm<traits::Algorithm<NAME>::PRIO>;
  public:
    using Encoded = typename Ancestor::Encoded;
    template<shards::required::Shardable TYPE> using Shards = keyston::Shards<TYPE>;
    template<array::required::Arrayable TYPE> using Series = components::Series<TYPE>;
    using Randomness   = components::Randomness;
    using Disassembled = components::Disassembled;
    using Computed     = components::Computed;
    using Amalgamated  = components::Amalgamated;
    using Reassembled  = components::Reassembled;
    using Processed    = components::Processed;
    //
    template<Slice SLICE> using Measurement = components::Measurement<SLICE>;
    template<Slice SLICE> using Input       = components::Input<SLICE>;
    template<Slice SLICE> using Public      = components::Public<SLICE>;
    template<Slice SLICE> using Output      = components::Output<SLICE>;
    template<Slice SLICE> using Aggregation = components::Aggregation<SLICE>;
    //
    static auto disassembly(Parameters const &, Measurement<WHOLE> const &, Randomness const &) -> Disassembled;
    static auto computation(Parameters const &, Shard, Public<SHARE> const &, Input<SHARE> const &) -> Computed;
    static auto amalgamation(Parameters const &, Series<Output<SHARE>> const &) -> Amalgamated;
    static auto reassembly(Parameters const &, Shards<Aggregation<SHARE>> const &, Processed) -> Reassembled;
  };
}
#endiv
#divert <tpp>
#import std.accumulate
#import tunitas.Tuple
#import tunitas.keyston.daf.exception.Invariant
#import tunitas.keyston.numeric.Augmentment
#import tunitas.keyston.numeric.Treatment
namespace tunitas::keyston::daf::numeric {
  template<Name NAME> auto Algorithm<PRIO, NAME>::disassembly(Parameters const &parameters, Measurement<WHOLE> const &wrapped, Randomness const &) -> Disassembled {
    auto split = [&parameters](Encoded single) -> Tuple<Encoded, Encoded> {
      return {single, Encoded{}};
    };
    auto encode = [&parameters](measurement::Specimen specimen) -> Encoded {
      if constexpr (Name::HISTOGRAM == NAME) {
        return Ancestor::encode(specimen, parameters.boundaries.value());
      } else {
        return Ancestor::encode(specimen);
      }
    };
    auto [one, two] = split(encode(wrapped.value));
    auto publick = Public<SHARE>{};
    return {move(publick), Shards<Input<SHARE>>(move(one), move(two))};
  }
  template<Name _> auto Algorithm<PRIO, _>::computation(Parameters const &parameters, Shard, Public<SHARE> const &, Input<SHARE> const &input) -> Computed {
    auto treatment = Treatment{[&parameters](Encoded const &encoded) -> typename Ancestor::Truncated {
      return Ancestor::truncate(encoded);
    }};
    return Output<SHARE>{visit(treatment, input)};
  }
  template<Name _> auto Algorithm<PRIO, _>::amalgamation(Parameters const &, Series<Output<SHARE>> const &outputs) -> Amalgamated {
    if (outputs.empty()) { throw exception::Invariant{"empty amalgamation"}; }
    auto accumulate = [](typename Ancestor::Truncated &&accumulator, Output<SHARE> const &each) -> typename Ancestor::Truncated {
      auto treatment = Treatment{[](typename Ancestor::Truncated const &truncated) -> typename Ancestor::Truncated { return truncated; }};
      accumulator += visit(treatment, each);
      return move(accumulator);
    };
    auto accumulated = std::accumulate(outputs.begin(), outputs.end(), typename Ancestor::Truncated{}, accumulate);
    return Aggregation<SHARE>{move(accumulated)};
  }
  template<Name _> auto Algorithm<PRIO, _>::reassembly(Parameters const &parameters, Shards<Aggregation<SHARE>> const &aggregations, Processed count) -> Reassembled {
    if (aggregations.empty()) { throw exception::Invariant{"empty reassembly"}; }
    using Decoded = typename Ancestor::Decoded;
    auto accumulate = [count](Decoded &&accumulator, Aggregation<SHARE> const &each) -> Decoded {
      auto treatment = Treatment{[count](typename Ancestor::Truncated const &truncated) -> Decoded { return Ancestor::decode(truncated, count); }};
      accumulator += visit(treatment, each);
      return move(accumulator);
    };
    auto accumulated = std::accumulate(aggregations.begin(), aggregations.end(), Decoded{}, accumulate);
    return Aggregation<WHOLE>{move(accumulated)};
  }
}
#endiv
