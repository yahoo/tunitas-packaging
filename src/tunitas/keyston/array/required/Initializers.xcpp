// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
#import nonstd.required.Same_As
#import nonstd.required.Convertible_To
#import nonstd.required.Integer
#import tunitas.tuple.Element
#import tunitas.tuple.Tuple
#import std.remove_cvref
namespace tunitas::keyston::array::required {
  //
  // Are these types unambiguous in the various array initialize constructors?
  //
  // Specification:
  //
  //   Whereas the convention is to put the control channel and the data channel together in the constructor without ceremony;
  //   Herewith find some ceremony to disambiguate the size-inducing conversion constructor and the initializer list constructor.
  //
  //   Ambiguity arises in the descendants when Integer<VALUE>
  //   e.g. consider Container<int>
  //
  //     Container{3};            ... an array of three elemnets, value initialized (to zero)
  //     Container{3, 5};         ... an array of 3 elements, initialied with 5.
  //     Container{3, 5, 7, 9};   ... an array of 4 elements, initialied with 3, 5, 7, 9
  //
  // Usage:
  //  
  //    explicit Container(Size);
  //    explicit Container(Size, Value const &);
  //    template<typename... VALUES> Container(VALUE &&)          requires required::Initializers<Value, VALUES...>
  //    template<typename... VALUES> Container(Inplace, VALUE &&) requires required::Initializers<Value, VALUES...>
  //
  namespace [[eponymous]] initializers {
    using namespace tuple;
    template<typename TUPLE> concept Ambiguous = Integer<typename Element<0, TUPLE>::type>;
    template<typename VALUE, typename... ARGUMENTS> concept Initializers = requires(VALUE, ARGUMENTS...) {
      requires (Convertible_To<std::remove_cvref_t<ARGUMENTS>, VALUE> && ... );
      requires ((0 == sizeof...(ARGUMENTS)) ||
                (1 == sizeof...(ARGUMENTS) && !Ambiguous<Tuple<ARGUMENTS...>>) ||
                (2 == sizeof...(ARGUMENTS) && !Ambiguous<Tuple<ARGUMENTS...>>) ||
                (2 < sizeof...(ARGUMENTS)));
    };
  }
  using initializers::Initializers;
}
#endiv
#divert <cpp>
namespace {
  namespace testate {
    namespace required = tunitas::keyston::array::required;
    using Dubious = int;
    static_assert(nonstd::required::Integer<char unsigned>);
    static_assert(nonstd::required::Integer<std::tuple_element<0, std::tuple<char unsigned>>::type>);
    static_assert(nonstd::required::Integer<tunitas::tuple::Element<0, std::tuple<char unsigned>>::type>);
    static_assert(required::initializers::Ambiguous<std::tuple<char unsigned>>);
    //
    static_assert(   required::Initializers<Dubious>);
    //
    static_assert(not required::Initializers<Dubious, char *>);
    static_assert(not required::Initializers<Dubious, bool>);
    static_assert(    required::Initializers<Dubious, char>); // char is not an integer
    static_assert(not required::Initializers<Dubious, char unsigned>);
    static_assert(not required::Initializers<Dubious, char signed>);
    static_assert(not required::Initializers<Dubious, int signed>);
    static_assert(not required::Initializers<Dubious, int unsigned>);
    static_assert(not required::Initializers<Dubious, std::size_t>);
    static_assert(not required::Initializers<Dubious, decltype(33)>);
    //
    // the two arguments is still ambiguous
    static_assert(not required::Initializers<Dubious, decltype(3), decltype(5)>);
    //
    // more than two arguments is always unambiguously an initializer
    static_assert(required::Initializers<Dubious, decltype(3), decltype(5), decltype(7)>);
    static_assert(required::Initializers<Dubious, decltype(3), decltype(5), decltype(7), decltype(9)>);
  }
}
#endiv
