// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
#import tunitas.keyston.nonce.Bundle
#import tunitas.keyston.nonce.required.Bundleable
#import tunitas.keyston.nonce.required.Entropy
#import tunitas.keyston.nonce.generator.Generator.template
namespace tunitas::keyston::nonce::generator {
  //
  // Fill up a bundle of nonces
  // A generator-of-bundles is a bundle-of-generators
  // recall: a Bundle<NONCE...> cannot contain a Bundle<...>; a Bundle<NONCE...> can only contain a Bits<...> or a Since<...>
  //
  template<typename... NONCE, required::Entropy ENTROPY> requires required::Bundleable<NONCE...> struct Generator<Bundle<NONCE...>, ENTROPY>;
}
#endiv
#divert <hpp>
#import tunitas.keyston.nonce.generator.Generator.Bits.N
#import tunitas.keyston.nonce.generator.Generator.Since.PRECISION
namespace tunitas::keyston::nonce::generator {
  template<typename... NONCE, required::Entropy ENTROPY> requires required::Bundleable<NONCE...> class Generator<Bundle<NONCE...>, ENTROPY> : public Tuple<Generator<NONCE, ENTROPY>...> {
    using Ancestor = Tuple<Generator<NONCE, ENTROPY>...>;
  public:
    using Entropy = ENTROPY;
    inline explicit Generator(Entropy &held);
    using Result = Bundle<NONCE...>;
    inline auto operator()() -> Result;
  };
}
#endiv
#divert <ipp>
#import std.integer_sequence
#import std.make_index_sequence
#import std.size_t
#import std.get
namespace tunitas::keyston::nonce::generator {
  template<typename... NONCE, required::Entropy ENTROPY> Generator<Bundle<NONCE...>, ENTROPY>::Generator(Entropy &e) : Ancestor{Generator<NONCE, ENTROPY>{e}...} { }
  template<typename... N, required::Entropy E> auto Generator<Bundle<N...>,E>::operator()() -> Result {
    return [this]<std::size_t... INDEX>(std::integer_sequence<std::size_t, INDEX...>) -> Result {
      return {std::get<INDEX>(static_cast<Ancestor &>(*this)).operator()()...};
    }(std::make_index_sequence<std::tuple_size_v<Ancestor>>{});
  }
}
#endiv
#divert <cpp>
#import tunitas.keyston.nonce.usage.Generator
#import tunitas.keyston.nonce.Since
#import tunitas.keyston.nonce.Bits
#import tunitas.keyston.nonce.Bundle
#import tunitas.keyston.nonce.required.Bundleable
#import tunitas.keyston.entropy.None
#import std.declval
namespace {
  namespace testate {
    using namespace tunitas::keyston::nonce;
    namespace usage = tunitas::keyston::nonce::usage;
    using Entropy = tunitas::keyston::entropy::None;
#if 1
    static_assert(usage::Generator<Generator<Bundle<Bits<1>>, Entropy>>);
    static_assert(usage::Generator<Generator<Bundle<Since<std::chrono::seconds>>, Entropy>>);
    static_assert(usage::Generator<Generator<Bundle<Since<std::chrono::seconds>>, Entropy>>);
    static_assert(usage::Generator<Generator<Bundle<Since<std::chrono::seconds>>, Entropy>>);
    static_assert(usage::Generator<Generator<Bundle<Since<std::chrono::seconds>, Bits<1>>, Entropy>>);
    static_assert(usage::Generator<Generator<Bundle<Bits<1>, Since<std::chrono::seconds>>, Entropy>>);
#else
    namespace required = tunitas::keyston::nonce::required;
    //
    static_assert(sizeof (Since<std::chrono::seconds>));
    static_assert(required::Bundleable<Since<std::chrono::seconds>>);
    static_assert(sizeof (Bundle<Since<std::chrono::seconds>>));
    static_assert(sizeof (Generator<Bundle<Since<std::chrono::seconds>>, Entropy>));
    static_assert(sizeof (std::declval<Generator<Bundle<Since<std::chrono::seconds>>, Entropy>>()));
    static_assert(sizeof (std::declval<Generator<Bundle<Since<std::chrono::seconds>>, Entropy>>().operator()()));
    static_assert(sizeof (std::declval<Generator<Bundle<Bits<1>>>>().operator()()));
    static_assert(sizeof (std::declval<Generator<Bundle<Since<std::chrono::seconds>, Bits<1>>, Entropy>>().operator()()));
    static_assert(sizeof (std::declval<Generator<Bundle<Bits<1>, Since<std::chrono::seconds>>, Entropy>>().operator()()));
    using Specimen = Generator<Bundle<Bits<1>>, Entropy>;
    static_assert(not std::is_default_constructible_v<Specimen>);
    static_assert(    std::is_copy_constructible_v<Specimen>);
    static_assert(    std::is_move_constructible_v<Specimen>);
    static_assert(not std::is_copy_assignable_v<Specimen>, "there are references inside");
    static_assert(not std::is_move_assignable_v<Specimen>, "there are references inside");
    static_assert(not std::is_swappable_v<Specimen>);
#endif
  }
}
#endiv
