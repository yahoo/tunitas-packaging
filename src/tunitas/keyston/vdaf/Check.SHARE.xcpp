// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
#import tunitas.keyston.vdaf.Check.template
namespace tunitas::keyston::vdaf::check {
  //
  // This is a "prep share" in the nomenclature of the (draft) standard
  //
  template<required::Definition DEFINITION> struct Check<SHARE, DEFINITION>;
}
#endiv
#divert <hpp>
#import tunitas.Tuple
namespace tunitas::keyston::vdaf::check {
  template<required::Definition DEFINITION> class Check<SHARE, DEFINITION> : public octets::Fixed<Outline<DEFINITION>::share_size()> {
    using Outline = check::Outline<DEFINITION>;
    using Ancestor = octets::Fixed<Outline::share_size()>;
  public:
    Check() = default;
    using Ancestor::Fixed;
    constexpr Check(Ancestor const &a) : Ancestor{a} { }
    //
    using Uncoded = typename Outline::Uncoded;
    using Decoded = typename Outline::Decoded;
    using Encoded = typename Outline::Encoded;
    //
    // def encode_prep_share(Prio3, verifier, k_joint_rand): -> Bytes
    inline static constexpr auto encode(typename Uncoded::Verifier::View::Fixed, typename Uncoded::Randomness::View::Fixed) -> Check;
    //
    // def decode_prep_share(Prio3, encoded): -> Tuple<Verifier, Joint> (a.k.a. 
    inline static constexpr auto decode(Check const &c) -> Tuple<typename Decoded::Verifier::Storage, typename Decoded::Randomness::Storage> { return decode(static_cast<view::Variable<Octet>>(c)); }
    inline static constexpr auto decode(view::Variable<Octet>) -> Tuple<typename Decoded::Verifier::Storage, typename Decoded::Randomness::Storage>;
  };
}
#endiv
#divert <ipp>
#import tunitas.keyston.octets.Fixed
#import tunitas.keyston.octets.slice_off
#import tunitas.keyston.prio.exception.Decode
#import std.copy
namespace tunitas::keyston::vdaf::check {
  //
  // Section 7.2.6.1 Message Serialization
  //
  template<required::Definition _> constexpr auto Check<SHARE, _>::encode(typename Uncoded::Verifier::View::Fixed verifier, typename Uncoded::Randomness::View::Fixed joint) -> Check {
    auto ret = Check{};
    auto position = Uncoded::Verifier::Vector::encode_into(verifier, ret.begin());
    if constexpr (Outline::use_joint_randomness()) {
      std::copy(joint.begin(), joint.end(), position);
    }
    return ret;
  }
  template<required::Definition _> constexpr auto Check<SHARE, _>::decode(view::Variable<Octet> encoded0) -> Tuple<typename Decoded::Verifier::Storage, typename Decoded::Randomness::Storage> {
    auto [verifier_view, encoded1] = octets::slice_off<typename Encoded::Verifier::View::Fixed, prio::exception::Decode>(encoded0);
    auto verifier = Uncoded::Verifier::Vector::decode(verifier_view);
    if constexpr (!Outline::use_joint_randomness()) {
      if (!encoded1.empty()) {
        throw prio::exception::Decode{};
      } else {
        return {move(verifier), typename Decoded::Randomness::Storage{}};
      }
    } else {
      auto [randomness_view, encoded2] = octets::slice_off<typename Encoded::Randomness::View::Fixed, prio::exception::Decode>(encoded1);
      if (!encoded2.empty()) {
        throw prio::exception::Decode{};
      } else {
        return {move(verifier), typename Decoded::Randomness::Storage{randomness_view}};
      }
    }
  }
}
#endiv
