// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc, 2022.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
namespace tunitas::keyston::vdaf::generic::continued {
  namespace package_cast {
    namespace body::exported { }
    namespace interface = body::exported;
  }
  using namespace package_cast::interface;
}
#forward tunitas.keyston.vdaf.generic.continued.Continued
#import tunitas.keyston.vdaf.generic.required // ctcnr (cascade that certain 'namespace required')
#import std.same_as
#import std.is_const
#import std.remove_const
#import nonstd.required.Pointer
#import nonstd.required.Reference
namespace tunitas::keyston::vdaf::generic::continued::package_cast::body {
  template<typename> struct Conjugations;
  template<required::Configuration CONFIGURATION> struct Conjugations<Continued<CONFIGURATION>>;
  template<required::Configuration CONFIGURATION> struct Conjugations<Continued<CONFIGURATION> const>;
  using namespace std; // at least same_as, remove_const, is_const and _v _t
  namespace pointer {
    template<required::Pointer RESULT, typename ACTUAL, typename MATCH> struct Each;
    template<required::Pointer RESULT, typename ACTUAL, typename... MATCHES> struct Conjugator;
    template<required::Pointer RESULT, typename ACTUAL, typename CONJUGATIONS> struct Selector;
  }
  namespace reference {
    template<required::Reference RESULT, typename ACTUAL, typename MATCH> struct Each;
    template<required::Reference RESULT, typename ACTUAL, typename... MATCHES> struct Conjugator;
    template<required::Reference RESULT, typename ACTUAL, typename CONJUGATIONS> struct Selector;
  }
}
#endiv
#divert <hpp>
#forward tunitas.keyston.vdaf.generic.continued.alternatives
#import tunitas.keyston.vdaf.generic.continued.required.Castable
#import tunitas.keyston.vdaf.generic.continued.required.Queryable
#import tunitas.keyston.vdaf.Visitor
#import tunitas.keyston.vdaf.exception.Cast
namespace tunitas::keyston::vdaf::generic::continued {
  namespace package_cast::body {
    namespace exported {
      // 
      // The variant cast
      //
      // Specification:
      //
      //   Conjugations for all of them: Again<CONFIGURATION>, Final<CONFIGURATION>
      //   Conjugations for constie and mutable variants.
      //
      // Exceptions:
      //
      //   The reference-returning variants throw an exception::Cast if the cast cannot be performed.
      //   The pointer-returning variants merely return nullptr.
      //
      // Design:
      //
      //   Carefully to avoid copy pasta (and yet continued::cast<...>(...) and continued::cast<...>(...) are copy-pasta in different namespaces for the ADL)
      //
      //   The predicates: is_again(...) and is_final(...) should be discoverable by ADL.
      //   cast<RESULT>(...) need not be discoverable by ADL because you'll be uttering continued::cast<RESULT(...) anyway.  [[rly?]]
      //
      // Usage:
      //
      //   Both constie and mutable variants following this pattern of usage
      //
      //   auto const &emp = continued::cast<continued::Again<CONFIGURATION> const &>(candidate);
      //   auto const &tim = continued::cast<continued::Final<CONFIGURATION> const &>(candidate);
      //
      //   auto const *emp = continued::cast<continued::Again<CONFIGURATION> const *>(candidate);
      //   auto const *tim = continued::cast<continued::Final<CONFIGURATION> const *>(candidate);
      //
      template<required::Queryable EXACT, required::Configuration CONFIGURATION> inline auto is(Continued<CONFIGURATION> const &) -> bool;
      template<required::Configuration CONFIGURATION> inline auto is_again(Continued<CONFIGURATION> const &) -> bool;
      template<required::Configuration CONFIGURATION> inline auto is_final(Continued<CONFIGURATION> const &) -> bool;
      //
      template<typename RESULT, required::Configuration CONFIGURATION> inline auto cast(Continued<CONFIGURATION> const &) -> RESULT requires required::Castable<RESULT>;
      template<typename RESULT, required::Configuration CONFIGURATION> inline auto cast(Continued<CONFIGURATION> &) -> RESULT requires required::Castable<RESULT>;
    }
    template<typename CONJUGATIONS, typename RESULT, typename VARIANT> inline auto conjugate(VARIANT &) -> RESULT;
    template<required::Configuration CONFIGURATION> struct Conjugations<Continued<CONFIGURATION>> {
      using Again = continued::Again<CONFIGURATION>;
      using Final = continued::Final<CONFIGURATION>;
    };
    template<required::Configuration CONFIGURATION> struct Conjugations<Continued<CONFIGURATION> const> {
      using Again = continued::Again<CONFIGURATION> const;
      using Float = continued::Final<CONFIGURATION> const;
    };
    template<required::Pointer RESULT, typename ACTUAL, typename MATCH> struct pointer::Each {
      static_assert(!is_const_v<RESULT>);
      static_assert(!is_const_v<ACTUAL>);
      // MATCH may or may not be constie
      auto operator()(MATCH &candidate) -> RESULT {
        if constexpr (same_as<ACTUAL, remove_const_t<MATCH>>) {
          return &candidate;
        } else {
          return nullptr;
        }
      }
    };
    template<required::Reference RESULT, typename ACTUAL, typename MATCH> struct reference::Each {
      static_assert(!is_const_v<RESULT>);
      static_assert(!is_const_v<ACTUAL>);
      // MATCH may or may not be constie
      auto operator()(MATCH &candidate) -> RESULT {
        if constexpr (same_as<ACTUAL, remove_const_t<MATCH>>) {
          return candidate;
        } else {
          throw exception::Cast{typeid(remove_const_t<MATCH>)};
        }
      }
    };
    template<required::Pointer RESULT, typename ACTUAL, typename... MATCHES> struct pointer::Conjugator : public Visitor<Each<RESULT, ACTUAL, MATCHES>...> { };
    template<required::Reference RESULT, typename ACTUAL, typename... MATCHES> struct reference::Conjugator : public Visitor<Each<RESULT, ACTUAL, MATCHES>...> { };
    //
    template<required::Pointer RESULT, typename ACTUAL, typename CONJUGATIONS> struct pointer::Selector : public Conjugator<RESULT, ACTUAL,
                                                                                                                            typename CONJUGATIONS::Again,
                                                                                                                            typename CONJUGATIONS::Final> { };
    template<required::Reference RESULT, typename ACTUAL, typename CONJUGATIONS> struct reference::Selector : public Conjugator<RESULT, ACTUAL,
                                                                                                                                typename CONJUGATIONS::Again,
                                                                                                                                typename CONJUGATIONS::Final> { };
  }
  //
  // Must import the declarations directly so that ADL will find them from the argument Continued<CONFIGURATION>
  //
  using package_cast::body::exported::is;
  using package_cast::body::exported::is_again;
  using package_cast::body::exported::is_final;
  using package_cast::body::exported::cast;
}
#endiv
#divert <ipp>
#import tunitas.keyston.vdaf.exception.Cast
#import tunitas.keyston.vdaf.generic.continued.traits.Cast
#import tunitas.keyston.vdaf.generic.continued.Continued
#import tunitas.keyston.vdaf.Visitor
#import tunitas.variant.visit
#import nonstd.exception.Unreachable
#import nonstd.required.Pointer
#import nonstd.required.Reference
namespace tunitas::keyston::vdaf::generic::continued::package_cast {
  template<required::Queryable EXACT, required::Configuration CONFIGURATION> auto interface::is(Continued<CONFIGURATION> const &candidate) -> bool {
    auto visitor = Visitor{[](EXACT const &) { return true; },
                           [](auto const &)  { return false; }};
    return visit(visitor, candidate);
  }
  template<required::Configuration CONFIGURATION> auto interface::is_again(Continued<CONFIGURATION> const &candidate) -> bool { return is<Again<CONFIGURATION>>(candidate); }
  template<required::Configuration CONFIGURATION> auto interface::is_final(Continued<CONFIGURATION> const &candidate) -> bool { return is<Final<CONFIGURATION>>(candidate); }
  template<typename RESULT, required::Configuration CONFIGURATION> auto interface::cast(Continued<CONFIGURATION> const &candidate) -> RESULT requires required::Castable<RESULT> { return conjugate<Conjugations<Continued<CONFIGURATION> const>, RESULT>(candidate); }
  template<typename RESULT, required::Configuration CONFIGURATION> auto interface::cast(Continued<CONFIGURATION> &candidate) -> RESULT requires required::Castable<RESULT>       { return conjugate<Conjugations<Continued<CONFIGURATION>>, RESULT>(candidate); }
  template<typename CONJUGATIONS, typename RESULT, typename VARIANT> auto body::conjugate(VARIANT &candidate) -> RESULT {
    using Actual = typename traits::Cast<RESULT>::Basis;
    if constexpr (required::Pointer<RESULT>) {
      return visit(pointer::Selector<RESULT, Actual, CONJUGATIONS>{}, candidate);
    } else if constexpr (required::Reference<RESULT>) {
      return visit(reference::Selector<RESULT, Actual, CONJUGATIONS>{}, candidate);
    } else {
      throw exception::Unreachable{};
    }
  }
}
#endiv
#divert <cpp>
#import tunitas.keyston.vdaf.generic.continued.alternatives
#import tunitas.keyston.vdaf.generic.continued.Continued
#import tunitas.keyston.vdaf.Configuration
namespace {
  namespace testate {
    namespace continued = tunitas::keyston::vdaf::generic::continued;
    using tunitas::keyston::vdaf::generic::continued::cast;
    using tunitas::keyston::vdaf::Configuration;
    using enum tunitas::keyston::Scheme;
    //
    using Specimen = continued::Continued<Configuration<PROTOCOL>>; // ... pick one, any one will do
    using Again = continued::Again<Configuration<PROTOCOL>>; // .......... eadem ratione
    using Final = continued::Final<Configuration<PROTOCOL>>; // .......... eadem ratione
    //
    // The constie
    static_assert(sizeof (cast<Again const &>(Specimen{})));
    static_assert(sizeof (cast<Final const &>(Specimen{})));
    //
    static_assert(sizeof (cast<Again const *>(Specimen{})));
    static_assert(sizeof (cast<Final const *>(Specimen{})));
    //
    // And the mutable
    static_assert(sizeof (cast<Again &>(Specimen{})));
    static_assert(sizeof (cast<Final &>(Specimen{})));
    //
    static_assert(sizeof (cast<Again *>(Specimen{})));
    static_assert(sizeof (cast<Final *>(Specimen{})));
  }
}
#endiv
