// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc, 2022.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
#import tunitas.keyston.vdaf.generic.required.Configuration
namespace tunitas::keyston::vdaf::generic {
  //
  // The definition of a generic (Verifiable Distributed Aggregation) Function
  //
  // Specification:
  //
  //   I-D.irtf-cfrg-vdaf
  //   https://www.ietf.org/archive/id/draft-irtf-cfrg-vdaf-03.html
  //   Verifiable Distributed Aggregation Function
  //
  //   The interface, as stated:
  //
  //   (a noun form)
  //   disassembly ........... Vdaf.measurement_to_input_shares(measurement: Measurement) -> (Bytes, Vec[Bytes])
  //   initialization ........ Vdaf.prep_init(verify_key: Bytes, agg_id: Unsigned, agg_param: AggParam, nonce: Bytes, public_share: Bytes, input_share: Bytes) -> Prep
  //   continuation .......... Vdaf.prep_next(prep: Prep, inbound: Optional[Bytes]) -> Union[Tuple[Prep, Bytes], OutShare]
  //   amalgamation .......... Vdaf.prep_shares_to_prep(agg_param: AggParam, prep_shares: Vec[Bytes]) -> Bytes
  //   disgorgement .......... Vdaf.out_shares_to_agg_share(agg_param: AggParam, out_shares: Vec[OutShare]) -> agg_share: Bytes
  //   reassembly ............ Vdaf.agg_shares_to_result(agg_param: AggParam, agg_shares: Vec[Bytes], num_measurements: Unsigned) -> AggResult
  //
  //   The interface terminology in the I-D.irtf-cfrg-vdaf is clunky. clang, Clang, ClAnG, CLANG
  //
  // Obligations:
  //
  //   The call site (user) provide an explicit specializations as follows
  //
  //     template<> tunitas::keyston::vdaf::generic::Core<...somehow...>
  //     template<> tunitas::keyston::vdaf::generic::Configuration<Core, ...somehow...>
  //     template<> tunitas::keyston::vdaf::generic::Definition<Configuration>:: Definition(Name);
  //
  // Design:
  //
  //   Just what you see.
  //   Definitions don't carry state.
  //
  // Usage:
  //
  //   Yes.
  //
  template<required::Configuration> struct Definition;
}
#endiv
#divert <hpp>
#import tunitas.keyston.vdaf.Name
#import tunitas.keyston.vdaf.generic.usage.Configuration
namespace tunitas::keyston::vdaf {
  namespace generic {
    using std::move;
    template<required::Configuration CONFIGURATION> inline auto swap(Definition<CONFIGURATION> &, Definition<CONFIGURATION> &) noexcept -> void;
  }
  template<generic::required::Configuration CONFIGURATION> struct generic::Definition {
    static_assert(usage::Configuration<CONFIGURATION>);
    using Name = vdaf::Name;
    using enum Name;
    //
    // Descendants will need these
    using Parameters = typename CONFIGURATION::Parameters;
    using Nonce = typename CONFIGURATION::Nonce;
    using Verify_Key = typename CONFIGURATION::Verify_Key;
    template<Slice SLICE> using Seed = typename CONFIGURATION::template Seed<SLICE>;
    template<Slice SLICE> using Input = typename CONFIGURATION::template Input<SLICE>;
    template<Slice SLICE> using Preparation = typename CONFIGURATION::template Preparation<SLICE>;
    template<Slice SLICE> using Output = typename CONFIGURATION::template Output<SLICE>;
    template<Slice SLICE> using Aggregation = typename CONFIGURATION::template Aggregation<SLICE>;
    //
    using Disassembled = typename CONFIGURATION::Disassembled;
    using Disassembly = typename CONFIGURATION::Disassembly;
    //
    using Initialized = typename CONFIGURATION::Initialized;
    using Initialization = typename CONFIGURATION::Initialization;
    //
    using Continued = typename CONFIGURATION::Continued;
    using Continuation = typename CONFIGURATION::Continuation;
    //
    using Amalgamated = typename CONFIGURATION::Amalgamated;
    using Amalgamation = typename CONFIGURATION::Amalgamation;
    //
    using Disgorged = typename CONFIGURATION::Disgorged;
    using Disgorgement = typename CONFIGURATION::Disgorgement;
    //
    using Reassembled = typename CONFIGURATION::Reassembled;
    using Reassembly = typename CONFIGURATION::Reassembly;
    //
    explicit Definition() = default;
    explicit Definition(Name); // callers MUST specialize this
  protected:
    friend auto generic::swap<>(Definition &, Definition &) noexcept -> void;
    Disassembly disassembly{};
    Initialization initialization{};
    Continuation continuation{};
    Amalgamation amalgamation{};
    Disgorgement disgorgement{};
    Reassembly reassembly{};
  };
}
#endiv
#divert <ipp>
namespace tunitas::keyston::vdaf {
  template<generic::required::Configuration CONFIGURATION> auto generic::swap(Definition<CONFIGURATION> &a, Definition<CONFIGURATION> &b) noexcept -> void {
    swap(a.disassembly, b.disassembly);
    swap(a.initialization, b.initialization);
    swap(a.continuation, b.continuation);
    swap(a.amalgamation, b.amalgamation);
    swap(a.disgorgement, b.disgorgement);
    swap(a.reassembly, b.reassembly);
  }
}
#endiv
