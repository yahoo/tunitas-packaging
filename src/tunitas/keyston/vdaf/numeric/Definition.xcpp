// This is -*- c++ -*- nearly C++2a with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
#import tunitas.keyston.vdaf.Name
#import tunitas.keyston.quantity.Items
namespace tunitas::keyston::vdaf::numeric {
  //
  // Constants of PRIO as indexed by Name
  //
  // Authorities:
  //
  //   https://www.ietf.org/archive/id/draft-irtf-cfrg-vdaf-05.html
  //   Verifiable Distributed Aggregation Functions
  //
  // Specification:
  //
  //   Section 5. Definition of VDAFs
  //   Table 2. Constants and types defined for each VDAF
  //
  //   Section 7. Prio3
  //   Table 5: VDAF parameters for Prio3.
  //
  // Design:
  //
  //   No.  Actually Yes.
  //   Many values need to vary by the algorithm.
  //
  // Usage:
  //
  //   using Indexed = vdaf::numeric::Definition<Name:SOMETHING>;
  //
  namespace [[eponymous]] definition {
    using quantity::Items;
    template<typename PERSONALITY> struct Convenience;
    template<vdaf::Name> struct Personality;
    template<> struct Personality<vdaf::Name::PRIO3_COUNT>;
    template<> struct Personality<vdaf::Name::PRIO3_SUM>;
    template<> struct Personality<vdaf::Name::PRIO3_HISTOGRAM>;
    // TODO Name::POPLAR
    // TODO Name::DOPLAR
    template<vdaf::Name> struct Definition;
  }
  using definition::Definition;
}
#endiv
#divert <hpp>
#import tunitas.keyston.vdaf.constants
#import tunitas.keyston.prio.Definition
#import tunitas.keyston.prio.Customizer
namespace tunitas::keyston::vdaf::numeric {
  template<typename PERSONALITY> struct definition::Convenience {
    inline static constexpr auto const VERIFY_KEY_SIZE = constants::VERIFY_KEY_BYTE_COUNT;
  };
  namespace definition {
    template<> struct Personality<vdaf::Name::PRIO3_COUNT> : public prio::Definition<prio::Name::COUNT> {
      inline static constexpr auto const VDAF = vdaf::Name::PRIO3_COUNT;
      using Customizer = prio::Customizer<VDAF>;
      inline static constexpr auto const ROUND_COUNT = Items{1u};
      static_assert(sizeof(ROUND_COUNT), "from the ancestor");
      static_assert(sizeof(NONCE_SIZE), "from the ancestor");
    };
    template<> struct Personality<vdaf::Name::PRIO3_SUM> : public prio::Definition<prio::Name::SUM> {
      inline static constexpr auto const VDAF = vdaf::Name::PRIO3_SUM;
      using Customizer = prio::Customizer<VDAF>;
      static_assert(sizeof(ROUND_COUNT), "from the ancestor");
      static_assert(sizeof(NONCE_SIZE), "from the ancestor");
    };
    template<> struct Personality<vdaf::Name::PRIO3_HISTOGRAM> : public prio::Definition<prio::Name::HISTOGRAM> {
      inline static constexpr auto const VDAF = vdaf::Name::PRIO3_HISTOGRAM;
      using Customizer = prio::Customizer<VDAF>;
      static_assert(sizeof(ROUND_COUNT), "from the ancestor");
      static_assert(sizeof(NONCE_SIZE), "from the ancestor");
    };
    // TODO Personality<vdaf::Name::POPLAR1>
    // TODO Personality<vdaf::Name::DOPLAR_SOMETING>
  }
  template<vdaf::Name NAME> struct definition::Definition : public Personality<NAME>, public Convenience<Personality<NAME>> { };
}
#endiv
