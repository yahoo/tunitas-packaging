// This is -*- c++ -*- nearly C++2a with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
#import tunitas.keyston.crypto.keccak.Keccak.template
namespace tunitas::keyston::crypto::keccak {
  //
  // Authorities:
  //
  //   The usual, see tunitas.keyston.crypto.algorithm.Keccak.template.
  //
  // Specification:
  //
  //   The two termination bits that are unique to this variant.
  //
  //   This padding shows up in Keccak<256,0b00>:::final() - Digest
  //   two zero bits (NIST SP 800 185, page 16, line 343-345) ----------------\\ (here)
  //                                                                          ||
  //                                                                        vv
  //   KECCAK[256](bytepad(encode_string(S) || encode_string(N), 168) || X || 00, L).
  //
  //
  //   See SP 800-185, page 15, lines 237-333
  //
  //   cSHAKE128(X, L, S, N):
  //   Validity Conditions: len(S)< 2^2040 and len(N)< 2^2040
  //   Note that the numbers 168 and 136 are rates (in bytes) of the KECCAK[256] and KECCAK[512] sponge functions, respectively;
  //   and the characters 00 in the Courier New font in these definitions specify two zero bits.
  //
  //     1. If S = "" and N = "":
  //          return SHAKE128(X, L);
  //     2. Else:
  //          return KECCAK[256](bytepad(encode_string(S) || encode_string(N), 168) || X || 00, L).
  //
  //   See FIPS 292, SHA-3 Standard: Permutation-Based Hash and Extendable-Output Functions,page 20 & 21
  //   Section 6.2 SHA-3 Extendable-Output Functions
  //   Section 6.3 Alternate Definitions of SHA-3 Extendable-Outoupt Functions
  //
  //     RawSHAKE128(J, d) = KECCAK[256] (J || 11, d),
  //     RawSHAKE256(J, d) = KECCAK[512] (J || 11, d).
  //     SHAKE128(M, d) = RawSHAKE128 (M || 11, d),
  //     SHAKE256(M, d) = RawSHAKE256 (M || 11, d).
  //
  //     SHAKE128(M, d) = KECCAK[256] (M || 1111, d),
  //     SHAKE256(M, d) = KECCAK[512] (M || 1111, d).
  //

  //
  // Design:
  //
  //   recall: we need "twice the width" for KECCAK as for the SHAKE series
  //   SHAKE-128 ---> KECCAK-256 with 0b111
  //   cSHAKE-128 --> KECCAK-256 with 0b00
  //
  //   copy-pasta from the tutorial
  //   https://www.cryptopp.com/wiki/Keccak
  //
  template<> struct Keccak<256,0b00,2>;
}
#endiv
#divert <hpp>
#import cryptopp.Keccak
#import tunitas.keyston.crypto.keccak.Interface
namespace tunitas::keyston::crypto::keccak {
  template<> class Keccak<256,0b00u,2> : public Interface, protected cryptopp::Keccak_Final<256/8> {
    using Implementation = cryptopp::Keccak_Final<256/8>;
    static_assert(std::same_as<Implementation, cryptopp::Keccak_256>);
  protected:
    auto Update(cryptopp::byte const *data, size_t size) -> void override   { return Implementation::Update(data, size); }
    auto TruncatedFinal(cryptopp::byte *data, size_t size) -> void override { return Interface::perform_final_with_padding(data, size); }
    auto BlockSize() const -> unsigned int override                         { return Implementation::BlockSize(); }
    auto Restart() -> void override                                         { return Implementation::Restart(); }
    auto State() -> cryptopp::word64 * override                             { return Implementation::m_state; }
    auto ValidateSize(size_t size) const -> void override                   { return Implementation::ThrowIfInvalidTruncatedSize(size); }
    //
    auto perform_padding() -> void override;
    //
    // The second half of the PAD10*1 rule herein as PAD10<--->PAD01
    //
    //                                                          76543 2 10  
    inline static constexpr auto const PAD10 = cryptopp::byte{0b00000'1'00u}; // [[recall]] shown in bigend, layout in littlend
    //                                                          ^^^^^ ^ ^^
    // the zeros of pad1*0 -------------------------------------///// | ||
    // the commencement of pad10* of pad10*1 -------------------------/ ||
    // termination bits (2 bits) of the algo ---------------------------//
  };
}
#endiv
#divert <cpp>
#import tunitas.keyston.exception.Null
namespace tunitas::keyston::crypto::keccak {
  auto Keccak<256,0b00,2>::perform_padding() -> void {
    auto state{Implementation::m_state.BytePtr()};
    state[Implementation::m_counter] ^= PAD10;
    state[Implementation::r()-1]     ^= PAD01;
  }
}
#endiv
