// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
#import tunitas.keyston.name.required.Renderable
namespace tunitas::keyston::name {
  //
  // The common idiom of to_string (as free functions discoverable by ADL)
  //
  // Specification:
  //
  //   You know.
  //
  // Obligations:
  //
  //   The by::Optional variant of to_string_view(by::Optional, TYPE const &) must already exist,
  //   specifically:
  //      auto xyzzy::to_string_view(error::by::Optional, Name) > error::Optional<string::View>;
  //
  // Design:
  //
  //   With error:by::Optional, Outcome, Error
  //
  //   The render(TYPE) function is found by ADL per required::Renderable<TYPE>
  //
  // Usage:
  //
  //   Hack The Spew.
  //    namespace tunitas::keyston {
  //      auto xyzzy::to_string_view(error::by::Optional, Name) > error::Optional<string::View>; .................... IMPLEMENT THIS
  //      auto xyzzy::to_string_view(error::by::Outcome, Name) > error::Outcome<string::View> { return name::To_String<Name>::invoke(by, name); }
  //      auto xyzzy::to_string_view(error::by::Exception, Name) > string::View               { return name::To_String<Name>::invoke(by, name); }
  //    }
  //
  template<required::Renderable TYPE> struct To_String_View;
}
#endiv
#divert <hpp>
#import tunitas.error.by.Optional
#import tunitas.error.by.Outcome
#import tunitas.error.by.Exception
#import tunitas.error.Optional
#import tunitas.error.Outcome
#import tunitas.error.Code
#import tunitas.exception.Invalid
#import tunitas.string.View
namespace tunitas::keyston {
  template<name::required::Renderable TYPE> struct name::To_String_View {
    using Value = TYPE;
    inline static auto invoke(error::by::Optional, Value const &) -> error::Optional<string::View>;
    inline static auto invoke(error::by::Outcome, Value const &) -> error::Outcome<string::View>;
    inline static auto invoke(error::by::Exception, Value const &) -> string::View;
  protected:
    struct On_Error {
      inline static constexpr auto CODE = error::Code::FAILURE;
      using Code = std::remove_cv_t<decltype(CODE)>;
      using Exception = exception::Invalid;
    };
  };
}
#endiv
#divert <ipp>
#import std.error_code
namespace tunitas::keyston::name {
  template<required::Renderable _> auto To_String_View<_>::invoke(error::by::Optional by, Value const &value) -> error::Optional<string::View> { return render(value); }
  template<required::Renderable _> auto To_String_View<_>::invoke(error::by::Outcome by, Value const &value) -> error::Outcome<string::View> {
    if (auto got=render(value); got) {
      return *got;
    } else {
      return std::error_code{On_Error::CODE};
    }
  }
  template<required::Renderable _> auto To_String_View<_>::invoke(error::by::Exception by, Value const &value) -> string::View {
    if (auto got=render(value); got) {
      return *got;
    } else {
      throw typename On_Error::Exception{std::error_code{On_Error::CODE}.message()};
    }
  }
}
#endiv
