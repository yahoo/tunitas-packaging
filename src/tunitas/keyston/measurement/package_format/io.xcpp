// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <hpp>
#import tunitas.keyston.measurement.Simple
#import tunitas.keyston.measurement.Histogram
#import tunitas.keyston.measurement.Population
#import tunitas.keyston.measurement.Count
#import tunitas.Tuple
#import tunitas.keyston.measurement.package_format.Formatter
#import tunitas.keyston.array.range.required.Container
#import nonstd.required.Enumeration
#import nonstd.required.InstanceOf
namespace tunitas::keyston::measurement::package_format::body {
  //
  // Specification:
  //
  //   the usual.
  //
  // Design:
  //
  //   May run multiple lines (e.g. histogram or population)
  //   Does not append a final newline.
  //
  // Usage:
  //
  //   Oh come on.  How you use these is in every single book and blog post they've ever written.
  //   Still unclear?  Go read the writings about std::format or its predecessor fmt::format.
  //   Still here?
  //
  //   cout << s << h << p;
  //
  template<required::Enumeration ENUM> inline auto operator<<(std::ostream &, Formatter<ENUM> const &) -> std::ostream &;
  template<required::InstanceOf<Quantity> QUANTITY> inline auto operator<<(std::ostream &, Formatter<QUANTITY> const &) -> std::ostream &;
  inline auto operator<<(std::ostream &, Formatter<Histogram, Histogram const &> const &) -> std::ostream &;
  inline auto operator<<(std::ostream &, Formatter<Population, Population const &> const &) -> std::ostream &;
  auto operator<<(std::ostream &, Formatter<Tuple<Boundaries const &, Histogram const &>> const &) -> std::ostream &;
  auto operator<<(std::ostream &, Formatter<Tuple<Bits, Prefixes const &, Population const &>> const &) -> std::ostream &;
  //
  template<required::Container CONTAINER> auto insert(std::ostream &, CONTAINER const &) -> std::ostream &;
}
#endiv
#divert <ipp>
#import tunitas.number.mp.io // will produce operator<<
namespace tunitas::keyston::measurement::package_format {
  template<required::Enumeration ENUM> auto body::operator<<(std::ostream &outbound, Formatter<ENUM, ENUM> const &formatter) -> std::ostream &                      { return outbound << underlying(formatter.captured); }
  template<required::InstanceOf<Quantity> QUANTITY> auto body::operator<<(std::ostream &outbound, Formatter<QUANTITY, QUANTITY> const &formatter) -> std::ostream & { return outbound << formatter.captured.count(); }
  auto body::operator<<(std::ostream &outbound, Formatter<Histogram, Histogram const &> const &formatter) -> std::ostream &                                         { return insert(outbound, formatter.captured); }
  auto body::operator<<(std::ostream &outbound, Formatter<Population, Population const &> const &formatter) -> std::ostream &                                       { return insert(outbound, formatter.captured); }
}
#endiv
#divert <tpp>
#import tunitas.keyston.array.enumerate
#import tunitas.keyston.measurement.package_format.format
namespace tunitas::keyston::measurement::package_format {
  template<required::Container CONTAINER> auto body::insert(std::ostream &outbound, CONTAINER const &container) -> std::ostream & {
    auto newline = Newline{}; // newline precedes so that there is no final newline
    for (auto [index, element] : enumerate(container)) {
      outbound << newline << index << ": " << format(element);
    }
    return outbound;
  }
}
#endiv
#divert <cpp>
#import nonstd.runtime_assert
#import langu.age.q
namespace tunitas::keyston::measurement::package_format {
  auto body::operator<<(std::ostream &outbound, Formatter<Tuple<Boundaries const &, Histogram const &>> const &formatter) -> std::ostream & {
#if 0
    auto const &boundaries = get<0>(formatter.captured);
    auto const &histogram = get<1>(formatter.captured);
#else
    auto const &[boundaries, histogram] = formatter.captured;
#endif
    static_assert(Boundaries{}.size() == Histogram{}.size());
    auto newline = Newline{};
    for (auto [index, observed] : enumerate(histogram)) {
      auto const &boundary = boundaries.at(index);
      outbound << newline << format(observed) << " in bucket #" << index << " below " << format(boundary);
    }
    return outbound;
  }
  auto body::operator<<(std::ostream &outbound, Formatter<Tuple<Bits, Prefixes const &, Population const &>> const &formatter) -> std::ostream & {
#if 0
    auto const &prefix_length = get<0>(formatter.captured);
    auto const &prefixes = get<1>(formatter.captured);
    auto const &population = get<2>(formatter.captured);
#else
    auto const &[prefix_length, prefixes, population] = formatter.captured;
#endif
    runtime_assert(prefixes.size() == population.size());
    auto newline = Newline{};
    outbound << newline << "prefix length " << prefix_length.count();
    for (auto [index, observed] : enumerate(population)) {
      auto const &prefix = prefixes.at(index);
      outbound << newline << format(observed) << " with prefix " << std::showbase << std::hex << format(prefix) << std::dec << " " << q(format(prefix)) << std::dec;
    }
    return outbound;
  }
}
#endiv
