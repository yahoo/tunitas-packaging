// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
#import tunitas.keyston.field.required.Element
namespace tunitas::keyston::field::vector {
  //
  // A vector over the field (element)
  //
  // Specification:
  //
  //   Only provides the field operations that are actually specified
  //   multiplication is the dot product, so the dimensions don't increase (multiplicatively)
  //
  // Design:
  //
  //   Fixed length.
  //   Use a new type so that ADL will find the operations. 
  //   The vectors MUST be of the same length.
  //
  //   The following operations are not available for modular vectors
  //   e.g. operator<=> ... what would it mean?
  //   e.g. operator/   ... alternatively, use multiplication against invm(...) or invm(...)*powm(...)
  //   e.g. operator%   ... this is already a modular field
  //
  //   Basically copy-pasta with Polynomial because ... that's how linear algebra goes.
  //   operator* on two Vectors does what you expect (the dot product)
  //
  // Usage:
  //
  //   Yes
  //.
  template<required::Element, Size CAPACITY> struct Fixed;
}
#endiv
#divert <hpp>
#import std.strong_ordering
#import tunitas.array.Fixed
namespace tunitas::keyston::field {
  namespace vector {
    using std::move;
    template<required::Element ELEMENT, Size CAPACITY> inline constexpr auto swap(Fixed<ELEMENT, CAPACITY> &, Fixed<ELEMENT, CAPACITY> &) noexcept -> void;
    //
    template<required::Element ELEMENT, Size CAPACITY> inline constexpr auto operator==(Fixed<ELEMENT, CAPACITY> const &, Fixed<ELEMENT, CAPACITY> const &) -> bool;
    //
    template<required::Element ELEMENT, Size CAPACITY> inline constexpr auto operator+(Fixed<ELEMENT, CAPACITY> const &a) -> Fixed<ELEMENT, CAPACITY> { return a; }
    template<required::Element ELEMENT, Size CAPACITY> inline constexpr auto operator-(Fixed<ELEMENT, CAPACITY> const &) -> Fixed<ELEMENT, CAPACITY>;
    //
    template<required::Element ELEMENT, Size CAPACITY> inline constexpr auto operator+(Fixed<ELEMENT, CAPACITY> const &, Fixed<ELEMENT, CAPACITY> const &) -> Fixed<ELEMENT, CAPACITY>;
    template<required::Element ELEMENT, Size CAPACITY> inline constexpr auto operator-(Fixed<ELEMENT, CAPACITY> const &, Fixed<ELEMENT, CAPACITY> const &) -> Fixed<ELEMENT, CAPACITY>;
    //
    template<required::Element ELEMENT, Size CAPACITY> inline constexpr auto operator*(ELEMENT a, Fixed<ELEMENT, CAPACITY> const &b) -> Fixed<ELEMENT, CAPACITY> { return b * a; }
    template<required::Element ELEMENT, Size CAPACITY> inline constexpr auto operator*(Fixed<ELEMENT, CAPACITY> const &, ELEMENT) -> Fixed<ELEMENT, CAPACITY>;
    template<required::Element ELEMENT, Size CAPACITY> inline constexpr auto operator*(Fixed<ELEMENT, CAPACITY> const &, Fixed<ELEMENT, CAPACITY> const &) -> Fixed<ELEMENT, CAPACITY>;
    // NO SUCH ---> operator/ or operator% because this is already modular arithmetic <---- NO SUCH
  }
  template<required::Element ELEMENT, Size CAPACITY> struct vector::Fixed : public array::Fixed<ELEMENT, CAPACITY> {
    using Ancestor = array::Fixed<ELEMENT, CAPACITY>;
  public:
    constexpr Fixed() = default;
    using Ancestor::Fixed;
    constexpr [[implicit]] Fixed(Ancestor const &);
    //
    constexpr auto operator=(Fixed const &) -> Fixed & = default;
    using Ancestor::operator=;
    //
    inline constexpr auto operator+=(Fixed const &) -> Fixed &;
    inline constexpr auto operator-=(Fixed const &) -> Fixed &;
    inline constexpr auto operator*=(typename Ancestor::Value) -> Fixed &;
  };
}
#import nonstd.container.Traits.tunitas.keyston.field.vector.Fixed.ELEMENT.CAPACITY
#endiv
#divert <ipp>
#import std.equal
#import std.index_sequence
#import std.make_index_sequence
#import std.nothrow
#import tunitas.keyston.exception.Domain
namespace tunitas::keyston::field {
  template<required::Element ELEMENT, Size CAPACITY> constexpr auto vector::swap(Fixed<ELEMENT, CAPACITY> &a, Fixed<ELEMENT, CAPACITY> &b) noexcept -> void {
    typename Fixed<ELEMENT, CAPACITY>::Ancestor &aa{a}, &bb{b};
    swap(aa, bb);
  }
  template<required::Element ELEMENT, Size CAPACITY> constexpr auto vector::operator==(Fixed<ELEMENT, CAPACITY> const &a, Fixed<ELEMENT, CAPACITY> const &b) -> bool { return std::equal(a.begin(), a.end(), b.begin(), b.end()); }
#if 0
  template<required::Element ELEMENT, Size CAPACITY> constexpr auto vector::operator<=>(Fixed<ELEMENT, CAPACITY> const &a, Fixed<ELEMENT, CAPACITY> const &b) -> std::strong_ordering { return std::lexicographical_compare_three_way(a.begin(), a.end(), b.begin(), b.end()); }
#endif
  template<required::Element ELEMENT, Size CAPACITY> constexpr auto vector::operator-(Fixed<ELEMENT, CAPACITY> const &a) -> Fixed<ELEMENT, CAPACITY> { return Fixed<ELEMENT, CAPACITY>{} - a; }
  template<required::Element ELEMENT, Size CAPACITY> constexpr auto vector::operator+(Fixed<ELEMENT, CAPACITY> const &a, Fixed<ELEMENT, CAPACITY> const &b) -> Fixed<ELEMENT, CAPACITY> {
    auto c{a};
    c += b;
    return c;
  }
  template<required::Element ELEMENT, Size CAPACITY> constexpr auto vector::operator-(Fixed<ELEMENT, CAPACITY> const &a, Fixed<ELEMENT, CAPACITY> const &b) -> Fixed<ELEMENT, CAPACITY> {
    auto c{a};
    c -= b;
    return c;
  }
  template<required::Element ELEMENT, Size CAPACITY> constexpr auto vector::operator*(Fixed<ELEMENT, CAPACITY> const &a, ELEMENT b) -> Fixed<ELEMENT, CAPACITY> {
    auto c{a};
    c *= b;
    return c;
  }
  template<required::Element ELEMENT, Size CAPACITY> constexpr auto vector::operator*(Fixed<ELEMENT, CAPACITY> const &a, Fixed<ELEMENT, CAPACITY> const &b) -> Fixed<ELEMENT, CAPACITY> {
    return [&]<Size... INDEX>(std::index_sequence<INDEX...>) {
        return Fixed<ELEMENT, CAPACITY>{(a.at(std::nothrow, INDEX) * b.at(std::nothrow, INDEX))...};
      }(std::make_index_sequence<CAPACITY>{});
  }
  namespace vector {
    template<required::Element E, Size C> constexpr Fixed<E,C>::Fixed(Ancestor const &a) : Ancestor{a} { }
    template<required::Element E, Size C> constexpr auto Fixed<E,C>::operator+=(Fixed const &other) -> Fixed & {
      auto &self{*this};
      for (auto i : std::views::iota(0u, Ancestor::size())) {
        self[i] += other[i];
      }
      return self;
    }
    template<required::Element E, Size C> constexpr auto Fixed<E,C>::operator-=(Fixed const &other) -> Fixed & {
      auto &self{*this};
      for (auto i : std::views::iota(0u, Ancestor::size())) {
        self[i] -= other[i];
      }
      return self;
    }
    template<required::Element E, Size C> constexpr auto Fixed<E,C>::operator*=(typename Ancestor::Value other) -> Fixed & {
      auto &self{*this};
      for (auto &item : self) {
        item *= other;
      }
      return self;
    }
  }
}
#endiv
