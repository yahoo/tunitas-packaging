// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
namespace tunitas::keyston::field {
  //
  // The field elements, as indexed.
  //
  // Usage:
  //
  //   using E64 = Element<64>;
  //   using E128 = Element<128>;
  //   using E255 = Element<128>;
  //
  namespace [[eponymous]] element {
    template<unsigned> struct Basis;
    // ADL will find functions against these types in namespace element
    template<> struct Basis<64>  { enum class Type : uint64_t; };
    template<> struct Basis<128> { enum class Type : uint128_t; };
    template<> struct Basis<255> { struct Type; };
    template<unsigned INDEX> using Element = typename Basis<INDEX>::Type;
  }
  using element::Element;
}
#endiv
#divert <hpp>
#import tunitas.keyston.field.required.Element
#import tunitas.keyston.field.traits.Field
#import nonstd.required.Enumeration
#import nonstd.required.Class
#import std.remove_cvref
namespace tunitas::keyston::field::element {
  template<required::Element ELEMENT> requires required::Enumeration<ELEMENT> inline constexpr auto underlying(ELEMENT e)                          { return typename traits::Element<ELEMENT>::Underlying(e); }
  template<required::Element ELEMENT> requires required::Class<ELEMENT>       inline constexpr auto underlying(ELEMENT const &e) -> decltype(auto) { return static_cast<typename traits::Element<ELEMENT>::Underlying const &>(e); }
  class Basis<255>::Type : public uint256_t {
    using Ancestor = uint256_t;
  public:
    Type() = default;
    using Ancestor::number; // yes, you "just have to know" that the constructor is 'number' within number<cpp_int_backend<...>>
    Type(Ancestor &&i) : Ancestor{move(i)} { }
    Type(Ancestor const &i) : Ancestor{i} { }
  };
  //
  // The field operations
  //
  // Authorities:
  //
  //   Any field theory textbook will do.
  //   But specifically, for this work
  //
  //   Verifiable Distributed Aggregation Functions
  //   https://www.ietf.org/archive/id/draft-irtf-cfrg-vdaf-05.html#name-preliminaries
  //   Section 6 Preliminaries
  //   Section 6.1 Finite fields
  //
  // Specification:
  //
  //   As-stated.
  //
  // Design:
  //
  //   These operators are found by ADL.
  //   The enumerations at issue are the class-scoped ELEMENT enumerators in the Field<INDEX> descriptor. 
  //
  // Usage:
  //
  //   You know how to add, subtract, multiply and divide, yes?
  //   Good for you!
  //
  template<typename ELEMENT> requires required::Element<std::remove_cvref_t<ELEMENT>> constexpr auto operator+(ELEMENT &&) -> ELEMENT;
  template<required::Element ELEMENT> inline constexpr auto operator+(ELEMENT const &) -> ELEMENT;
  template<required::Element ELEMENT> inline constexpr auto operator+(ELEMENT &&) -> ELEMENT;
  template<required::Element ELEMENT> inline constexpr auto operator-(ELEMENT const &) -> ELEMENT;
  //
  template<required::Element ELEMENT> inline constexpr auto operator+(ELEMENT const &, ELEMENT const &) -> ELEMENT;
  template<required::Element ELEMENT> inline constexpr auto operator-(ELEMENT const &, ELEMENT const &) -> ELEMENT;
  template<required::Element ELEMENT> inline auto operator*(ELEMENT const &, ELEMENT const &) -> ELEMENT;
  template<required::Element ELEMENT> inline auto pow(ELEMENT const &, int long unsigned exponent) -> ELEMENT;
  //
  template<required::Element ELEMENT> inline constexpr auto operator+=(ELEMENT &, ELEMENT const &) -> ELEMENT &;
  template<required::Element ELEMENT> inline constexpr auto operator-=(ELEMENT &, ELEMENT const &) -> ELEMENT &;
  template<required::Element ELEMENT> inline auto operator*=(ELEMENT &, ELEMENT const &) -> ELEMENT &;
#if 0
  // we don't need the division ones (they are multiply-by-the-inverse
  template<required::Element ELEMENT> inline constexpr auto operator/(ELEMENT const &, ELEMENT const &) -> ELEMENT = delete;
  template<required::Element ELEMENT> inline constexpr auto inverse(ELEMENT const &) -> ELEMENT = delete;
  template<required::Element ELEMENT> inline constexpr auto pow(ELEMENT const &, int long signed exponent) -> ELEMENT = delete;
#endif
  template<required::Element ELEMENT> inline constexpr auto operator==(ELEMENT const &, ELEMENT const &) -> bool;
}
#endiv
#divert <ipp>
#import tunitas.keyston.field.traits.Field
#import tunitas.keyston.field.Limits
#import tunitas.keyston.exception.Overflow
#import tunitas.keyston.numeric.powm
#import tunitas.keyston.numeric.narrow
#import tunitas.number.mp.convert // [[FIXTHIS]] [[REMOVETHIS]] when uint256_t and uint512_t are available
#import std.derived_from
namespace tunitas::keyston::field {
  template<required::Element ELEMENT> inline constexpr auto element::operator==(ELEMENT const &a, ELEMENT const &b) -> bool { return underlying(a) == underlying(b); }
  template<typename ELEMENT> requires required::Element<std::remove_cvref_t<ELEMENT>> constexpr auto element::operator+(ELEMENT &&e) -> ELEMENT { return forward<ELEMENT>(e); }
  template<required::Element ELEMENT> constexpr auto element::operator-(ELEMENT const &e) -> ELEMENT {
    using Field = traits::Element<ELEMENT>::Field;
    if (ELEMENT{} == e) {
      return e;
    } else {
      return ELEMENT{Field::MODULUS - underlying(e)};
    }
  }
  //
  // Diagram of A + B (avoiding overflow)
  //
  //   let A+B < MODULUS
  //   <---------MODULUS ---------->
  //   <---A----<-----B----->
  //
  //   let A+B >= MODULUS
  //   <---------MODULUS ---------->
  //   <--------A-------><----------B---------->
  //                     <----B1---><----B2---->
  // 
  //
  template<required::Element ELEMENT> constexpr auto element::operator+(ELEMENT const &a, ELEMENT const &b) -> ELEMENT {
    using Field = traits::Element<ELEMENT>::Field;
    auto const &ua = underlying(a);
    auto const &ub = underlying(b);
    if (ua < Field::MODULUS - ub) {
      return ELEMENT{ua + ub};
    } else {
      auto b1 = Field::MODULUS - ua;
      auto b2 = ub - b1;
      return ELEMENT{b2};
    }
  }
  //
  // Diagram of A - B (avoiding overflow)
  //
  //   let A >= B
  //   <--------------------MODULUS-------------------->
  //   <---------------A--------------->
  //   <-----B----->
  //                <-------A-B-------->
  //
  //   let A < B
  //   <--------------------MODULUS--------------------><--------------------MODULUS-------------------->
  //   <-----A----->
  //   <---------------B--------------->
  //                                    <-----M-B------>
  //                                                    <-----A----->
  //                                    <----------M-B+A------------>
  //
  //     C = A - B     (mod M) 
  // M + C = M + A - B (mod M)
  //     C = M + A - B (mod M)
  //     C = M - B + A (mod M)
  //     C = (M-B) + A (mod M)
  //
  template<required::Element ELEMENT> constexpr auto element::operator-(ELEMENT const &a, ELEMENT const &b) -> ELEMENT {
    using Field = traits::Element<ELEMENT>::Field;
    static_assert(Limits<ELEMENT>::max() <= Limits<ELEMENT>::Numeric::max());
    auto const &ua = underlying(a);
    auto const &ub = underlying(b);
    if (ua < ub) {
      return ELEMENT{Field::MODULUS - ub + ua};
    } else {
      return ELEMENT{ua - ub};
    }
  }
  template<required::Element ELEMENT> auto element::operator*(ELEMENT const &a, ELEMENT const &b) -> ELEMENT {
    using Field = traits::Element<ELEMENT>::Field;
    using Temporary = typename Field::Temporary;
    static_assert(Limits<ELEMENT>::max() + Limits<ELEMENT>::max() <= Limits<ELEMENT>::Numeric::max()); // unsigned "overflow" is defined to wrap around (even for bignums), so this doesn't prove anything.
    static_assert(Temporary{Limits<ELEMENT>::max()} + Temporary{Limits<ELEMENT>::max()} <= Temporary{2} * Temporary{Limits<ELEMENT>::Numeric::max()}); // this does prove something.
    auto ua = Temporary{underlying(a)};
    auto ub = Temporary{underlying(b)};
    auto widened = (ua * ub) % Field::MODULUS;
    auto narrowed = numeric::narrow<typename Field::Underlying>(error::by::Exception{}, widened);
    return ELEMENT{narrowed};
  }
  template<required::Element ELEMENT> constexpr auto element::operator+=(ELEMENT &lhs, ELEMENT const &rhs) -> ELEMENT & {
    lhs = lhs + rhs;
    return lhs;
  }
  template<required::Element ELEMENT> constexpr auto element::operator-=(ELEMENT &lhs, ELEMENT const &rhs) -> ELEMENT & {
    lhs = lhs - rhs;
    return lhs;
  }
  template<required::Element ELEMENT> auto element::operator*=(ELEMENT &lhs, ELEMENT const &rhs) -> ELEMENT & {
    lhs = lhs * rhs;
    return lhs;
  }
  template<required::Element ELEMENT> auto element::pow(ELEMENT const &a, int long unsigned e) -> ELEMENT {
    using Field = traits::Element<ELEMENT>::Field;
    if constexpr (required::Enumeration<ELEMENT>) {
      if (ELEMENT{2} == a && e < 8*sizeof(ELEMENT)) {
        //
        // special case 2^e
        //
        auto candidate = typename Field::Underlying{1u} << e;
        if (candidate < Field::MODULUS) {
          return ELEMENT{candidate};
        } else {
          return ELEMENT{candidate % Field::MODULUS};
        }
      }
    }
    return ELEMENT{numeric::powm<typename Field::Underlying>(underlying(a), e, Field::MODULUS)};
  }
#if 0
  // find these in keyston::numeric
  template<required::Element ELEMENT> constexpr auto element::inverse(ELEMENT const &a) -> ELEMENT {
    using Field = traits::Element<ELEMENT>::Field;
    return ELEMENT{inversem(error::by::Exception{}, underlying(a), Field::MODULUS)};
  }
#endif
}
#endiv
#divert <cpp>
#import tunitas.keyston.field.traits.Element
#import std.derived_from
namespace {
  namespace testate {
    using namespace tunitas::keyston::field;
    static_assert(std::derived_from<Element<255>, traits::Element<Element<255>>::Underlying>);
  }
}
#endiv
