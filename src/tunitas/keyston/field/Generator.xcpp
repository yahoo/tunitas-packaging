// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
#import tunitas.keyston.field.required.generator.Generator // and Triple<...> as is done herein
#import tunitas.keyston.field.traits.Common
#include <hpp/tunitas.keyston.field.traits.Common>
#import tunitas.number.Integer
namespace tunitas::keyston::field {
  //
  // A generator of a group.
  //
  // Specification:
  //
  // Design:
  //
  //   Specializations and  constexpr when it can be.
  //
  //   The operator()() cannot be constexpr when number:Integer is produced.
  //
  // Usage:
  //
  //   auto gen() -> Value { return Generator{}(); }
  //
  namespace [[eponymous]] generator {
    template<auto BASE, auto EXPONENT, auto MODULUS, required::Subelement SUBELEMENT = typename traits::Common<BASE, EXPONENT, MODULUS>::Type>
    requires required::generator::Triple<BASE, EXPONENT, MODULUS, SUBELEMENT> struct Triple;
    //
    template<auto BASE, auto EXPONENT, auto MODULUS,
             required::Element ELEMENT = typename traits::Common<BASE, EXPONENT, MODULUS>::Type,
             required::Subelement SUBELEMENT = ELEMENT>
    requires required::generator::Generator<BASE, EXPONENT, MODULUS, ELEMENT, SUBELEMENT> struct Generator;
    //
    template<auto BASE, auto EXPONENT, auto MODULUS> struct Generator<BASE, EXPONENT, MODULUS, number::Integer, typename traits::Common<BASE, EXPONENT, MODULUS>::Type>;
  }
  using generator::Generator;
}
#endiv
#divert <hpp>
namespace tunitas::keyston::field {
  template<auto THE_BASE, auto THE_EXPONENT, auto THE_MODULUS, required::Subelement SUBELEMENT>
  requires required::generator::Triple<THE_BASE, THE_EXPONENT, THE_MODULUS, SUBELEMENT>
  class generator::Triple {
  protected:
    using Subvalue = SUBELEMENT;
  public:
    inline static constexpr Subvalue const BASE     = THE_BASE;
    inline static constexpr Subvalue const EXPONENT = THE_EXPONENT;
    inline static constexpr Subvalue MODULUS        = THE_MODULUS;
  };
  template<auto THE_BASE, auto THE_EXPONENT, auto THE_MODULUS, required::Element ELEMENT, required::Subelement SUBELEMENT>
  requires required::generator::Generator<THE_BASE, THE_EXPONENT, THE_MODULUS, ELEMENT, SUBELEMENT>
  class generator::Generator : public Triple<THE_BASE, THE_EXPONENT, THE_MODULUS, SUBELEMENT> {
    using Ancestor = Triple<THE_BASE, THE_EXPONENT, THE_MODULUS, SUBELEMENT>;
  public:
    using Value = ELEMENT;
    inline auto operator()() const -> Value; // [[FIXTHIS]] can we make this constexpr when the constants BASE, EXPONENT, MODULUS are known?
  protected:
    mutable Optional<Value> generated{};
  };
  namespace generator {
    template<> inline auto Generator<7u, 4294967295lu, 18446744069414584321llu>::operator()() const -> Value;
    template<auto THE_BASE, auto THE_EXPONENT, auto THE_MODULUS>
    class Generator<THE_BASE, THE_EXPONENT, THE_MODULUS, number::Integer, typename traits::Common<THE_BASE, THE_EXPONENT, THE_MODULUS>::Type>
      : public Triple<THE_BASE, THE_EXPONENT, THE_MODULUS, typename traits::Common<THE_BASE, THE_EXPONENT, THE_MODULUS>::Type> {
      using Ancestor = Triple<THE_BASE, THE_EXPONENT, THE_MODULUS, typename traits::Common<THE_BASE, THE_EXPONENT, THE_MODULUS>::Type>;
    public:
      using Value = number::Integer;
      inline auto operator()() const -> Value;
    protected:
      mutable Optional<Value> generated{};
    };
    template<> inline auto Generator<7lu, 4294967295lu, 18446744069414584321lu>::operator()() const -> Value;
  }
}
#endiv
#divert <ipp>
#import tunitas.keyston.field.get.Extract // we MUST use this one because Integer::get<SMALL>() only works with signed integers
#import tunitas.keyston.field.Field
#import tunitas.keyston.field.powm
#import std.same_as
namespace tunitas::keyston::field::generator {
  //
  // As used in Field<64>
  // 
  // MODULUS = 2^32 * 4294967295 + 1;
  // GENERATOR = 7^4294967295               (pesky ... /usr/bin/bc won't compute this)
  //
  template<> auto Generator<7lu, 4294967295lu, 18446744069414584321lu>::operator()() const -> Value {
    static_assert(std::same_as<Generator, Field<64>::Generator>, "the magic is in the constants, are they not correct?");
    if (generated) {
      return *generated;
    } else {
#if 1
      // FIXTHIS - make this constexpr
      // WATCHOUT - the carrier MUST be wide enough to hold (modulus-1)^2 so for a 64-bit base we need a 128-bit intermediate carrier
      generated = powm<uint128_t>(BASE, EXPONENT, MODULUS);
      return *generated;
#else
      // can't be constexpr if we use bignums.
      // [[FIXTHIS]] ... the annoyance of having to use convert<...>(...) which is an implemenation detail because Integer requires signed but modular arithmetic is all unsigned (by definition).
      // [[FIXTHIS]] ... open-code the (modular) exponentiation for the Subelement type (which are small integers)
      auto const base = number::Integer{number::mp::convert<mpz_class>(BASE)};
      auto const modulus = number::Integer{number::mp::convert<mpz_class>(MODULUS)};
      auto noob = powm(base, EXPONENT, modulus);
      generated = get::Extract<Value>::get(noob.peek());
      return *generated;
#endif
    }
  }
  template<auto B, auto X, auto M, required::Element E, required::Subelement S> auto Generator<B,X,M,E,S>::operator()() const -> Value {
    if (generated) {
      return *generated;
    } else {
      auto const base = number::Integer{number::mp::convert<mpz_class>(Ancestor::BASE)};
      auto const exponent = number::Integer{number::mp::convert<mpz_class>(Ancestor::EXPONENT)};
      auto const modulus = number::Integer{number::mp::convert<mpz_class>(Ancestor::MODULUS)};
      auto noob = powm(base, exponent, modulus);
      generated = get::Extract<Value>::get(noob.peek());
      return *generated;
    }
  }
}
#endiv
