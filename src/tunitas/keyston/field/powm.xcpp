// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
namespace tunitas::keyston::field {
  namespace package_powm {
    namespace body::exported { }
    namespace interface = body::exported;
  }
  using namespace package_powm::interface;
}
#import tunitas.keyston.required
#import tunitas.number.Integer
#import nonstd.required.integer.Unsigned
namespace tunitas::keyston::field::package_powm {
  namespace required {
    using namespace tunitas::keyston::required;
    namespace integer {
      using namespace nonstd::required::integer;
      template<typename MODINT> concept Small = Unsigned<MODINT>;
      template<typename MODINT> concept Bigge = same_as<MODINT, number::Integer>;
      template<typename MODINT> concept Modulo = Small<MODINT> || Bigge<MODINT>;
    }
  }
  namespace body { }
}
#endiv
#divert <hpp>
#import tunitas.number.Integer // and powm(...)
namespace tunitas::keyston::field::package_powm::body {
  namespace exported {
    //
    // Exponential modulo
    //
    // Specification:
    //
    //   The power of base^exp modulo modulus
    //
    // Authority:
    //
    //   https://en.wikipedia.org/wiki/Modular_exponentiation
    //   Gotta be a Knuth citation in there somewhere.
    //   Donald E. Knuth. Seminumerical Algorithms, volume 2 [where?]
    //
    // Design:
    //
    //   Be constexpr when we can.
    //   Be bignum when we need.
    //
    //   ADL can't find any of this because the integers are in global scop and the bignums are "elsewhere"
    //   Of course the bignum variant can't be constexpr.
    //
    // Usage:
    //
    //   auto result = powm(base, exponent, modulus)
    //
    template<required::integer::Small MODINT> inline constexpr auto powm(MODINT base, MODINT exponent, MODINT modulus) -> MODINT;
    template<required::integer::Bigge MODINT> inline auto powm(MODINT base, MODINT exponent, MODINT modulus) -> MODINT;
    using tunitas::number::mp::integer::powm; // with the bignum arguments, and also some smallnum arguments
  }
  template<required::integer::Modulo MODINT> inline constexpr auto recipe(MODINT base, MODINT exponent, MODINT modulus) -> MODINT;
}
#endiv
#divert <ipp>
#import tunitas.keyston.exception.Domain
namespace tunitas::keyston::field::package_powm {
  template<required::integer::Small MODINT> constexpr auto interface::powm(MODINT base, MODINT exponent, MODINT modulus) -> MODINT { return recipe(base, exponent, modulus); }
  template<required::integer::Bigge MODINT>           auto interface::powm(MODINT base, MODINT exponent, MODINT modulus) -> MODINT { return recipe(base, exponent, modulus); }
  template<required::integer::Modulo MODINT> constexpr auto body::recipe(MODINT base, MODINT exponent, MODINT modulus) -> MODINT {
    // base & exponent can never be invalid (when unsigned)
    if (modulus < 1) {
      throw exception::Domain{"no modulus"};
    } else if (1 == modulus) {
      return 0;
    } else if (2 < modulus) {
      // (modular-maximum)^2 <= unsigned-maximum
      if (auto modular_maximum=modulus-1; modular_maximum > std::numeric_limits<MODINT>::max()/modular_maximum) {
        throw exception::Domain{"overflow (use a wider integer)"};
      }
    }
    if (base < 2) {
      return 1;
    } else {
      auto result = MODINT{1};
      while (exponent > 0) {
        if (1 == (exponent & 01)) {
          result = (result * base) % modulus;
        }
        base = (base * base) % modulus;
        exponent >>= 1;
      }
      return result;
    }
  }
}
#endiv
