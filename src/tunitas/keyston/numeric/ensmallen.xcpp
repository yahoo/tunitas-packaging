// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
namespace tunitas::keyston::numeric {
  namespace package_ensmallen {
    namespace body::exported { }
    namespace interface = body::exported;
  }
  using namespace package_ensmallen::interface;
}
#import tunitas.number.Integer
#import tunitas.keyston.measurement.Result
#import std.underlying_type
#import std.make_signed
#import std.numeric_limits
#import std.is_unsigned
namespace tunitas::keyston::numeric::package_ensmallen {
  using number::Integer;
  namespace body {
    using Overlaying = measurement::Result;
    using Underlying = std::underlying_type_t<Overlaying>;
    static_assert(std::is_unsigned_v<Underlying>);
    using Encoded = std::make_signed_t<Underlying>;
    namespace limits {
      using Unsigned = std::numeric_limits<Underlying>;
      using Signed = std::numeric_limits<Encoded>;
      static_assert(Unsigned::max() == Underlying{2u} * Signed::max() + 1);
    }
    namespace exported {
      enum class Clip { SILENTLY };
    }
  }
}
#endiv
#divert <hpp>
#import tunitas.Pair
namespace tunitas::keyston::numeric::package_ensmallen::body {
  namespace exported {
    //
    // Convert the bignum to a smallnum to a Result
    //
    // Specification:
    //
    //   Just what you see.
    //   Return an indication of whether the original value was clipped.
    //
    // Design:
    //
    //   Using the Best Available Means and Methods (UBAMM!)
    //
    // Usage:
    //
    //   Obvious.  You see it, don't you?
    //
    //   auto something_big = Integer{...somehow...};
    //
    //   auto [small, clipped] = ensmallen(something_big);
    //
    inline auto ensmallen(Integer const &) -> Pair<measurement::Result, bool>;
    inline auto ensmallen(Clip, Integer const &i) -> measurement::Result { return ensmallen(i).first; }
  }
  inline constexpr auto VALUE_WAS_CLIPPED = true;
  inline constexpr auto VALUE_IS_CORRECT = false;
}
#endiv
#divert <ipp>
namespace tunitas::keyston::numeric::package_ensmallen {
  auto interface::ensmallen(Integer const &big) -> Pair<measurement::Result, bool> {
    if (big.fits<Encoded>()) {
      if (auto got=big.get<Encoded>(); got < 0) {
        return {Overlaying{0}, VALUE_WAS_CLIPPED}; // this is unexpected (it means someone didn't true-up after modular arithmetic)
      } else {
        return {Overlaying(got), VALUE_IS_CORRECT};
      }
    } else {
      // it may still be too big, but let's try
      Integer shaved = big >> 1;
      int oddness = 1 == (big % 2) ? 1 : 0;
      if (!shaved.fits<Encoded>()) {
        Underlying clipped = shaved < 0 ? 0u : limits::Unsigned::max();
        return {Overlaying{clipped}, VALUE_WAS_CLIPPED};
      } else {
        if (auto got=shaved.get<Encoded>(); got < 0) {
          return {Overlaying{0}, VALUE_WAS_CLIPPED}; // eadam ratione
        } else {
          auto reassembled = Overlaying{2u * Underlying(got) + oddness};
          return {reassembled, VALUE_IS_CORRECT};
        }
      }
    }
  }
}
#endiv
