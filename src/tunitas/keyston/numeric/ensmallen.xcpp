// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
namespace tunitas::keyston::numeric {
  namespace package_ensmallen {
    namespace body::exported { }
    namespace interface = body::exported;
  }
  using namespace package_ensmallen::interface;
}
#import tunitas.keyston.aggregation.Simple
#import tunitas.keyston.field.element.narrow // for element::Clip
#import std.underlying_type
namespace tunitas::keyston::numeric::package_ensmallen {
  using aggregation::Simple;
  using keyston::field::element::Clip;
  namespace body {
    using Underlying = std::underlying_type_t<Simple>;
    namespace exported {
      static_assert(sizeof(Clip), "yup, visible");
    }
  }
}
#endiv
#divert <hpp>
#import tunitas.integer.required.Large
#import tunitas.integer.required.Unsigned
#import tunitas.error.by.Exception
#import tunitas.error.by.Optional
#import tunitas.error.by.Outcome
#import tunitas.error.Optional
#import tunitas.error.Outcome
#import tunitas.Pair
namespace tunitas::keyston::numeric::package_ensmallen::body {
  namespace exported {
    //
    // Convert the bignum to a smallnum to a Simple
    //
    // Specification:
    //
    //   See tunitas.keyston.numeric.narrow
    //
    // Design:
    //
    //   See tunitas::keyston::numeric::narrow<SMALL>(Integer const &)
    //   Obviously, what was once herein was more complicated; and such has been moved elsewhere.
    //
    // Usage:
    //
    //   Obvious.  You see it, don't you?
    //
    //   auto something_big = uint128_t{...somehow...};
    //   auto something_big = uint256_t{...somehow...};
    //
    //   auto [small, clipped] = ensmallen(something_big);
    //   auto small = ensmallen(Clip::SILENTLY, something_big);
    //
    template<integer::required::Large SOURCE> inline auto ensmallen(error::by::Exception, SOURCE const &) -> Simple requires integer::required::Unsigned<SOURCE>;
    template<integer::required::Large SOURCE> inline auto ensmallen(error::by::Optional, SOURCE const &) -> error::Optional<Simple> requires integer::required::Unsigned<SOURCE>;
    template<integer::required::Large SOURCE> inline auto ensmallen(error::by::Outcome, SOURCE const &) -> error::Outcome<Simple> requires integer::required::Unsigned<SOURCE>;
    template<integer::required::Large SOURCE> inline auto ensmallen(SOURCE const &) -> Pair<Simple, bool> requires integer::required::Unsigned<SOURCE>;
    template<integer::required::Large SOURCE> inline auto ensmallen(Clip, SOURCE const &i) -> Simple requires integer::required::Unsigned<SOURCE>;
  }
}
#endiv
#divert <ipp>
#import tunitas.keyston.field.element.narrow
namespace tunitas::keyston::numeric::package_ensmallen {
  template<integer::required::Large SOURCE> auto interface::ensmallen(Clip c, SOURCE const &i) -> Simple requires integer::required::Unsigned<SOURCE>                  { return Simple{narrow<Underlying>(c, i)}; }
  template<integer::required::Large SOURCE> auto interface::ensmallen(error::by::Exception by, SOURCE const &i) -> Simple requires integer::required::Unsigned<SOURCE> { return Simple{narrow<Underlying>(by, i)}; }
  template<integer::required::Large SOURCE> auto interface::ensmallen(SOURCE const &i) -> Pair<Simple, bool> requires integer::required::Unsigned<SOURCE> {
    auto [narrowed, clipped] = narrow<Underlying>(i);
    return {Simple{narrowed}, clipped};
  }
  template<integer::required::Large SOURCE> auto interface::ensmallen(error::by::Optional by, SOURCE const &i) -> error::Optional<Simple> requires integer::required::Unsigned<SOURCE> {
    if (auto got=narrow<Underlying>(by, i); got) {
      return Simple{*got};
    } else {
      return {};
    }
  }
  template<integer::required::Large SOURCE> auto interface::ensmallen(error::by::Outcome by, SOURCE const &i) -> error::Outcome<Simple> requires integer::required::Unsigned<SOURCE> {
    if (auto got=field::element::narrow<Underlying>(by, i); good(got)) {
      return Simple{value(got)};
    } else {
      return error_code(got);
    }
  }
}
#endiv
