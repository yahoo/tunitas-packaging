// This is -*- c++ -*- nearly C++2a with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <hpp>
#import tunitas.array.required.Fixed
namespace tunitas::keyston::numeric::generic {
  //
  // Cosine similarity (on vectors).
  //
  // Specification:
  //
  //   You know.
  //
  // Design:
  //
  //   Applies the ADL-found operator*
  //   Works with numeric and non-numeric elements; i.e. not constrained by numeric::required::Element
  //   But is constrained to be "vectors" as arrays of constexpr-fixed length.
  //
  // Usage:
  //
  //   As the implementation for a more convenient operator.
  //   e.g.
  //
  //   given something::Vector<Element, SIZE>.
  //   template<Size SIZE> constexpr auto something::operator*(Vector<Element, SIZE> const &a, Vector<Element, SIZE> const &b) -> Vector<Element, SIZE> {
  //     return cosine_similarity(a, b);
  //   }
  //
  template<array::required::Fixed VECTOR> inline constexpr auto cosine_similarity(VECTOR const &a, VECTOR const &b) -> VECTOR;
}
#endiv
#divert <ipp>
#import std.index_sequence
#import std.make_index_sequence
namespace tunitas::keyston::numeric {
  template<array::required::Fixed VECTOR> constexpr auto generic::cosine_similarity(VECTOR const &a, VECTOR const &b) -> VECTOR {
    constexpr auto const CAPACITY = VECTOR{}.capacity();
    if constexpr (CAPACITY <= ARBITRARY_VECTOR_CONSTRUCTOR_INLINING_LIMIT) {
      return [&]<Size... INDEX>(std::index_sequence<INDEX...>) {
        return VECTOR{(a.at(std::nothrow, INDEX) * b.at(std::nothrow, INDEX))...};
      }(std::make_index_sequence<CAPACITY>{});
    } else {
      auto c = VECTOR{};
      auto ci = c.begin();
      auto ai = a.begin();
      auto bi = b.begin();
      for (auto i{0u}; CAPACITY != i; ++i, ++ai, ++bi, ++ci) {
        *ci = *ai * *bi;
      }
      return c;
    }
  }
}
#endiv
