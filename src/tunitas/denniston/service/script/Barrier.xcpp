// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc. 2022.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-denniston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/services/denniston/tree/LICENSE
#divert <fpp>
namespace tunitas::denniston::service::script {
  //
  // The barrier for the scripting
  //
  // Specification:
  //
  //   Just what you see.
  //
  //   <quote ref="https://en.cppreference.com/w/cpp/thread/condition_variable">
  //     Any thread that intends to wait on std::condition_variable has to
  //     1. acquire a std::unique_lock<std::mutex>, on the same mutex as used to protect the shared variable
  //     2. either
  //        a. check the condition, in case it was already updated and notified
  //        b. execute wait, wait_for, or wait_until.
  //     The wait operations atomically release the mutex and suspend the execution of the thread.
  //     When the condition variable is notified, a timeout expires, or a spurious wakeup occurs,
  //     the thread is awakened, and the mutex is atomically reacquired.
  //     The thread should then check the condition and resume waiting if the wake up was spurious.
  //     The use the predicated overload of wait, wait_for, and wait_until, which takes care of the three steps above
  //   </quote>
  //  
  // Design:
  //
  //   Using the Best Available Means & Methods (UBAMM)
  //
  // Usage:
  //
  //   Reader               Executor
  //   ------------------------------------
  //   ....                  barrier.start()
  //   barrier.notify()      ....
  //   ....                  barrier.wait(...predicate...)
  //   barrier.notify()      ....
  //   ....                  barrier.wait(...predicate...)
  //   barrier.notify()      ....
  //   ....                  barrier.wait(...predicate...)
  //
  // And so on
  //
  struct Barrier;
}
#endiv
#divert <hpp>
#import std.mutex
#import std.unique_lock
#import std.condition_variable
#import std.invocable
struct tunitas::denniston::service::script::Barrier {
  std::mutex mutex{};
  std::unique_lock<std::mutex> lock{mutex, std::defer_lock};
  std::condition_variable when;
  inline auto notify() -> void;
  inline auto start() -> void;
  template<std::invocable<> PREDICATE> inline auto wait(PREDICATE predicate) -> void;
};
#endiv
#divert <ipp>
namespace tunitas::denniston::service::script {
  auto Barrier::notify() -> void { when.notify_all(); }
  auto Barrier::start() -> void { lock.lock(); }
  template<std::invocable<> PREDICATE> auto Barrier::wait(PREDICATE predicate) -> void {
    when.wait(lock, predicate);
    lock.unlock();
  }
}
#endiv
