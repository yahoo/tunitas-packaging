// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc. 2022.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-denniston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/services/denniston/tree/LICENSE
#divert <fpp>
namespace tunitas::denniston::service::instance {
  //
  // The (prototype of a) manifestation of a service (a computing resource).
  //
  // Specification:
  //
  //   Manages some computing.
  //   Publishes an interface by which it can be contacted.
  //   Expects to be dynamically allocated with std::make_unique<DESCENDANT>(...)
  //
  //   Whereas this is a simulatoin, every process has a control channel (socket interface)
  //
  // Design:
  //
  //   Descendants only.
  //   Something something: a thread.
  //   The destructor must be public so that std::unique_ptr can see it.
  //
  // Usage:
  //
  //   In the environment..
  //
  struct Prototype;
}
#endiv
#divert <hpp>
#import tunitas.denniston.log.Client
#import tunitas.denniston.network.Socket.Interface
#import tunitas.denniston.service.Name
#forward tunitas.denniston.driver.Threads
#forward tunitas.denniston.driver.Driver
#import tunitas.denniston.process.Prototype
#import std.atomic
#import std.vector
class tunitas::denniston::service::instance::Prototype : public process::Prototype {
  using Ancestor = process::Prototype;
public:
  Name name{};
  denniston::log::Client log;
  using Interface = network::Socket::Interface;
  using Interfaces = std::vector<network::Socket::Interface>;
  Interface control{};
  Prototype(Prototype const &) = delete;
  Prototype &operator=(Prototype const &) = delete;
  virtual ~Prototype() = default;
  virtual auto launch([[inout]] driver::Threads &) -> void = 0;
protected:
  inline explicit Prototype(Name);
  std::atomic<bool> graceful_shutdown{false}; // not clear this needs to be atomic.
  friend class driver::Driver;
};
#endiv
#divert <ipp>
namespace tunitas::denniston::service::instance {
  Prototype::Prototype(Name name)
    : name{name}
    , log{name}
  { }
}
// All descendants will need this
#import tunitas.denniston.driver.Threads
#endiv
