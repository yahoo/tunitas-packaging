// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc. 2022.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-denniston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/services/denniston/tree/LICENSE
#divert <fpp>
namespace tunitas::denniston::service::instance {
  //
  // A manifestation of the gateway in the network.
  //
  // Specification:
  //
  //   A router; suffles octets.
  //
  // Design:
  //
  //   Something something: a thread.
  //
  // Usage:
  //
  //   In the environment..
  //
  struct Gateway;
}
#endiv
#divert <hpp>
#import tunitas.Pair
#forward tunitas.denniston.World
#import tunitas.denniston.process.Reactor
#import tunitas.denniston.error.Code
#import tunitas.denniston.process.companion.Barrier
#import tunitas.denniston.report.Dictionary
#import tunitas.denniston.report.Manifest
#import tunitas.denniston.task.Dictionary
#import tunitas.denniston.task.Corpus
class tunitas::denniston::service::instance::Gateway : public process::Reactor {
  using Ancestor = process::Reactor;
protected:
  using Barrier = process::companion::Barrier;
  Barrier init_barrier{*this};
  auto init_subprocess() noexcept -> void;
  Barrier delegate_barrier{*this};
  auto delegate_subprocess() noexcept -> void;
  auto react() -> void override;
  auto catchup() -> void override;
  auto respond([[inout]] Interface &, [[inout]] Report<Slice::WHOLE> &, string::View from_whom) -> void;
public:
  inline explicit Gateway();
  inline explicit Gateway([[inout]] World &);
  auto launch(driver::Threads &) -> void override;
  Interfaces clients{};
  Interface collector{};
  Interface configuration{};
  Interfaces processors{};
  task::Dictionary<task::Corpus<Genus::GATEWAY>> tasks{};
  report::Dictionary<report::Manifest> reports{};
  using E = error::Code;
};
#endiv
#divert <ipp>
#import tunitas.denniston.World
namespace tunitas::denniston::service::instance {
  Gateway::Gateway(World &) : Gateway{} { }
  Gateway::Gateway() : Ancestor{Species::GATEWAY} { }
}
#endiv
#divert <cpp>
#import tunitas.keyston.protocol.report.key_from
#import tunitas.denniston.exception.Invariant
#import tunitas.denniston.process.companion.Shutdown
#import tunitas.denniston.protocol.packet.cast
#import tunitas.denniston.protocol.packet.make
#import tunitas.denniston.protocol.packet.Query
#import tunitas.denniston.protocol.packet.Report
#import tunitas.denniston.protocol.packet.Response
namespace tunitas::denniston::service::instance {
  auto Gateway::launch(driver::Threads &pool) -> void {
    pool.launch(&Gateway::run, this);
    pool.launch(&Gateway::init_subprocess, this);
    delegate_barrier.start();
    pool.launch(&Gateway::delegate_subprocess, this);
  }
  auto Gateway::catchup() -> void {
    if (graceful_shutdown.load()) {
      init_barrier.notify(); // catch up!
    }
  }
  auto Gateway::react() -> void {
    for (auto &client : clients) {
      if (auto red=client.read_if(); red) {
        if (auto got=downcast<Report<Slice::WHOLE>>(*red); nullptr != got) {
          respond(client, *got, "some client"sv);
        }
      }
    }
    if (auto red=collector.read_if(); red) {
      log.format("red from collector (and ignoring it)");
      // ... do something ...
    }
    if (auto red=configuration.read_if(); red) {
      if (auto got=downcast<Status>(*red); nullptr != got) {
        log.format("from configuration failure: {}", got->status.message());
      } else if (auto got=downcast<Response<Get::TASKS>>(*red); nullptr != got) {
        log.format("from configuration tasks: count {}", got->tasks.size());
        for (auto &given : got->tasks) {
          auto [noob, inserted] = tasks.insert({move(given)});
          log.format("{} {}", (inserted ? "inserted"s : "duplicated"s), noob.definition.id);
        }
        init_barrier.notify();
      } else {
        log.format("from configuration something else (ignored)");
      }
    }
    for (auto &processor : processors) {
      if (auto red=processor.read_if(); red) {
        log.format("red from a processor (and ignoring it)");
        // ... do something ...
      }
    }
  }
  auto Gateway::respond(Interface &back, Report<Slice::WHOLE> &whole, string::View from_whom) -> void {
    if (auto const required_processor_count=processors.size(); 2uz != required_processor_count) {
      back.write(make<Status>(E::GATEWAY_IS_MISCONFIGURED));
      throw exception::Invariant{"the system and algorithms only support exactly two processors"};
    } else if (auto found=tasks.find(whole.produced.task_id); !found) {
      back.write(make<Status>(E::NO_SUCH_TASK));
    } else if (whole.produced.encrypted_input_shares.size() != required_processor_count) {
      back.write(make<Status>(E::SHARE_COUNT_IS_INCORRECT_FOR_THIS_TASK));
    } else {
      found.value().outgoing->push_back(move(whole.produced));;
      back.write(make<Status>());
    }
  }
  auto Gateway::init_subprocess() noexcept -> void try {
    //
    // Ask for the tasks
    // The init barrier is superfluous here because all we're doing here is asking for the TASKS,
    //
    init_barrier.start();
    configuration.write(make<Query<Get::TASKS>>()); // ask for them all
    init_barrier.wait([this]{ return !tasks.empty(); });
    delegate_barrier.notify();
    //
    log.format("init is ending, having recovered the endpoints");
 } catch (process::companion::Shutdown) {
    // yay!
  } catch(...) {
    log.format("init has an escaped exception which is suppressed");
  }
  auto Gateway::delegate_subprocess() noexcept -> void try {
    delegate_barrier.wait([this]{ return !tasks.empty(); });
    while (!graceful_shutdown.load()) {
      std::this_thread::sleep_for(250ms);
      for (auto locked=tasks.range(); auto &corpus : locked) {
        if (auto red=corpus.outgoing->pop_if(); red) {
          auto saved_report_id_for_ux = key_from(*red);
          auto copy = saved_report_id_for_ux;
          auto [noob, inserted] = reports.insert(move(copy), {.report{move(*red)}});
          if (!inserted) {
            log.format("duplicate report {} is ignored", saved_report_id_for_ux);
          }
        }
      }
    }
  } catch (process::companion::Shutdown) {
    // yay!
  } catch(...) {
    log.format("delegate has an escaped exception which is suppressed");
  }
}
#endiv
