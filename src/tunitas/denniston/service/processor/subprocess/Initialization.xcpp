// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc. 2022.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-denniston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/services/denniston/tree/LICENSE
#divert <fpp>
namespace tunitas::denniston::service::processor::subprocess {
  //
  // The initialization subprocess (thread)
  //
  // Specificiation:
  //
  //   Ask for the tasks.
  //
  // Design:
  //
  //   Just what you see.
  //
  // Concurrency:
  //
  //   Not within.
  //   Synchronize with (others) in the Processor by the Prototype::barrier.
  //
  // Usage:
  //
  //   See service::instance::Processor
  //
  struct Initialization;
}
#endiv
#divert <hpp>
#import tunitas.denniston.count
#import tunitas.denniston.error.Code
#import tunitas.denniston.network.Socket.Interface
#import tunitas.denniston.protocol.initialization.Computer
#import tunitas.denniston.service.processor.subprocess.Prototype
#import tunitas.denniston.report.ranges.Subrange
#import tunitas.keyston.hpke.Key
#import tunitas.keyston.protocol.initialization.Request
#import tunitas.keyston.protocol.initialization.Response
namespace tunitas::denniston::service::processor {
  namespace subprocess {
    inline auto swap(Initialization *&a, Initialization *&b) noexcept -> void { std::swap(a, b); }
  }
  class subprocess::Initialization : public Prototype {
    using Ancestor = Prototype;
  public:
    inline explicit Initialization(Processor &);
    //
    auto run() noexcept -> void;
  protected:
    using E = error::Code;
    using Report_Shares = keyston::protocol::initialization::Request::Report_Shares;
    using Project_to_Identifier = report::ranges::Subrange<report::ranges::Projection::REPORT_ID, Report_Shares::Basic_Iterator<Report_Shares const>>;
    using Interface = network::Socket::Interface;
    struct Protocol {
      using Request = keyston::protocol::initialization::Request;
      using Response = keyston::protocol::initialization::Response;
    };
    using Verify_Key = keyston::hpke::Key<keyston::hpke::Side::SECRET>;
    auto respond(Interface &back, Protocol::Request const &) -> void;
    using Computer = protocol::initialization::Computer;
  };
}
#endiv
#divert <ipp>
#import tunitas.denniston.job.Corpus
namespace tunitas::denniston::service::processor::subprocess {
  Initialization::Initialization(Processor &owner) : Ancestor{owner} {
    // expects this->barrier to already be started (locked)
    subbie = std::jthread{&Initialization::run, this};
  }
}
#divert <cpp>
namespace {
  namespace testate {
    using tunitas::denniston::service::processor::subprocess::Initialization;
    //
    static_assert(not std::semiregular<Initialization>);
    //
    // because that barrier in Initialization::Ancestor (Prototype) has an immobile mutex within it.
    static_assert(not std::is_default_constructible_v<Initialization>);
    static_assert(not std::is_copy_constructible_v<Initialization>);
    static_assert(not std::is_move_constructible_v<Initialization>);
    static_assert(not std::is_copy_assignable_v<Initialization>);
    static_assert(not std::is_move_assignable_v<Initialization>);
    static_assert(not std::is_swappable_v<Initialization>);
    static_assert(    std::is_swappable_v<Initialization *>);
  }
}
#import tunitas.denniston.protocol.packet.make
#import tunitas.denniston.protocol.packet.Query
#import tunitas.denniston.protocol.packet.Response
#import tunitas.denniston.protocol.packet.Status
#import nonstd.runtime_assert
namespace tunitas::denniston::service::processor::subprocess {
  auto Initialization::run() noexcept -> void try {
    barrier.wait([this]{ return !owner.tasks.empty(); });
    for (barrier.start(); !owner.is_shutting_down(); barrier.start()) {
      // waiting on the barrier ALSO checks for other signalling (e.g. graceful shutdown)
      barrier.wait([this]{ return !owner.initializations.empty(); });
      respond(owner.gateway, owner.initializations.pop_front()->payload);
    }
    owner.log.format("initialization is ending");
  } catch (process::companion::Shutdown) {
    // yay!
  } catch(...) {
    owner.log.format("initialize has an escaped exception which is suppressed");
  }
  auto Initialization::respond(Interface &back, Protocol::Request const &request) -> void {
    //
    // Reminder: each of the 'found' holds a lock on the Task and the Job dictionary.
    // Thus we are guaranteed we won't be interfered with while reading the task and job.
    // But we want to minimize the critical section.
    // There is contention for these resources with the Initialization thread.
    //
    // Steps:
    //
    //   1. Get the task (readonly).
    //   2. Probe for the job id (is it duplicated?)
    //   3. Make a new job (writable).
    //   4. Compute the vdaf state (preparation Step<POSITIONED>)
    //   5. Store the state.
    //   6. Return the response {continued, finished, failed}
    //
    owner.log.format("initialization responding for job {} task {}", request.job_id, request.task_id);
    if (auto found=owner.tasks.find(request.task_id); !found) {
      back.write(make<Status>(E::NO_SUCH_TASK));
    } else {
      auto anchor = Project_to_Identifier{request.report_shares}; // [[FIXTHIS]] infer this
      auto noob_id = request.job_id;
      if (auto [noob, inserted] = owner.jobs.insert(noob_id, {noob_id, *found, anchor.begin(), anchor.end()}); !inserted) {
        owner.log.format("duplicate job id {}; duplicate initialization for job id {}", noob_id, noob_id);
        back.write(make<Status>(E::DUPLICATE_JOB));
      } else {
        runtime_assert(request.task_id == found.value().definition.id); // i.e. we already knew this was true
        auto const &job_id = noob.definition.id;
        auto computer = [&, this]{
                           auto const sh = recover_processor_shard(owner.role);
                           auto const &ex = owner.executor;
                           auto const &vk = (Verify_Key const &) found.value().verify;
                           auto &no = owner.generators.noncer;
                           auto const &tid = request.task_id; // else reference the one we just found
                           auto const &ap = request.aggregation_parameters;
                           auto const &qu = request.query;
                           auto const &re = request.report_shares;
                           return Computer{sh, ex, vk, no, tid, ap, qu, re};
                         }();
        back.write(make<Response<Get::INITIALIZATION>>(job_id, computer()));
      }
    }
  }
}
#endiv
