// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc. 2022.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-denniston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/services/denniston/tree/LICENSE
#divert <fpp>
//
// The result of a lookup ("find") in the dictionary.
//
// Specification:
//
//   An optional reference to the found entry.
//   Rhymes with Optional<Value &>
//
// Design:
//
//   An optional reference (whatever that might mean.
//   These things are thus useful substantially only for the return value of Dictionary::find(...)
//
// Lifetimes:
//
//   lifetime(Found) < lifetime(Value &)
//   And consider the invalidation when the containing Dictionary is reorganized.
//
// Exceptions:
//
//   Throws exception::Optional{} upon indirection into an empty container.
//
// Usage:
//
//   auto found = dictionary.find(key);
//   if (found) {
//      ...*found or found.value()...
//   } else {
//      ...do without...
//   }
//   
#include <hpp/tunitas.denniston.task.Dictionary>
#endiv
#divert <hpp>
#import std.same_as
#import std.remove_const
#import tunitas.denniston.task.required.dictionary.Foundable
#import tunitas.denniston.dictionary.Found
namespace tunitas::denniston::task {
  template<required::dictionary::Foundable<Dictionary::Value> VALUE> struct Dictionary::Found : public dictionary::Found<VALUE, Dictionary::Value> {
    using Ancestor = dictionary::Found<VALUE, Dictionary::Value>;
    static_assert(std::same_as<Dictionary::Value, std::remove_const_t<VALUE>>, "belabor the point");
  public:
    Found() = default;
    using Ancestor::Found;
  };
}
#endiv
