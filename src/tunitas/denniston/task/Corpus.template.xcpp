// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc. 2022.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-denniston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/services/denniston/tree/LICENSE
#divert <fpp>
#import tunitas.denniston.Genus
#import tunitas.denniston.task.required.Corporal
namespace tunitas::denniston::task {
  //
  // Some of the processes need to keep around piles of work to do (or has been done)
  // This work is organized by id::Task.
  //
  // Specification:
  //
  //   Indexed by the service instance 
  //   Suitable for the VALUE of a Dictionary<VALUE>; i.e. required::Valueable<Corpus<INSTANCE>>.
  //
  // Design:
  //
  //   Specializations only for the object definitions.
  //   key_from(...) .... so that ADL will find it; an every specialization MUST have a field Corpus::definition
  //   swap(...) ........ so that ADL will find it.
  //
  // Usage:
  //
  //   Sure.
  //
  template<auto CORPORAL> requires required::Corporal<CORPORAL> struct Corpus;
}
#endiv
#divert <hpp>
#import tunitas.rheem.protocol.id // for id::Task
#import tunitas.denniston.task.required.corpus.Pointed
namespace tunitas::denniston::task {
  using std::move;
  template<auto CORPORAL> requires required::Corporal<CORPORAL> inline auto key_from(Corpus<CORPORAL> const &) -> rheem::protocol::id::Task const &;
  template<required::corpus::Pointed POINTED> inline auto swap(POINTED *&, POINTED *&) noexcept -> void;
}
#endiv
#divert <ipp>
namespace tunitas::denniston {
  template<auto CORPORAL> requires task::required::Corporal<CORPORAL> auto task::key_from(Corpus<CORPORAL> const &corpus) -> rheem::protocol::id::Task const & { return corpus.definition.id; }
  template<task::required::corpus::Pointed POINTED> auto task::swap(POINTED *&a, POINTED *&b) noexcept -> void { std::swap(a, b); }
}
#endiv
