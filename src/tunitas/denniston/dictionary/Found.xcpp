// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc. 2022.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-denniston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/services/denniston/tree/LICENSE
#divert <fpp>
#import tunitas.denniston.dictionary.required.Foundable
namespace tunitas::denniston::dictionary {
  //
  // The result of a lookup ("find") in the dictionary.
  //
  // Specification:
  //
  //   An optional reference to the found entry.
  //   Rhymes with Optional<Value &>
  //
  // Design:
  //
  //   An optional reference (whatever that might mean.
  //   These things are thus useful substantially only for the return value of Dictionary::find(...)
  //
  // Lifetimes:
  //
  //   lifetime(Found) < lifetime(Value &)
  //   And consider the invalidation when the containing Dictionary is reorganized.
  //
  // Exceptions:
  //
  //   Throws exception::Optional{} upon indirection into an empty container.
  //
  // Usage:
  //
  //   auto found = dictionary.find(key);
  //   if (found) {
  //      ...*found or found.value()...
  //   } else {
  //      ...do without...
  //   }
  //   
  template<typename VALUE, typename BASE> requires required::Foundable<VALUE, BASE> struct Found;
}
#endiv
#divert <hpp>
#import tunitas.Optional
#import std.is_same
#import std.remove_const
namespace tunitas::denniston {
  template<typename VALUE, typename BASE> requires dictionary::required::Foundable<VALUE, BASE> struct dictionary::Found {
    Found() = default;
    using Value = VALUE;
    inline Found(Value &);
    inline explicit operator bool() const;
    inline auto has_value() const -> bool;
#if 202312 < __cplusplus
    template<typename SELF> inline auto operator*(this SELF *) -> nonstd::like_t<SELF, Value &>;
    template<typename SELF> inline auto value(this SELF *) -> nonstd::like_t<SELF, Value &>;
#else
    inline auto operator*() -> Value &;
    inline auto operator*() const -> Value const &;
    inline auto value() -> Value &;
    inline auto value() const -> Value const &;
  private:
    template<typename SELF> inline static auto indirect(SELF &) -> decltype(auto);
  public:
#endif
  private:
    Optional<Value *> held{};
  };
}
#endiv
#divert <ipp>
#import tunitas.denniston.exception.Optional
namespace tunitas::denniston::dictionary {
  template<typename V, typename B> Found<V,B>::Found(Value &value) : held{&value} { }
  template<typename V, typename B> Found<V,B>::operator bool() const          { return held.operator bool(); }
  template<typename V, typename B> auto Found<V,B>::has_value() const -> bool { return held.has_value(); }
#if 202312 < __GNUC__
  template<typename V, typename B> template<typename SELF> auto Found<V,B>::operator*(this SELF *self) -> nonstd::like_t<SELF, Value &> { return self->value(); }
  template<typename V, typename B> template<typename SELF> auto Found<V,B>::value(this SELF *self) -> nonstd::like_t<SELF, Value &> {
    if (!self->held) {
      throw exception::Optional{};
    } else {
      return **self->held;
    }
  }
#else
  template<typename V, typename B> template<typename SELF> auto Found<V,B>::indirect(SELF &self) -> decltype(auto) {
    if (!self.held) {
      throw exception::Optional{};
    } else {
      return **self.held;
    }
  }
  template<typename V, typename B> auto Found<V,B>::operator*() -> Value &             { return indirect(*this); }
  template<typename V, typename B> auto Found<V,B>::operator*() const -> Value const & { return indirect(*this); }
  template<typename V, typename B> auto Found<V,B>::value() -> Value &                 { return indirect(*this); }
  template<typename V, typename B> auto Found<V,B>::value() const -> Value const &     { return indirect(*this); }
#endif
}
#endiv
