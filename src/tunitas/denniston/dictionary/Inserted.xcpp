// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc. 2022.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-denniston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/services/denniston/tree/LICENSE
#divert <fpp>
#import tunitas.denniston.dictionary.required.Valuable
#import tunitas.denniston.dictionary.required.Guardian
namespace tunitas::denniston::dictionary {
  //
  // The result of an insertion into the dictionary
  //
  // Specification:
  //
  //   <quote ref="https://en.cppreference.com/w/cpp/container/map/insert">
  //     1-3) Returns a pair consisting of
  //          an iterator to the inserted element (or to the element that prevented the insertion)
  //          and a bool denoting whether the insertion took place.
  //   </quote>
  //
  // Design:
  //
  //   Same as the underlying, but Indirect the iterator.
  //   Do not return the iterator, return the reference to the underlying
  //
  //   Because the thing holds a referece,
  //   no default construction
  //   no assignment
  //   no moving.
  //
  //   Basically these things are useful only to capture the result value of a call to Dictionary::insert(...)
  //
  //   On the use of tuple-theme
  //   See https://en.cppreference.com/w/cpp/language/structured_binding
  //   tl;dr using the tuple interpretation.
  //     a complete type definition for std::tuple_size<Inserted<...>> must be visible.
  //     get(...) is looked up as a member or at class scope or by ADL or by lexical visibility
  //
  // Usage:
  //
  //   As with insert(...)
  //
  //   auto [inserted_value, really_did_insert] = dictionary.insert(...somehow...)
  //
  template<required::Valuable, required::Guardian> struct Inserted;
}
#forward std.tuple_size.tunitas.denniston.dictionary.Inserted.VALUE.GUARD
#forward std.tuple_element.N.tunitas.denniston.dictionary.Inserted.VALUE.GUARD
#endiv
#divert <hpp>
#import tunitas.Pair
#import std.is_const
#import std.get
namespace tunitas::denniston {
  template<dictionary::required::Valuable VALUE, dictionary::required::Guardian GUARD> struct dictionary::Inserted : public Pair<VALUE &, bool> {
    using Ancestor = Pair<VALUE &, bool>;
    static_assert(!std::is_const_v<VALUE>, "belabor the point");
  public:
    using Guard = GUARD;
    using Value = VALUE;
    inline Inserted(Guard &&, Value &either_inserted_or_existing, bool did_actually_insert);
  protected:
    Guard guard;
    friend class std::tuple_size<Inserted<Value, Guard>>;
    template<Size N> friend auto get(Inserted const &i) -> decltype(auto) { return std::get<N>(i); }
    template<Size N> friend auto get(Inserted &i)       -> decltype(auto) { return std::get<N>(i); }
    template<Size N> friend auto get(Inserted &&i)      -> decltype(auto) { return std::get<N>(forward<Inserted>(i)); }
#if __GNUC__ <= 12
    // How are you supposed to do this?  We don't want *all* tuple elemetns to be friends.  Just some.
    template<Size N, typename TUPLE> friend class std::tuple_element;
#else
    // /exp/gcc/12/include/c++/12.1.1/bits/utility.h:84:11: internal compiler error: in tsubst, at cp/pt.cc:15813
    template<Size N, typename TUPLE> requires std::same_as<TUPLE, Inserted<Value, Guard>> friend class std::tuple_element;
#endif
  };
}
#import std.tuple_size.tunitas.denniston.dictionary.Inserted.VALUE.GUARD
#import std.tuple_element.N.tunitas.denniston.dictionary.Inserted.VALUE.GUARD
#endiv
#divert <ipp>
namespace tunitas::denniston::dictionary {
  template<required::Valuable V, required::Guardian G> Inserted<V,G>::Inserted(Guard &&guard, Value &either, bool did)
    : Ancestor{either, did}
    , guard{forward<Guard>(guard)}
  { }
}
#endiv
