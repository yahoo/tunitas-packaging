// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc. 2022.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-denniston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/services/denniston/tree/LICENSE
#divert <fpp>
#import tunitas.denniston.preparation.ranges.projection.Projection
namespace tunitas::denniston::preparation::ranges::projection {
  //
  // What does a projection do?
  // Specializations only.
  //
  // RECORD is constie or not
  //
  template<Projection, typename RECORD> struct Traits;
  template<typename RECORD> struct Traits<Projection::RECORD, RECORD>;
  template<typename RECORD> struct Traits<Projection::ID, RECORD>;
}
#endiv
#divert <hpp>
#import tunitas.keyston.protocol.id // for id::Report
#import tunitas.keyston.protocol.preparation.Step
#import std.conditional
namespace tunitas::denniston::preparation::ranges::projection {
  template<typename RECORD> struct Traits<Projection::RECORD, RECORD> {
    using Record = RECORD; // can be constie
    using Value = std::remove_const_t<RECORD>;
    using Reference = Record &;
    using Pointer = Record *;
  };
  template<typename RECORD> struct Traits<Projection::POSITIONED, RECORD> {
    using Replacement = keyston::protocol::preparation::Step<keyston::protocol::preparation::Mark::POSITIONED>;
  public:
    using Record = std::conditional<std::is_const_v<RECORD>, Replacement const, Replacement>;
    using Value = Replacement;
    using Reference = std::conditional_t<std::is_const_v<RECORD>, Value const &, Value &>;
    using Pointer = std::conditional_t<std::is_const_v<RECORD>, Value const *, Value *>;
  };
  template<typename RECORD> class Traits<Projection::ID, RECORD> {
    using Replacement = keyston::protocol::id::Report;
  public:
    using Record = std::conditional<std::is_const_v<RECORD>, Replacement const, Replacement>;
    using Value = Replacement;
    using Reference = std::conditional_t<std::is_const_v<RECORD>, Value const &, Value &>;
    using Pointer = std::conditional_t<std::is_const_v<RECORD>, Value const *, Value *>;
  };
}
#endiv
