// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc. 2022.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-denniston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/services/denniston/tree/LICENSE
#divert <fpp>
#import nonstd.required.iterator.Forward
#import nonstd.required.iterator.Producing
#import tunitas.denniston.task.Definition
#import std.remove_reference
namespace tunitas::denniston::protocol::packet::required::tasks {
  //
  // Produce Some task:Definitions
  // MUST produce the task by value (task:Definition) for copy or by constie reference
  // MUST  NOT by lvalue reference (task:Definition &&) for move
  // Check the iterator for specific return of task:Definition or task:Definition const &; never task:Definition &
  //
  // This DOES NOT handle the ancestry of keyston::protocol::task::task:Definition into denniston::task::task:Definition
  // or the implicit prmotion (conversion) of keyston::protocol::task::task:Definition into denniston::task::task:Definition.
  // See the hardcoding of the denniston task:Definition.
  // We're trading denniston tasks around, sot his is appropriate.
  //
  namespace [[eponymous]] eponymous_iterator {
    template<typename VALUE, typename MATCH> concept Copying = same_as<MATCH, VALUE> || same_as<MATCH const, std::remove_reference_t<VALUE>>;
    template<typename ITERATOR, typename VALUE> concept Iterator_Producing = requires(ITERATOR) {
      requires iterator::Forward<ITERATOR>;
      requires requires(VALUE, ITERATOR const constie, ITERATOR writing) {
        requires iterator::Producing<ITERATOR, VALUE>; // ... which is too vague
        { *constie } -> Copying<VALUE>;
        { *writing } -> Copying<VALUE>;
      };
    };
    template<typename ITERATOR> concept Iterator = Iterator_Producing<ITERATOR, denniston::task::Definition>;
  }
  using eponymous_iterator::Iterator;
}
#endiv
