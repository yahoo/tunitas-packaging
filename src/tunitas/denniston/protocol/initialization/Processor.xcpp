// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc. 2022.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-denniston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/services/denniston/tree/LICENSE
#divert <fpp>
namespace tunitas::denniston::protocol::initialization {
  //
  // The processor for the initialization step of the aggregation protocol
  //
  // Specification:
  //
  //   https://ietf-wg-ppm.github.io/draft-ietf-ppm-dap/draft-ietf-ppm-dap.html
  //   Section 4.4.1 Aggregate Initialization
  //
  //   We call it "process" not "aggregate" because it ... (wait for it) ... processes.
  //
  // Design:
  //
  //   Stateless.
  //   How hard can this be?
  //   Copy some fields from the left side to the right side.
  //   Return the result; go home.
  //
  //   (To avoid gratuitous copying) The processor works against references to its components.
  //
  // Lifetimes:
  //
  //   lifetime(Processor) < lifetime(...components...)
  //   The lifetime of the components must be longer than that of the Processor.
  //
  // Exceptions:
  //
  //   Throws Invalid upon Inappropriate service species.
  //   The service species MUST be PROCESSOR1 or PROCESSOR2
  //
  // Usage:
  //
  //   [[as found in each service::instance::Processor]]
  //   <rhymes-with>
  //     auto processor = Processor{task_id, job_id, query, prepared};
  //     origin.processors.write(make<Response<INITIALIZATION>>(process()));
  //   </rhymes-with>
  //
  struct Processor;
}
#endiv
#divert <hpp>
#import tunitas.denniston.index // for index::Processor
#import tunitas.keyston.nonce.Generator
#import tunitas.keyston.protocol.id // id::Task and id::Job
#import tunitas.keyston.protocol.function.Parameters
#import tunitas.keyston.protocol.initialization.Request
#import tunitas.keyston.protocol.initialization.Response
#import tunitas.keyston.vdaf.Configuration
#import tunitas.keyston.vdaf.Executor
struct tunitas::denniston::protocol::initialization::Processor {
  using Index = index::Processor;
  using Function = keyston::vdaf::Executor<keyston::vdaf::Scheme::PROTOCOL>;
  using Verify_Key = keyston::vdaf::Configuration<keyston::vdaf::Scheme::PROTOCOL>::Verify_Key;
  using Nonce = keyston::vdaf::Configuration<keyston::vdaf::Scheme::PROTOCOL>::Nonce;
  using Noncer = keyston::nonce::Generator<Nonce>;
  struct Identifier {
    using Task = keyston::protocol::id::Task;
    using Job = keyston::protocol::id::Job;
  };
  using Parameters = keyston::protocol::function::Parameters;
  using Query = keyston::protocol::initialization::Request::Query;
  using Reports = keyston::protocol::initialization::Request::Report_Shares;
  using Report = Reports::Value;
  using Response = keyston::protocol::initialization::Response;
  //
  Index index{};
  Function exe{};
  Verify_Key const &verify_key;
  Noncer &noncer;
  Identifier::Task const &task_id;
  Identifier::Job const &job_id;
  Parameters const &parameters;
  Query const &query;
  Reports const &reports;
  //
  inline [[implicit]] Processor(Index, Function, Verify_Key const &, Noncer &, Identifier::Task const &, Identifier::Job const &, Parameters const &, Query const &, Reports const &);
  inline auto operator()() const -> Response;
};
#endiv
#divert <ipp>
namespace tunitas::denniston::protocol::initialization {
  Processor::Processor(Index index, Function exe, Verify_Key const &verify_key, Noncer &noncer, Identifier::Task const &tid, Identifier::Job const &jid, Parameters const &par, Query const &que, Reports const &rep)
    : index{index}
    , exe{exe}
    , verify_key{verify_key}
    , noncer{noncer}
    , task_id{tid}
    , job_id{jid}
    , parameters{par}
    , query{que}
    , reports{rep}
  { }
  auto Processor::operator()() const -> Response {
    auto ret = Response{};
    for (auto &shard : reports) {
      ret.preparation_steps.push_back(exe.initialization(parameters, verify_key, index, noncer(), shard.public_share, shard.encrypted_input_share));
    }
    return ret;
  }
}
#endiv
