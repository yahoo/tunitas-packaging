// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc. 2022.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-denniston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/services/denniston/tree/LICENSE
#divert <fpp>
namespace tunitas::denniston::protocol::initialization {
  //
  // The computer (function processor) for the initialization step of the aggregation protocol
  //
  // Specification:
  //
  //   https://ietf-wg-ppm.github.io/draft-ietf-ppm-dap/draft-ietf-ppm-dap.html
  //   Section 4.4.1 Aggregate Initialization
  //
  //   We call it "compute" not "process" or "aggregate" because it ... (wait for it) ... computes.
  //
  // Design:
  //
  //   Stateless.
  //   How hard can this be?
  //   Copy some fields from the left side to the right side.
  //   Return the result; go home.
  //
  //   (To avoid gratuitous copying) The computer works against references to its components.
  //
  // Lifetimes:
  //
  //   lifetime(Computer) < lifetime(...components...)
  //   (otherwise said) The lifetime of the components must be longer than that of the Computer.
  //
  // Exceptions:
  //
  //   Throws Invalid upon Inappropriate service species.
  //   The service species MUST be PROCESSOR1 or PROCESSOR2
  //
  // Usage:
  //
  //   [[as found in each service::processor::Initialization, or processor::Continuation]]
  //   <rhymes-with>
  //     ...something something dark-side...
  //   </rhymes-with>
  //
  struct Computer;
}
#endiv
#divert <hpp>
#import tunitas.denniston.index // for index::Processor
#import tunitas.keyston.nonce.Generator
#import tunitas.keyston.protocol.id // for id::Task
#import tunitas.keyston.protocol.function.Parameters
#import tunitas.keyston.protocol.initialization.Request
#import tunitas.keyston.protocol.initialization.Response
#import tunitas.keyston.vdaf.Configuration
#import tunitas.keyston.vdaf.Executor
class tunitas::denniston::protocol::initialization::Computer {
protected:
  using Nonce = keyston::vdaf::Configuration<keyston::vdaf::Scheme::PROTOCOL>::Nonce;
public:
  using Index = index::Processor;
  using Function = keyston::vdaf::Executor<keyston::vdaf::Scheme::PROTOCOL>;
  using Verify_Key = keyston::vdaf::Configuration<keyston::vdaf::Scheme::PROTOCOL>::Verify_Key;
  using Noncer = keyston::nonce::Generator<Nonce>;
  struct Identifier {
    using Task = keyston::protocol::id::Task;
  };
  using Parameters = keyston::protocol::function::Parameters;
  using Query = keyston::protocol::initialization::Request::Query;
  using Reports = keyston::protocol::initialization::Request::Report_Shares;
  using Response = keyston::protocol::initialization::Response;
  //
  Index index{};
  Function exe{};
  Verify_Key const &verify_key;
  Noncer &noncer;
  Identifier::Task const &task_id;
  Parameters const &parameters;
  Query const &query;
  Reports const &reports;
  //
  inline [[implicit]] Computer(Index, Function, Verify_Key const &, Noncer &, Identifier::Task const &, Parameters const &, Query const &, Reports const &);
  inline auto operator()() const -> Response;
protected:
  using Report = Reports::Value;
  using Step = Response::Preparation_Steps::Value;
};
#endiv
#divert <ipp>
namespace tunitas::denniston::protocol::initialization {
  Computer::Computer(Index index, Function exe, Verify_Key const &verify_key, Noncer &noncer, Identifier::Task const &tid, Parameters const &par, Query const &que, Reports const &rep)
    : index{index}
    , exe{exe}
    , verify_key{verify_key}
    , noncer{noncer}
    , task_id{tid}
    , parameters{par}
    , query{que}
    , reports{rep}
  { }
  auto Computer::operator()() const -> Response {
    auto ret = Response{};
    for (auto &report : reports) {
      auto state = exe.initialization(parameters, verify_key, index, noncer(), report.public_share, report.encrypted_input_share);
      auto step = Step{report.report_id, move(state)};
      ret.preparation_steps.push_back(move(step));
    }
    return ret;
  }
}
#endiv
