// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc. 2022.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-denniston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/services/denniston/tree/LICENSE
#divert <fpp>
namespace tunitas::denniston::process {
  //
  // At the process level, are any channels readable?
  //
  // Specification:
  //
  //   A multi-lock situation
  //   The first lock(able) is special, for it guards the "is ready" bit.
  //   A lock+condition (variable) system.
  //
  // Design:
  //
  //   Right outta da books.
  //
  //   See te recipe for using a condition variable
  //   https://en.cppreference.com/w/cpp/thread/condition_variable
  //   1. acquire a std::unique_lock<std::mutex>, on the same mutex as used to protect the shared variable
  //   2. choices among the predicated variants of wait(...), wait_for(...), wait_until(...)
  //
  // Usage:
  //
  //   Positioned in a process.
  //   Socket::Interface performs update+notifications.
  //
  // Centrall; e.g. at the service instance (a.k.a. "process") state variables (a.k.a. "struct").
  //
  //   struct Something {
  //     ...etc...
  //     Ready ready{};
  //     ...etc...
  //   }
  //
  // Reading; e.g. within the service instance's run function
  //
  //    while (true) {
  //      ready.wait();
  //      ... something is ready to read ... find it (poll).
  //      auto red0 = some_face.read_if();
  //      auto red1 = someother_face.read_if();
  //      auto red2 = another_face.read_if();
  //      auto red3 = and_another_face.read_if();
  //      ... and so on...
  //   }
  //
  // Writing:
  //
  //   readability.notify();
  //
  struct Ready;
}
#endiv
#divert <hpp>
#import std.mutex
#import std.lock_guard
#import std.unique_lock
#import std.condition_variable
#import tunitas.denniston.process.Readable
#forward tunitas.denniston.process.readable.Container
#forward tunitas.denniston.process.readable.Fixed
#forward tunitas.denniston.process.readable.Variable
class tunitas::denniston::process::Ready {
protected:
  template<readable::required::Array> friend class readable::Container;
  template<Size> friend class readable::Fixed;
  friend class readable::Variable;
  std::mutex lock{};
  // std::unique_lock<std::mutex> lock{mutex, std::defer_lock};
  std::condition_variable condition{};
  bool some_channel_is_ready_to_read{};
  using Guard = std::lock_guard<std::mutex>;
  using Unique = std::unique_lock<std::mutex>;
public:
  inline auto notify() -> void;
  inline auto wait([[inout]] Readable &) -> void;
};
#endiv
#divert <ipp>
namespace tunitas::denniston::process {
  auto Ready::notify() -> void {
    { auto guard = Guard{lock};
      some_channel_is_ready_to_read = true; }
    // [[does it matter?]] dont' notify while in the critical section
    condition.notify_all();
  }
  auto Ready::wait(Readable &them) -> void {
    them.lock();
    some_channel_is_ready_to_read |= them.is_ready_to_read();
    them.unlock_rest();
    if (!some_channel_is_ready_to_read) {
      auto uuu = Unique{lock, std::adopt_lock};
      condition.wait(uuu, [&location=some_channel_is_ready_to_read]{ return location; });
      uuu.release();
    }
    some_channel_is_ready_to_read = false; // You MUST now go about your business reading the channels
    them.unlock_first();
  }
}
#endiv
