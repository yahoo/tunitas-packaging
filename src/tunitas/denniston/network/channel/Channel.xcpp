// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc. 2022.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-denniston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/services/denniston/tree/LICENSE
#divert <fpp>
namespace tunitas::denniston::network::channel {
  //
  // A (network) channel of things
  //
  // Specification:
  //
  //    It's a queue with a push_back and pop(front).
  //    Is thread-safe.
  //
  // Design:
  //
  //   naming: Channel<T>::push_back(...) because 'push_back' is the standard name for these things.
  //   naming: Channel<T>::pop(...) is pop_front()
  //
  //   There are no iterators over the internals of the channel.
  //
  //   yes these are non-const because of the locks; channels are always actively being thrashed upon.
  //   yes, you can't peek at the the channel without copying what is out there (think about it).
  //
  // Exception guarantees
  //
  //   If exceptions are thrown, the locks are released
  //   If an exception is thrown, the channel is in a consistent & operable state.
  //   If an exception is thrown on iterated push_back, then the channel is in some partially updated state.
  //
  // Usage:
  //
  //    auto const SIZE = 5lu;
  //    Channel<Message> ch(SIZE);
  //    ch.push(Message{});
  //    auto message = ch.pop();
  //    auto message = ch.peek();
  //    auto e = ch.empty();
  //    auto e = ch.size();
  //
  template<typename TYPE> class Channel;
}
#endiv
#divert <hpp>
#import std.deque
#import std.bind
#import nonstd.required.iterator.Producing
#import tunitas.denniston.network.channel.Peek
#import tunitas.denniston.network.channel.Variables.Predicate
#import tunitas.denniston.network.channel.required.Peekable
#import tunitas.denniston.network.channel.Pollability
#import tunitas.denniston.network.required // ctcnr (cascade that certain 'namespace required')
namespace tunitas::denniston::network {
  template<typename TYPE> class channel::Channel : private std::deque<TYPE>, public Pollability {
    using Ancestor = std::deque<TYPE>;
  public:
    using Value = TYPE;
    inline static auto const DEFAULT_SIZE = 10uz;
    inline explicit Channel(Size limit = DEFAULT_SIZE); // push operations block until the queue drains
    Channel(Channel const &) = delete;
    auto operator=(Channel const &) -> Channel & = delete;
    Channel(Channel &&) = delete;
    auto operator=(Channel &&) -> Channel & = delete;
    inline auto push_back(Value &&) -> void;
    inline auto push_back(Value const &) -> void;
    // [[FIXTHIS]] there is no obvious way to signal "push_back iterators, but use move not copy" is there?
    template<required::iterator::Producing<Value> ITERATOR> inline auto push_back(ITERATOR first, ITERATOR last) -> void;
    template<typename... ARGS> inline auto emplace_back(ARGS &&...) -> void;
    inline auto pop() -> Value; // ................ blocks until there is something to pop
    inline auto pop_if() -> Optional<Value>; // ... does not block
    inline auto peek() -> Peek<Value>;
    inline auto empty() -> bool;
    inline auto size() -> Size;
    virtual auto is_ready_to_read() -> bool override;  // the caller MUST lock
  protected:
    Size limit;
    friend class channel::Variables::Predicate;
    inline auto is_not_full() const -> bool { return Ancestor::size() <= limit; }
    inline auto is_not_empty() const -> bool { return !Ancestor::empty(); }
    inline auto nonfull() const -> Variables::Predicate  { return Variables::Predicate{&Variables::nonfull, std::bind(&Channel::is_not_full, this)}; }
    inline auto nonempty() const -> Variables::Predicate { return Variables::Predicate{&Variables::nonempty, std::bind(&Channel::is_not_empty, this)}; }
  };
}
#endiv
#divert <ipp>
#import std.error_code
#import tunitas.denniston.network.channel.Variables.Guard.Exclusive
#import tunitas.denniston.network.channel.Variables.Guard.Condition
#import tunitas.denniston.network.error.Code
namespace tunitas::denniston::network::channel {
  template<typename _> Channel<_>::Channel(Size limit)
    : limit{limit}
  { }
  template<typename _> auto Channel<_>::push_back(Value &&value) -> void {
    Variables::Guard::Condition guard{Pollability::variables, nonfull()};
    Ancestor::push_back(std::move(value));
  }
  template<typename _> auto Channel<_>::push_back(Value const &value) -> void {
    Variables::Guard::Condition guard{Pollability::variables, nonfull()};
    Ancestor::push_back(value);

  }
  template<typename _> template<required::iterator::Producing<_> ITERATOR> auto Channel<_>::push_back(ITERATOR here, ITERATOR last) -> void {
    Variables::Guard::Condition guard{Pollability::variables, nonfull()};
    for ( ;  last != here; ++here) {
      Ancestor::push_back(*here);
    }
  }
  template<typename _> template<typename... ARGS> auto Channel<_>::emplace_back(ARGS &&...args) -> void {
    Variables::Guard::Condition guard{Pollability::variables, nonfull()};
    Ancestor::emplace_back(std::forward<ARGS>(args)...);
  }
  template<typename _> auto Channel<_>::pop() -> Value {
    Variables::Guard::Condition guard{Pollability::variables, nonempty()};
    auto popped{std::move(Ancestor::front())};
    Ancestor::pop_front();
    return popped;
  }
  template<typename _> auto Channel<_>::pop_if() -> Optional<Value> {
    Variables::Guard::Exclusive guard{variables};
    if (Ancestor::empty()) {
      return {};
    } else {
      auto popped{std::move(Ancestor::front())};
      Ancestor::pop_front();
      return popped;
    }
  }
  template<typename _> auto Channel<_>::peek() -> Peek<Value> {
    Variables::Guard::Exclusive guard{variables};
#if 1
    if (Ancestor::empty()) {
      return {};
    } else {
      return Peek<Value>{Ancestor::front()}; // WATCHOUT - this returns a (constie) reference into the queue.
    }
#else
    if (Ancestor::empty()) {
      return nonstd::Outcome<RESULT>{std::error_code{error::Code::EMPTY}};
    } else {
      return nonstd::Outcome<RESULT>{Ancestor::front()}; // WATCHOUT - this requires copy semantics -- DO NOT USE std::move(...)
    }
#endif
  }
  template<typename _> auto Channel<_>::empty() -> bool {
    Variables::Guard::Exclusive guard{variables};
    return Ancestor::empty();
  }
  template<typename _> auto Channel<_>::size() -> Size {
    Variables::Guard::Exclusive guard{variables};
    return Ancestor::size();
  }
}
#endiv
#divert <tpp>
namespace tunitas::denniston::network::channel {
  template<typename _> auto Channel<_>::is_ready_to_read() -> bool {
    // WATCHOUT - this MUST be called lock-free (the caller sets up and holds *this* lock on *this* mutex)
    // Calling this->empty() is WRONG because it lock
    return !Ancestor::empty();
  }
}
#endiv
