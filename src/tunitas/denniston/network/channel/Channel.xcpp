// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc. 2022.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-denniston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/services/denniston/tree/LICENSE
#divert <fpp>
namespace tunitas::denniston::network::channel {
  //
  // A (network) channel of things
  // It's a queue with a push end and a pop end
  // Is thread-safe.
  //
  // There are no iterators over the internals of the channel.
  //
  // Exception guarantees
  //   If exceptions are thrown, the locks are released
  //   If an exception is thrown, the channel is in a consistent & operable state.
  //   If an exception is thrown on iterated push_back, then the channel is in some partially updated state.
  //
  // Usage:
  //
  //    auto const SIZE = 5lu;
  //    Channel<Message> ch(SIZE);
  //    ch.push(Message{});
  //    auto message = ch.pop();
  //    auto message = ch.peek();
  //    auto e = ch.empty();
  //    auto e = ch.size();
  //
  template<typename TYPE> class Channel;
}
#endiv
#divert <hpp>
#import std.deque
#import std.bind
#import nonstd.required.iterator.Producing
#import tunitas.denniston.network.channel.Peek
#import tunitas.denniston.network.channel.Predicate
#import tunitas.denniston.network.channel.Variables
#import tunitas.denniston.network.channel.required.Peekable
#import tunitas.denniston.network.required // ctcnr (cascade that certain 'namespace required')
namespace tunitas::denniston::network {
  template<typename TYPE> class channel::Channel : private std::deque<TYPE> {
    using Ancestor = std::deque<TYPE>;
  public:
    using Value = TYPE;
    inline static auto const DEFAULT_SIZE = 10uz;
    inline explicit Channel(Size limit = DEFAULT_SIZE); // push operations block until the queue drains
    Channel(Channel const &) = delete;
    auto operator=(Channel const &) -> Channel & = delete;
    Channel(Channel &&) = delete;
    auto operator=(Channel &&) -> Channel & = delete;
    inline auto push_back(Value &&) -> void;
    inline auto push_back(Value const &) -> void;
    // [[FIXTHIS]] there is no obvious way to signal "push_back iterators, but use move not copy" is there?
    template<required::iterator::Producing<Value> ITERATOR> inline auto push_back(ITERATOR first, ITERATOR last) -> void;
    template<typename... ARGS> inline auto emplace_back(ARGS &&...) -> void;
    inline auto pop() -> Value; // blocks until there is something to pop
    // yes these are non-const because of the locks; channels are always actively being thrashed upon.
    // yes, you can't peek at the the channel without copying what is out there (think about it).
    inline auto peek() -> Peek<Value>;
    inline auto empty() -> bool;
    inline auto size() -> Size;
  protected:
    Size limit;
    friend class channel::Predicate;
    inline auto is_not_full() const -> bool { return Ancestor::size() <= limit; }
    inline auto is_not_empty() const -> bool { return !Ancestor::empty(); }
    inline auto nonfull() const -> Predicate { return Predicate{&Variables::nonfull, std::bind(&Channel::is_not_full, this)}; }
    inline auto nonempty() const -> Predicate { return Predicate{&Variables::nonempty, std::bind(&Channel::is_not_empty, this)}; }
    Variables variables;   // is neither copyable nor movable. 
  };
}
#endiv
#divert <ipp>
#import std.error_code
#import std.move
#import std.forward
#import tunitas.denniston.network.channel.Exclusive.Guard
#import tunitas.denniston.network.channel.Condition
#import tunitas.denniston.network.error.Code
namespace tunitas::denniston::network::channel {
  template<typename _> Channel<_>::Channel(Size limit)
    : limit{limit}
  { }
  template<typename _> auto Channel<_>::push_back(Value &&value) -> void {
    Condition guard{variables, nonfull()};
    Ancestor::push_back(std::move(value));
  }
  template<typename _> auto Channel<_>::push_back(Value const &value) -> void {
    Condition guard{variables, nonfull()};
    Ancestor::push_back(value);

  }
  template<typename _> template<required::iterator::Producing<_> ITERATOR> auto Channel<_>::push_back(ITERATOR here, ITERATOR last) -> void {
    Condition guard{variables, nonfull()};
    for ( ;  last != here; ++here) {
      Ancestor::push_back(*here);
    }
  }
  template<typename _> template<typename... ARGS> auto Channel<_>::emplace_back(ARGS &&...args) -> void {
    Condition guard{variables, nonfull()};
    Ancestor::emplace_back(std::forward<ARGS>(args)...);
  }
  template<typename _> auto Channel<_>::pop() -> Value {
    Condition guard{variables, nonempty()};
    auto popped{std::move(Ancestor::front())};
    Ancestor::pop_front();
    return popped;
  }
  template<typename _> auto Channel<_>::peek() -> Peek<Value> {
    Exclusive::Guard guard{variables};
#if 1
    if (Ancestor::empty()) {
      return {};
    } else {
      return Peek<Value>{Ancestor::front()}; // WATCHOUT - this returns a (constie) reference into the queue.
    }
#else
    if (Ancestor::empty()) {
      return nonstd::Outcome<RESULT>{std::error_code{error::Code::EMPTY}};
    } else {
      return nonstd::Outcome<RESULT>{Ancestor::front()}; // WATCHOUT - this requires copy semantics -- DO NOT USE std::move(...)
    }
#endif
  }
  template<typename _> auto Channel<_>::empty() -> bool {
    Exclusive::Guard guard{variables};
    return Ancestor::empty();
  }
  template<typename _> auto Channel<_>::size() -> Size {
    Exclusive::Guard guard{variables};
    return Ancestor::size();
  }
}
#endiv
