// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc. 2022.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-denniston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/drivers/denniston/tree/LICENSE
#divert <fpp>
namespace tunitas::denniston::driver {
  //
  // The manifestation of a driver (a computing resource).
  //
  // Specification:
  //
  //   Manages some computing.
  //   Publishes an interface by which it can be contacted.
  //
  // Design:
  //
  //   Something something: a thread.
  //
  // Usage:
  //
  //   In the environment..
  //
  struct Driver;
}
#endiv
#divert <hpp>
#import tunitas.denniston.log.Concentrator
#import tunitas.denniston.network.Sockets
#import tunitas.denniston.network.Sockets.Interfaces
#import tunitas.denniston.service.System
#import tunitas.denniston.service.Instance
#import tunitas.denniston.driver.Threads
#import tunitas.keyston.entropy.Source
#import tunitas.denniston.World
namespace tunitas::denniston {
  namespace driver {
    using std::move;
  }
  struct driver::Driver {
    keyston::entropy::Source entropy{};
    denniston::World world;
    service::System system;
    denniston::log::Concentrator log{};
    network::Sockets sockets{};
    Threads threads{};
    struct Control {
      network::Sockets::Interfaces everyone{};
      network::Sockets::Interfaces clients{};
    } control{};
    //
    auto shutdown() -> void; // idempotent
    //
    inline constexpr static auto DEFAULT_INITIAL_CLIENT_COUNT = 3uz;
    explicit Driver(Size = DEFAULT_INITIAL_CLIENT_COUNT);
    ~Driver();
    Driver(Driver const &) = delete;
    Driver &operator=(Driver const &) = delete;
  protected:
    network::channel::Ready ready{}; 
    auto startup() -> void;
    auto link_logging() -> void;
    auto link_configuration() -> void;
    auto link_control() -> void;
    auto link_directory() -> void;
    auto link_gateway() -> void;
    inline auto bind_control_system([[inout]] network::Socket::Interface &, [[in]] network::channel::Ready &) -> network::Socket::Interface;
    inline auto bind_control_userland([[inout]] network::Socket::Interface &, [[in]] network::channel::Ready &) -> void;
    inline auto bind([[inout]] network::Socket::Interface &green_face, [[inout]] network::channel::Ready &green_ready, [[inout]] network::Socket::Interface &blue_face, [[inout]] network::channel::Ready &blue_ready) -> void;
  };
}
#endiv
#divert <ipp>
namespace tunitas::denniston::driver {
  auto Driver::bind_control_userland(network::Socket::Interface &face, network::channel::Ready &ready) -> void { control.clients.push_back(bind_control_system(face, ready)); }
  auto Driver::bind_control_system(network::Socket::Interface &green_face, network::channel::Ready &green_ready) -> network::Socket::Interface {
    control.everyone.push_back(network::Socket::Interface{});
    auto &blue_face = control.everyone.back();
    auto &blue_ready = this->ready;
    bind(green_face, green_ready, blue_face, blue_ready);
    return blue_face;
  }
  auto Driver::bind(network::Socket::Interface &green_face, network::channel::Ready &green_ready, network::Socket::Interface &blue_face, network::channel::Ready &blue_ready) -> void {
    // when we write to blue, green must be notified that it is ready-to-ready
    // When we write to green, blue becomes ready
    auto noob = sockets.allocate();
    green_face = noob->left(&blue_ready);
    blue_face = noob->right(&green_ready);
  }
}
#endiv
#divert <cpp>
#import tunitas.denniston.service.Instance
#import std.clog
namespace tunitas::denniston::driver {
  Driver::Driver(Size initial_client_count)
    : world{entropy}
    , system{world, initial_client_count}
  {
    log.outbound = &std::clog; // else we won't see anything!
    link_logging();
    // in arbitrary order
    link_control();
    link_gateway();
    link_configuration();
    link_directory();
    // and finally
    startup();
  }
  Driver::~Driver() {
    shutdown();
  }
  auto Driver::link_configuration() -> void {
    for (auto i{0uz}, e{system.processors.size()}; e != i; ++i) {
      bind(system.configuration->processors[i], system.processors[i]->ready, system.processors[i]->configuration, system.configuration->ready);
    }
    for (auto i{0uz}, e{system.clients.size()}; e != i; ++i) {
      bind(system.configuration->clients[i], system.clients[i]->ready, system.clients[i]->configuration, system.configuration->ready);
    }
  }
  auto Driver::link_control() -> void {
    bind_control_system(system.gateway->control, system.gateway->ready);
    bind_control_system(system.collector->control, system.collector->ready);
    bind_control_system(system.configuration->control, system.configuration->ready);
    for (auto &processor : system.processors) {
      bind_control_system(processor->control, processor->ready);
    }
    for (auto &client : system.clients) {
      bind_control_userland(client->control, client->ready);
    }
  }
  auto Driver::link_directory() -> void {
    for (auto i{0uz}, e{system.clients.size()}; e != i; ++i) {
      bind(system.directory->clients[i], system.clients[i]->ready, system.clients[i]->configuration, system.directory->ready);
    }
  }
  auto Driver::link_gateway() -> void {
    for (auto i{0uz}, e{system.processors.size()}; e != i; ++i) {
      bind(system.gateway->processors[i], system.processors[i]->ready, system.processors[i]->gateway, system.gateway->ready);
    }
    for (auto i{0uz}, e{system.clients.size()}; e != i; ++i) {
      bind(system.configuration->clients[i], system.clients[i]->ready, system.clients[i]->configuration, system.configuration->ready);
    }
    bind(system.gateway->collector, system.collector->ready, system.collector->gateway, system.gateway->ready);
  }
  auto Driver::link_logging() -> void {
    system.gateway->log.concentrator = &log;
    system.collector->log.concentrator = &log;
    system.configuration->log.concentrator = &log;
    for (auto &processor : system.processors) {
      processor->log.concentrator = &log;
    }
    for (auto &client : system.clients) {
      client->log.concentrator = &log;
    }
  }
  auto Driver::startup() -> void {
    system.gateway->launch(threads);
    system.collector->launch(threads);
    for (auto &processor : system.processors) {
      processor->launch(threads);
    }
    for (auto &client : system.clients) {
      client->launch(threads);
    }
  }
}
#import tunitas.denniston.message.packet.make
#import tunitas.denniston.message.packet.Quit
namespace tunitas::denniston::driver {
  auto Driver::shutdown() -> void {
    using namespace message::packet;
    for (auto &face : control.everyone) {
      face.write(make<Quit>());
    }
    // and after the Quit messages are processed, all the run(...) functions will have exited.
  }
}
namespace {
  namespace testate {
    using namespace tunitas::denniston::driver;
    static_assert(std::is_default_constructible_v<Driver>);
    static_assert(not std::is_copy_constructible_v<Driver>);
    static_assert(not std::is_move_constructible_v<Driver>);
    static_assert(not std::is_copy_assignable_v<Driver>);
    static_assert(not std::is_move_assignable_v<Driver>);
    static_assert(not std::is_swappable_v<Driver>);
  }
}
#endiv
