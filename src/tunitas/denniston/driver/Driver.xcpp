// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc. 2022.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-denniston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/services/denniston/tree/LICENSE
#divert <fpp>
namespace tunitas::denniston::driver {
  //
  // The manifestation of a driver (a computing resource).
  //
  // Specification:
  //
  //   Manages some computing.
  //   Publishes an interface by which it can be contacted.
  //
  // Design:
  //
  //   Something something: a thread.
  //
  //   Driver::shutdown() is idempotent
  //   driver::one_shot_shut_down() is NOT idempotent and MUST be run precisely once.
  //        WATCHOUT - if you run it multiply then it sends control messages to defunct processes (and thus hangs)
  //
  // Usage:
  //
  //   In the environment..
  //
  struct Driver;
}
#endiv
#divert <hpp>
#import tunitas.denniston.driver.Layout
namespace tunitas::denniston {
  namespace driver {
    using std::move;
  }
  class driver::Driver : public Layout {
    using Ancestor = Layout;
  public:
    [[idempotent]] inline auto shutdown() -> void;
    //
    explicit Driver(Size = DEFAULT_INITIAL_CLIENT_COUNT);
    ~Driver();
    Driver(Driver const &) = delete;
    Driver &operator=(Driver const &) = delete;
  protected:
    auto startup() -> void;
    auto enable_logging() -> void;
    bool has_been_shut_down{false};
    [[NOT_idempotent]] auto one_shot_shut_down() -> void;
  };
}
#endiv
#divert <ipp>
namespace tunitas::denniston::driver {
  auto Driver::shutdown() -> void {
    if (!has_been_shut_down) {
      one_shot_shut_down();
    }
  }
}
#endiv
#divert <cpp>
#import tunitas.denniston.service.Instance
#import tunitas.denniston.driver.Linker
#import std.clog
namespace tunitas::denniston::driver {
  Driver::Driver(Size initial_client_count) : Layout{initial_client_count} {
    logs.outbound = &std::clog; // else we won't see anything!
    enable_logging();
    auto link = Linker{*this};
    // in arbitrary order
    link.control();
    link.gateway();
    link.configuration();
    link.directory();
    // and finally
    startup();
  }
  Driver::~Driver() {
    shutdown();
  }
  auto Driver::enable_logging() -> void {
    // ALL processes of the System MUST be listed here (else you'll see no logsnothing)
    system.collector->log.concentrator = &logs;
    system.configuration->log.concentrator = &logs;
    system.directory->log.concentrator = &logs;
    system.gateway->log.concentrator = &logs;
    for (auto &processor : system.processors) { processor->log.concentrator = &logs; }
    for (auto &client : system.clients)       { client->log.concentrator = &logs; }
  }
  auto Driver::startup() -> void {
    system.configuration->launch(threads);
    system.directory->launch(threads);
    system.gateway->launch(threads);
    system.collector->launch(threads);
    for (auto &processor : system.processors) {
      processor->launch(threads);
    }
    for (auto &client : system.clients) {
      client->launch(threads);
    }
  }
}
#import tunitas.denniston.protocol.packet.make
#import tunitas.denniston.protocol.packet.Quit
#import nonstd.runtime_assert
namespace tunitas::denniston::driver {
  auto Driver::one_shot_shut_down() -> void {
    runtime_assert(!has_been_shut_down);
    has_been_shut_down = true;
    using namespace protocol::packet;
    for (auto &face : control.everyone) {
      face.write(make<Quit>());
    }
    // and after the Quit packets are processed, all the run(...) functions will have exited.
  }
}
namespace {
  namespace testate {
    using namespace tunitas::denniston::driver;
    static_assert(std::is_default_constructible_v<Driver>);
    static_assert(not std::is_copy_constructible_v<Driver>);
    static_assert(not std::is_move_constructible_v<Driver>);
    static_assert(not std::is_copy_assignable_v<Driver>);
    static_assert(not std::is_move_assignable_v<Driver>);
    static_assert(not std::is_swappable_v<Driver>);
  }
}
#endiv
