// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc. 2022.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-denniston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/services/denniston/tree/LICENSE
#divert <fpp>
namespace tunitas::denniston::driver {
  //
  // The manifestation of a driver (a computing resource).
  //
  // Specification:
  //
  //   A Driver manages Asome computing.
  //   Publishes an interface by which it can be contacted.
  //
  //   Starts immediately upon construction
  //   Shutdown (stopping) must be managed to recover from schduler exceptions.
  //
  // Design:
  //
  //   Something something: a thread.
  //
  //   Whereas we acknowledge that userland can cause scheduling problems such as deadlock-on-graceful_hutdown
  //   we work within the scheduler operations infrastructure to map those detected prolems to exceptions.
  //
  //   Driver::shutdown() is idempotent
  //   driver::one_shot_shut_down() is NOT idempotent and MUST be run precisely once.
  //        WATCHOUT - if you run it multiply then it sends control messages to defunct processes (and thus hangs)
  //
  //   Driver::shutdown() can throw
  //   Driver::~Driver() can throw if shutdown throws; this will be immediately fatal
  //     to operate safely, guard with a Stopper (which itself throws in the destructor)
  //     or for complete safety use scheduler::operate<Driver>(...thunk...)
  //
  // Usage:
  //
  //   try {
  //     auto world = World{};
  //     auto stopper = Stop{world};
  //     ...operate upon world...
  //     if (optionally) {
  //       world.shutdown(); .................. else Stopper will do it for us
  //     }
  //   } catch (scheduler::exception::Aspect const &) {
  //     ...remind that ther's a bug in userland so shutdown() deadlocked...
  //   }
  //
  // Usage:
  //
  //   try {
  //     scheduler::operate<World>([](auto &world) {
  //       ...operate upon world...
  //       if (optionally) {
  //         world.shutdown(); .................. else Stopper will do it for us
  //       }
  //     });
  //   } catch (scheduler::exception::Aspect const &) {
  //     ...remind that ther's a bug in userland so shutdown() deadlocked...
  //   }
  //
  struct Driver;
}
#endiv
#divert <hpp>
#import tunitas.denniston.driver.Layout
namespace tunitas::denniston {
  namespace driver {
    using std::move;
  }
  class driver::Driver : public Layout {
    using Ancestor = Layout;
  public:
    [[idempotent]] inline auto shutdown() -> void;
    //
    explicit Driver(Size = DEFAULT_INITIAL_CLIENT_COUNT);
    ~Driver();
    Driver(Driver const &) = delete;
    Driver &operator=(Driver const &) = delete;
  protected:
    auto startup() -> void;
    auto enable_logging() -> void;
    bool has_been_shut_down{false};
    [[NOT_idempotent]] auto one_shot_shut_down() -> void;
  };
}
#endiv
#divert <ipp>
namespace tunitas::denniston::driver {
  auto Driver::shutdown() -> void {
    if (!has_been_shut_down) {
      one_shot_shut_down();
    }
  }
}
#endiv
#divert <cpp>
#import tunitas.denniston.service.Instance
#import tunitas.denniston.driver.Linker
#import std.clog
namespace tunitas::denniston::driver {
  Driver::Driver(Size initial_client_count) : Layout{initial_client_count} {
    logs.outbound = &std::clog; // else we won't see anything!
    enable_logging();
    auto link = Linker{*this};
    // in arbitrary order
    link.control();
    link.gateway();
    link.configuration();
    link.directory();
    // and finally
    startup();
  }
  Driver::~Driver() {
    // WATCHOUT - this can throw, which will be immediately fatal.
    // For safety, instead guard ~Driver()  with a Driver::Stopper
    shutdown();
  }
  auto Driver::enable_logging() -> void {
    // ALL processes of the System MUST be listed here (else you'll see no logsnothing)
    system.collector->log.concentrator = &logs;
    system.configuration->log.concentrator = &logs;
    system.directory->log.concentrator = &logs;
    system.gateway->log.concentrator = &logs;
    for (auto &processor : system.processors) { processor->log.concentrator = &logs; }
    for (auto &client : system.clients)       { client->log.concentrator = &logs; }
  }
  auto Driver::startup() -> void {
    system.configuration->launch(threads);
    system.directory->launch(threads);
    system.gateway->launch(threads);
    system.collector->launch(threads);
    for (auto &processor : system.processors) {
      processor->launch(threads);
    }
    for (auto &client : system.clients) {
      client->launch(threads);
    }
  }
}
#import tunitas.denniston.protocol.packet.make
#import tunitas.denniston.protocol.packet.Quit
#import tunitas.denniston.scheduler.backoff.Stepper
#import nonstd.runtime_assert
namespace tunitas::denniston::driver {
  auto Driver::one_shot_shut_down() -> void {
    runtime_assert(!has_been_shut_down);
    has_been_shut_down = true;
    using namespace protocol::packet;
    for (auto &face : control.everyone) {
      face.write(make<Quit>());
    }
    // ensure that they all have run to process that quit packet.
    for (auto step=scheduler::backoff::Stepper{}; step; ++step) {
      for (auto &face : control.everyone) {
        if (face.is_blocked_then_notify()) {
          step.needs_another_iteration();
        }
      }
    }
    // and after the Quit packets are processed, all the run(...) functions will have exited.
  }
}
namespace {
  namespace testate {
    using namespace tunitas::denniston::driver;
    static_assert(std::is_default_constructible_v<Driver>);
    static_assert(not std::is_copy_constructible_v<Driver>);
    static_assert(not std::is_move_constructible_v<Driver>);
    static_assert(not std::is_copy_assignable_v<Driver>);
    static_assert(not std::is_move_assignable_v<Driver>);
    static_assert(not std::is_swappable_v<Driver>);
  }
}
#endiv
