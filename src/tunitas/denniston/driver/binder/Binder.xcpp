// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc. 2022.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-denniston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/services/denniston/tree/LICENSE
#divert <fpp>
namespace tunitas::denniston::driver::binder {
  //
  // The binder, green & blue.
  //
  // Specification:
  //
  //   Just what it says.
  //   Special-case the chotrol channel.
  //
  // Design:
  //
  //   An interface detail of the Driver & the Linker
  //   Using the Best Available Means & Methods (UBAMM)
  //
  // WATCHOUT - the ordering of the arguments here is CRITICAL else activation scheduling WILL NOT WORK
  // The semantic is:
  //
  //   When writing to green interface, activate the blue process
  //   When writing to blue interface, activate the green process
  //
  // Usage:
  //
  //   See Driver
  //
  struct Binder;
}
#endiv
#divert <hpp>
#import tunitas.Tuple
#forward tunitas.denniston.driver.Layout
#import tunitas.denniston.driver.binder.Triple
#import tunitas.denniston.network.pipe.Pollability
#import tunitas.denniston.network.pipe.readable.Variable
#import tunitas.denniston.network.Socket.Interface
#import tunitas.denniston.network.Sockets
#import tunitas.denniston.process.Prototype
#import tunitas.denniston.process.Ready
#import tunitas.denniston.process.readable.Variable
#import tunitas.denniston.process.Model
class tunitas::denniston::driver::binder::Binder {
  using Process = process::Prototype;
  using Instance = process::Model;
  using Readable = network::pipe::readable::Variable;
  using Ready = process::Ready;
  using Socket = network::Socket;
  using Interface = network::Socket::Interface;
  using Descriptor = network::Sockets::Descriptor;
protected:
  inline auto do_control_channel(Triple) -> Interface;
  using Untied = Tuple<network::pipe::Pollability *, Interface>;
  inline auto left(Descriptor, Ready &) -> Untied;
  inline auto right(Descriptor, Ready &) -> Untied;
  struct Tied;
  inline auto tie(Readable &, Interface &) -> Tied;
public:  
  Layout &layout;
  explicit Binder(Layout &l) : layout{l} { }
  inline auto control_system([[inout]] Instance &) -> void;
  inline auto control_userland([[inout]] Instance &) -> void;
  inline auto link([[inout]] Triple green, [[inout]] Triple blue) -> void;
};
#endiv
#divert <ipp>
#import tunitas.denniston.driver.Layout
#import tunitas.denniston.driver.binder.Binder.Tied
namespace tunitas::denniston::driver::binder {
  auto Binder::control_userland(Instance &instance) -> void { layout.control.clients.push_back(do_control_channel({instance.control, instance})); }
  auto Binder::control_system(Instance &instance) -> void   { do_control_channel({instance.control, instance}); }
  //
  auto Binder::do_control_channel(Triple green) -> network::Socket::Interface {
    layout.control.everyone.push_back(network::Socket::Interface{});
    auto blue = Triple{layout.readable, layout.ready, layout.control.everyone.back()};
    link(green, blue);
    return blue.face;
  }
  auto Binder::link(Triple green, Triple blue) -> void {
    // when we write to blue, green must be notified that it is ready-to-ready
    // When we write to green, blue becomes ready
    auto noob = layout.sockets.allocate();
    tie(green.readable, green.face) = left(noob, blue.ready);
    tie(blue.readable, blue.face) = right(noob, green.ready);
  }
  auto Binder::left(Descriptor noob, Ready &ready) -> Untied {
    auto raw = noob.get();
    auto face = Interface{raw, &Socket::left2right, &Socket::right2left, &ready};
    auto poll = &raw->right2left;
    return {poll, face};
  }
  auto Binder::right(Descriptor noob, Ready &ready) -> Untied {
    auto raw = noob.get();
    auto face = Interface{raw, &Socket::right2left, &Socket::left2right, &ready};
    auto poll = &raw->left2right;
    return {poll, face};
  }
  auto Binder::tie(Readable &readable, Interface &face) -> Tied { return {readable, face}; }
}
#endiv
