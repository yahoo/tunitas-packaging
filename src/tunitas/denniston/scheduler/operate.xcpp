// This is -*- c++ -*- nearly C++2a with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-denniston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/services/denniston/tree/LICENSE
#divert <fpp>
namespace tunitas::denniston::scheduler {
  namespace package_operate {
    namespace body::exported { }
    namespace interface = body::exported;
  }
  using namespace package_operate::interface;
}
#import tunitas.denniston.scheduler.required.World
namespace tunitas::denniston::scheduler::package_operate {
  namespace body {
    template<required::World WORLD> struct Operator;
  }
}
#endiv
#divert <hpp>
#import tunitas.denniston.scheduler.required.World
#import tunitas.denniston.scheduler.required.Invocable
#import tunitas.denniston.scheduler.traits.Stopper
namespace tunitas::denniston::scheduler::package_operate {
  namespace body::exported {
    //
    // Operate a world ("a driver")
    //
    // Specification:
    //
    //   The complete life cycle: construction, operation, graceful shutdown.
    //   handle shutdown, which hmay throw if deadlock is detected
    //
    // Design:
    //
    //   Yes.  Why yes! Yes, YES!  There is a design here.  And by "design" we mean Deaign with a capital-D and hushed-voice-eyes-raised-to-the-heavens look.
    //   Because the Stopper can throw in its desstructor, we run the stopper in a constructor.
    //   If the constructor fails then you get the exception.
    //
    // Expectations:
    //
    //   The complete type of the Stopper is known. (you may need some extra specializations and the relevant #import)
    //
    // Usage:
    //
    //   using World = ...somehow...
    //
    //   try {
    //     operate<World>([](auto &world) {
    //       ...operate upon the world...
    //     });
    //   } catch (scheduler::exception::Aspect const &) {
    //     ...remind that a scheduler exception was thrown; e.g. Deadlock on shutdown
    //   }
    //
    //   try {
    //     operate(World{...arguments...}, [](auto &world) {
    //       ...operate upon the world...
    //     });
    //   } catch (scheduler::exception::Aspect const &) {
    //     ...remind that a scheduler exception was thrown; e.g. Deadlock on shutdown
    //   }
    //
    template<required::World WORLD, required::Invocable<WORLD &> OPERATE> auto operate(OPERATE) -> void;
    template<required::World WORLD, required::Invocable<WORLD &> OPERATE> auto operate(WORLD &&, OPERATE) -> void;
  }
  template<required::World WORLD> struct body::Operator {
    using World = WORLD;
    using Stopper = typename traits::Stopper<World>::Type;
    template<typename OPERATE> explicit Operator(World &&, OPERATE &&);
    template<typename OPERATE> explicit Operator(OPERATE &&);
  };
}
#endiv
#divert <ipp>
namespace tunitas::denniston::scheduler::package_operate {
  template<required::World _> template<typename OPERATE> body::Operator<_>::Operator(OPERATE &&operate) {
    auto world = World{};
    auto stop = Stopper{world}; // can throw in its destructor
    operate(world);
  }
  template<required::World _> template<typename OPERATE> body::Operator<_>::Operator(World &&world, OPERATE &&operate) {
    auto stop = Stopper{world}; // can throw in its destructor
    operate(world);
  }
  template<scheduler::required::World WORLD, scheduler::required::Invocable<WORLD &> OPERATE> auto interface::operate(OPERATE operate) -> void { Operator<WORLD>{forward<OPERATE>(operate)};}
  template<required::World WORLD, required::Invocable<WORLD &> OPERATE> auto interface::operate(WORLD &&world, OPERATE operate)        -> void { Operator<WORLD>{forward<WORLD>(world), forward<OPERATE>(operate)}; }
}
#endiv
