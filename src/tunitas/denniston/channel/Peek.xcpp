// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc. 2022.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-denniston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/services/denniston/tree/LICENSE
#divert <fpp>
#import tunitas.denniston.channel.required.Channelable
namespace tunitas::denniston::channel {
  //
  // The result of a peek operation on a channel
  //
  // Specification:
  //
  //   An "optional reference" (whatever that means)
  //   Rhymes with std::optional<...> where it can.
  //   Retains exclusive access to the channel
  //
  // Design:
  //
  //   Peek<RESULT> is NOT defined in terms of required::Peekable<RESULT>; instead that definitional order is inverted.
  //   Because required::Peekable<RESULT> diagnoses to whether the RESULT can be used in Channel<TYPE,VARIABILITY>::peek<RESULT>() -> Peek<RESULT>
  //
  //   As with the Optional<RESULT>::operator* there is no checking here.
  //   Though peeking, it returns a reference ot the internals of the channel.
  //   The Peek<REUSLT> transfer ownership of the exclusive lock on teh channel.
  //
  // Usage:
  //
  //   Use it as you would std::optional<RESULT const &> (if that were even a thing) 
  //
  template<required::Channelable RESULT> struct Peek;
}
#endiv
#divert <hpp>
#import tunitas.Optional
#import tunitas.Pair
#import nonstd.required.Pointer
#import std.same_as
#forward tunitas.denniston.channel.Channel
#import tunitas.denniston.channel.Variables.Guard.Exclusive
#import tunitas.denniston.channel.required // ctcnr (cascade that certain 'namespace required')
namespace tunitas::denniston {
  template<channel::required::Channelable RESULT> class channel::Peek : private Optional<tunitas::Pair<Variables::Guard::Exclusive, RESULT const *>> {
    using Ancestor = Optional<tunitas::Pair<Variables::Guard::Exclusive, RESULT const *>>;
    using Pair = tunitas::Pair<Variables::Guard::Exclusive, RESULT const *>;
  public:
    using Value [[school("New")]] = RESULT;
    using value_type [[school("Old")]] = Value;
    static_assert(not std::same_as<Value, typename Ancestor::value_type::second_type>, "reminder");
    static_assert(required::Pointer<typename Ancestor::value_type::second_type>, "reminder");
    using Ancestor::operator bool;
    using Ancestor::has_value;
    inline auto operator*() const -> Value const &; // just as dangerous as the ancestor's
    inline auto value() const -> Value const &;
    inline auto reset() -> void;
  protected:
    template<required::Channelable, required::Variability> friend class Channel;
    using Guard = Variables::Guard::Exclusive;
    inline [[implicit]] Peek() = default;
    inline [[implicit]] Peek(Guard &&, Value const &);
  };
}
#endiv
#divert <ipp>
#import tunitas.denniston.exception.Optional
namespace tunitas::denniston::channel {
  template<required::Channelable _> Peek<_>::Peek(Guard &&guard, Value const &value) : Ancestor{Pair{move(guard), &value}}  { }
  template<required::Channelable _> auto Peek<_>::operator*() const -> Value const & {
    Ancestor const &self{*this};
    return *self->second;
  }
  template<required::Channelable _> auto Peek<_>::value() const -> Value const & try {
    return *Ancestor::value();
  } catch (substd::exception::Optional const &) {
    throw exception::Optional{};
  }
  template<required::Channelable _> auto Peek<_>::reset() -> void {
    auto &self{*this};
    if (self) {
      self->first.release();
      Ancestor::reset();
    }
  }
}
#endiv
