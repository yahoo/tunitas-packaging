// This is -*- c++ -*- nearly C++2a with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <hpp>
#import tunitas.octets.required.view.Fixed
#import tunitas.octets.required.view.Variable
#import tunitas.exception.Length
#import tunitas.Tuple
#import nonstd.required.Exception
namespace tunitas::octets {
  //
  // slice off some
  //
  // Specification:
  //
  //   Slice off the fixed part
  //   Return the remaining part
  //   Throw that exception if that can't be done.
  //
  // Design:
  //
  //   Only views (constie) is supported; slice_off(...) cannot be used to cut up mutable octet strings.
  //   Because that's all we need it for.
  //
  //   Using the Best Available Means & Methods (UBAMM)
  //
  //   The default exception is a Length which is a logic problem (the caller coulda-shoulda checked)
  //   In other scenarios the problem constitutes a runtime error because the idiom is used to detect short input supplied off-the-wire.
  //
  // Usage:
  //
  //   auto original = octets::Variable{...somehow...};
  //   auto [got1, remaining1] = slice_off<octets::Fixed<33>>(original);
  //   auto [got2, remaining2] = slice_off<octets::Fixed<33>>(remaining1);
  //
  template<required::view::Fixed FIXED, required::Exception = exception::Length, required::view::Variable VARIABLE> inline auto slice_off(VARIABLE) -> Tuple<FIXED, VARIABLE>;
}
#endiv
#divert <ipp>
namespace tunitas {
  template<octets::required::view::Fixed FIXED, required::Exception EXCEPTION, octets::required::view::Variable VARIABLE> auto octets::slice_off(VARIABLE source) -> Tuple<FIXED, VARIABLE> {
    if (auto const size=source.size(); FIXED::extent > size) {
      if constexpr (requires { EXCEPTION{}; }) {
        throw EXCEPTION{};
      } else {
        throw EXCEPTION{"the slice is too long (the source is too short)"};
      }
    } else {
      auto const base = source.data();
      auto const first = FIXED{base, FIXED::extent};
      auto const rest = VARIABLE{base + FIXED::extent, source.size() - FIXED::extent};
      return {first, rest};
    }
  }
}
#endiv
