// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
namespace tests::unit::field::get {
  template<typename SUBJECT> struct Extract;
}
#endiv
#divert <hpp>
#import tunitas.keyston.exception.Aspect
#import tunitas.keyston.field.get.Extract
#import tests.unit.field.get.Palette
#import nonstd.uint128_t
namespace tests::unit::field {
  template<typename SUBJECT> struct get::Extract : public rigging::suite::Fixture, protected Palette {
    static auto suite() -> Suite;
    //
    using Subject = SUBJECT;
    //
    using Small = typename Subject::Value;
    static_assert(0 == Palette::Limits<Small>::min());
    //
    auto test_min() -> void;
    auto test_min_plus_1() -> void;
    auto test_max_minus_1() -> void;
    auto test_max() -> void;
    auto test_negative() -> void;
    auto test_too_big() -> void;
  protected:
    using Failure = ::tunitas::keyston::exception::Aspect;
    auto exercise(typename Subject::Value specimen) -> void;
  };
  namespace get {
    template<> inline auto Extract<library::Extract<nonstd::uint128_t>>::test_too_big() -> void { /* can't fail */ }
  }
}
#endiv
#divert <tpp>
#import tunitas.number.mp.convert
namespace tests::unit::field::get {
  template<typename _> auto Extract<_>::suite() -> Suite {
    auto series = Stream{typeid(Subject)};
    series << add("min", &Extract::test_min)
           << add("min+1", &Extract::test_min_plus_1)
           << add("max-1", &Extract::test_max_minus_1)
           << add("max", &Extract::test_max)
           << add("negative", &Extract::test_negative)
           << add("too-big", &Extract::test_too_big)
           << END;
    return settle(series);
  }
  template<typename _> auto Extract<_>::exercise(typename Subject::Value specimen) -> void {
    auto candidate = typename Palette::Candidate{::tunitas::number::mp::convert<mpz_class>(specimen)};
    auto got = Subject::get(candidate.impl);
    require(ASSERTION, specimen == got);
  }
  template<typename _> auto Extract<_>::test_min() -> void         { exercise(Limits<Small>::min()); }
  template<typename _> auto Extract<_>::test_min_plus_1() -> void  { exercise(Limits<Small>::min() + 1); }
  template<typename _> auto Extract<_>::test_max_minus_1() -> void { exercise(Limits<Small>::max() - 1); }
  template<typename _> auto Extract<_>::test_max() -> void         { exercise(Limits<Small>::max()); }
  template<typename _> auto Extract<_>::test_negative() -> void try {
    auto candidate = typename Palette::Candidate{-1};
    Subject::get(candidate.impl);
    impossible(ASSERTION);
  } catch (Failure const &) {
    require(ASSERTION);
  }
  template<typename _> auto Extract<_>::test_too_big() -> void try {
    auto const yikes = nonstd::int128_t{Palette::Limits<Small>::max()} + 2;
    auto candidate = typename Palette::Candidate{yikes};
    Subject::get(candidate.impl);
    impossible(ASSERTION);
  } catch (Failure const &) {
    require(ASSERTION);
  }
}
#endiv
