// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
#import tunitas.keyston.field.required.Element
namespace tests::unit::field::element {
  template<typename SUBJECT> requires required::Element<SUBJECT> struct Element;
}
#endiv
#divert <hpp>
namespace tests::unit::field {
  template<typename SUBJECT> requires field::required::Element<SUBJECT> struct element::Element : public rigging::suite::Fixture {
    static auto suite() -> Suite;
    //
    using Subject = SUBJECT;
    //
    auto test_operator_pos() -> void;
    auto test_operator_neg() -> void;
    //
    auto test_operator_add() -> void;
    auto test_operator_sub() -> void;
    auto test_operator_mul() -> void;
    auto test_operator_pow() -> void;
    //
    auto test_operator_eq() -> void;
    auto test_operator_ne() -> void;
    //
    auto test_identity0() -> void;
    auto test_identity1() -> void;
    auto test_identity2() -> void;
    auto test_identity3() -> void;
  protected:
    struct Expected;
    static auto generate(unsigned specimen) -> Subject;
  };
}
#endiv
#divert <tpp>
#import tests.unit.field.element.Element.SUBJECT.Expected
#import std.derived_from
namespace tests::unit::field::element {
  template<typename _> auto Element<_>::suite() -> Suite {
    auto series = Stream{typeid(Subject)};
    series << []{
               auto un = Stream{"unary"sv};
               un << add("operator+", &Element::test_operator_pos)
                  << add("operator-", &Element::test_operator_neg)
                  << END;
               return un;
             }()
           << []{
               auto bi = Stream{"binary"sv};
               bi << add("operator+", &Element::test_operator_add)
                  << add("operator-", &Element::test_operator_sub)
                  << add("operator*", &Element::test_operator_mul)
                  << add("pow", &Element::test_operator_pow)
                  << END;
               return bi;
             }()
           << []{
               auto cmp = Stream{"compare"sv};
               cmp << add("operator==", &Element::test_operator_eq)
                   << add("operator!=", &Element::test_operator_ne)
                   << END;
               return cmp;
             }()
           << []{
               auto id = Stream{"identity"sv};
               id << add("0", &Element::test_identity0)
                  << add("1", &Element::test_identity1)
                  << add("2", &Element::test_identity2)
                  << add("3", &Element::test_identity3)
                  << END;
               return id;
             }()
           << END;
    return settle(series);
  }
  template<typename _> auto Element<_>::generate(unsigned specimen) -> Subject {
    // nowadays, this is trivial
    return Subject{specimen};
  }
  template<typename _> auto Element<_>::test_operator_pos() -> void {
    auto original = 3u;
    auto subject = generate(original);
    auto observed = +subject; // <-------------------- test this
    require(ASSERTION, Expected::pos() == underlying(observed));
  }
  template<typename _> auto Element<_>::test_operator_neg() -> void {
    auto original = 3u;
    auto subject = generate(original);
    auto observed = -subject; // <-------------------- test this
    require(ASSERTION, Expected::neg() == underlying(observed));
  }
  template<typename _> auto Element<_>::test_operator_add() -> void {
    auto a = generate(3);
    auto b = generate(5);
    auto observed = a + b; // <-------------------- test this
    require(ASSERTION, Expected::add() == underlying(observed));
  }
  template<typename _> auto Element<_>::test_operator_sub() -> void {
    auto a = generate(3);
    auto b = generate(5);
    auto observed = a - b; // <-------------------- test this
    require(ASSERTION, Expected::sub() == underlying(observed));
  }
  template<typename _> auto Element<_>::test_operator_mul() -> void {
    auto a = generate(3);
    auto b = generate(5);
    auto observed = a * b; // <-------------------- test this
    require(ASSERTION, Expected::mul() == underlying(observed));
  }
  template<typename _> auto Element<_>::test_operator_pow() -> void {
    auto a = generate(3);
    auto b = 5lu;
    auto observed = pow(a, b); // <-------------------- test this
    require(ASSERTION, Expected::pow() == underlying(observed));
  }
  template<typename _> auto Element<_>::test_operator_eq() -> void {
    { auto a = generate(3);
      auto b = generate(5);
      auto observed = a == b;
      require(ASSERTION, false == observed); }
    { auto a = generate(3);
      auto b = generate(3);
      auto observed = a == b;
      require(ASSERTION, true == observed); }
  }
  template<typename _> auto Element<_>::test_operator_ne() -> void {
    { auto a = generate(3);
      auto b = generate(5);
      auto observed = a != b;
      require(ASSERTION, true == observed); }
    { auto a = generate(3);
      auto b = generate(3);
      auto observed = a != b;
      require(ASSERTION, false == observed); }
  }
  template<typename _> auto Element<_>::test_identity0() -> void {
    auto a = generate(3);
    auto zero = generate(0);
    auto const expected = a;
    auto const observed = a + zero;
    require(ASSERTION, expected == observed);
  }
  template<typename _> auto Element<_>::test_identity1() -> void {
    auto a = generate(3);
    auto zero = generate(0);
    auto const expected = zero;
    auto const observed = a - a;
    require(ASSERTION, expected == observed);
  }
  template<typename _> auto Element<_>::test_identity2() -> void {
    auto a = generate(3);
    auto b = generate(5);
    auto zero = generate(0);
    auto const expected = zero;
    auto const observed = (a - b) - a + b;
    require(ASSERTION, expected == observed);
  }
  template<typename _> auto Element<_>::test_identity3() -> void {
    auto a = generate(3);
    auto left = generate(0);
    auto right = generate(0);
    auto const expected = a;
    auto const observed = a + Subject{} - left + right;
    require(ASSERTION, expected == observed);
  }
}
#endiv
