// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
namespace tests::unit::field { struct Fixture; }
#endiv
#divert <hpp>
struct tests::unit::field::Fixture : public rigging::suite::Fixture {
  static auto suite() -> Suite;
  //
  template<typename FIELD> auto test_usage_Generator() -> void;
  template<typename BASE, typename EXPONENT> auto test_usage_powm() -> void;
};
#endiv
#divert <tpp>
#import tunitas.keyston.field.Field
#import tunitas.keyston.field.powm
#import nonstd.int128.ostream
namespace tests::unit::field {
  //
  // Source: the self-asserted computation herein
  //
  // Field<64>  1753635133440165772
  // Field<128> 145091266659756586618791329697897684742
  //
  template<typename FIELD> auto Fixture::test_usage_Generator() -> void {
    using Field = FIELD;
    auto g0 = Field::gen();
    using Generator = typename Field::Generator;
    auto generator = Generator{};
    auto g1 = generator();
    auto g2 = generator();
    auto g3 = generator();
    require(ASSERTION, g0 == g1);
    require(ASSERTION, g1 == g2);
    require(ASSERTION, g2 == g3);
    require(ASSERTION, g3 == g0);
    using nonstd::int128::operator<<;
    std::cerr << g0 << '\n';
  }
  template<typename BASE, typename EXPONENT> auto Fixture::test_usage_powm() -> void {
    using Base = BASE;
    using Exponent = EXPONENT;
    using Modulus = Base;
    auto base = Base{4};
    auto exponent = Exponent{13};
    auto modulus = Modulus{497};
    auto observed = library::powm(base, exponent, modulus);
    auto expected = Base{445};
    require(ASSERTION, expected == observed);
  }
}
#endiv
#divert <cpp>
//
// Specializations must be presented before suite() so that it can see them when it takes their address
//
#import tests.unit.field.get.Fixture
#import tunitas.number.Integer
#import nonstd.uint128_t
#import std.uint32_t
#import std.uint64_t
auto tests::unit::field::Fixture::suite() -> Suite {
  auto series = Stream{"field"sv};
  series << []{
             auto use = Stream{"usage"sv};
             use << []{
                      auto gen = Stream{"Generator"sv};
                      gen << add("Field<64>", &Fixture::test_usage_Generator<library::Field<64>>)
                          << add("Field<128>", &Fixture::test_usage_Generator<library::Field<128>>)
                          << END;
                      return gen;
                    }()
                 << []{
                   using std::uint64_t;
                   using nonstd::uint128_t;
                   using ::tunitas::number::Integer;
                      auto pow = Stream{"powm"sv};
                      pow << add("uint32,uint32", &Fixture::test_usage_powm<uint32_t,uint32_t>)
                          << add("uint64,uint64", &Fixture::test_usage_powm<uint64_t, uint64_t>)
                          << add("uint128,uint128", &Fixture::test_usage_powm<uint128_t,uint128_t>)
                          << add("Integer,uint164", &Fixture::test_usage_powm<Integer,uint64_t>)
                          << add("Integer,uint128", &Fixture::test_usage_powm<Integer,uint128_t>)
                          << END;
                      return pow;
                    }()
                 << END;
             return use;
           }()
         << add<get::Fixture>()
         << END;
  return settle(series);
}
#endiv
