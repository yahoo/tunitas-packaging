// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
namespace tests::unit::field { struct Fixture; }
#endiv
#divert <hpp>
struct tests::unit::field::Fixture : public rigging::suite::Fixture {
  static auto suite() -> Suite;
  //
  template<typename FIELD> auto test_usage_Generator() -> void;
  template<typename VECTOR> auto test_usage_Vector() -> void;
  template<typename VECTOR> auto test_usage_Polynomial() -> void;
protected:
  inline static constexpr auto const DIMENSIONS = 3uz; // keep this reasonably small (this is a test rig)
  inline static constexpr auto const DEGREE = 5uz;
};
#endiv
#divert <tpp>
#import tunitas.keyston.field.element
#import tunitas.keyston.field.element.traits.Element
#import tunitas.keyston.field.Definition
#import tunitas.keyston.Field
#import tunitas.keyston.field.Polynomial
#import tunitas.keyston.field.Vector
#import tunitas.keyston.field.Definition
#import tunitas.keyston.field.vector.Definition
#import tunitas.keyston.field.polynomial.Definition
#import nonstd.int128.ostream
#import std.fill
namespace tests::unit::field {
  //
  // Source: the self-asserted computation herein
  //
  // Field<64>  1753635133440165772
  // Field<128> 145091266659756586618791329697897684742
  //
  template<typename FIELD> auto Fixture::test_usage_Generator() -> void {
    using Field = FIELD;
    auto g0 = Field::generator();
    using Generator = typename Field::Generator;
    auto generator = Generator{};
    auto g1 = generator();
    auto g2 = generator();
    auto g3 = generator();
#if 1
    require(ASSERTION, sizeof(g0));
    require(ASSERTION, sizeof(g1));
    require(ASSERTION, sizeof(g2));
    require(ASSERTION, sizeof(g3));
#else
    require(ASSERTION, g0 == g1);
    require(ASSERTION, g1 == g2);
    require(ASSERTION, g2 == g3);
    require(ASSERTION, g3 == g0);
    using nonstd::int128::operator<<;
    std::cerr << g0 << '\n';
#endif
  }
  template<typename VECTOR> auto Fixture::test_usage_Vector() -> void {
    using Subject = VECTOR;
    auto generate = [](int unsigned raw_initial) -> Subject {
      auto initial = typename Subject::Value{raw_initial};
      auto ret = Subject{};
      std::fill_n(ret.begin(), ret.size(), initial);
      return ret;
    };
    auto const one = generate(1);
    auto const two = generate(2);
    auto const three = generate(3);
#if 1
    require(ASSERTION, sizeof(one));
    require(ASSERTION, sizeof(two));
    require(ASSERTION, sizeof(three));
#else
    using Scalar = typename Subject::Value;
    require(ASSERTION, three == one + two);
    require(ASSERTION, two == three - one);
    require(ASSERTION, three == Scalar{3} * one);
    require(ASSERTION, one == three / Scalar{3});
    require(ASSERTION, one == three % Scalar{2});
#endif
  }
  template<typename POLYNOMIAL> auto Fixture::test_usage_Polynomial() -> void {
    using Subject = POLYNOMIAL;
    auto generate = [](int unsigned raw_initial) -> Subject {
      auto initial = typename Subject::Value{raw_initial};
      auto ret = Subject{};
      std::fill_n(ret.begin(), ret.size(), initial);
      return ret;
    };
    auto const one = generate(1);
    auto const two = generate(2);
    auto const three = generate(3);
    require(ASSERTION, sizeof(one));
    require(ASSERTION, sizeof(two));
    require(ASSERTION, sizeof(three));
  }
}
#endiv
#divert <cpp>
//
// Specializations must be presented before suite() so that it can see them when it takes their address
//
#import tunitas.keyston.field.Definition
#import tunitas.keyston.field.vector.Definition
#import tunitas.keyston.field.polynomial..Definition
#import tests.unit.field.Field
#import tests.unit.field.element.Fixture
#import tests.unit.field.Vector
#import tests.unit.field.vector.Vector
#import tests.unit.field.Polynomial
#import tests.unit.field.polynomial.Polynomial
auto tests::unit::field::Fixture::suite() -> Suite {
  auto series = Stream{"field"sv};
  series << []{
             auto use = Stream{"usage"sv};
             use << []{
                      auto gen = Stream{"Generator"sv};
                      gen << add("Field<64>", &Fixture::test_usage_Generator<library::Definition<64>>)
                          << add("Field<128>", &Fixture::test_usage_Generator<library::Definition<128>>)
                          << END;
                      return gen;
                    }()
                << []{
                    auto poly = Stream{"Polynomial"sv};
                    poly << add("Field<64>::Polynomial<DEGREE>", &Fixture::test_usage_Polynomial<library::polynomial::Definition<library::Definition<64>, DEGREE>::Value>)
                         << add("Field<128>::Polynomial<DEGREE>", &Fixture::test_usage_Polynomial<library::polynomial::Definition<library::Definition<128>, DEGREE>::Value>)
                         << add("Field<255>::Polynomial<DEGREE>", &Fixture::test_usage_Polynomial<library::polynomial::Definition<library::Definition<255>, DEGREE>::Value>)
                        << END;
                    return poly;
                }()
                << []{
                    auto vec = Stream{"Vector"sv};
                    vec << add("Field<64>::Vector", &Fixture::test_usage_Vector<library::vector::Definition<library::Definition<64>, DIMENSIONS>::Value>)
                        << add("Field<128>::Vector", &Fixture::test_usage_Vector<library::vector::Definition<library::Definition<128>, DIMENSIONS>::Value>)
                        << add("Field<255>::Vector", &Fixture::test_usage_Vector<library::vector::Definition<library::Definition<255>, DIMENSIONS>::Value>)
                        << END;
                    return vec;
                }()
                 << END;
             return use;
          }()
         << []{
             auto obj = Stream{"object"sv};
             obj << add<element::Fixture>()
                 << []{
                     auto poly = Stream{"polynomial"sv};
                     poly << add<polynomial::Polynomial<library::polynomial::Definition<library::Definition<64>, DEGREE>::Value>>()
                          << add<polynomial::Polynomial<library::polynomial::Definition<library::Definition<128>, DEGREE>::Value>>()
                          << add<polynomial::Polynomial<library::polynomial::Definition<library::Definition<255>, DEGREE>::Value>>()
                          << END;
                     return poly;
                   }()
                 << []{
                     auto vec = Stream{"vector"sv};
                     vec << add<vector::Vector<library::vector::Definition<library::Definition<64>, DIMENSIONS>::Value>>()
                         << add<vector::Vector<library::vector::Definition<library::Definition<128>, DIMENSIONS>::Value>>()
                         << add<vector::Vector<library::vector::Definition<library::Definition<255>, DIMENSIONS>::Value>>()
                         << END;
                     return vec;
                   }()
                 << END;
             return obj;
         }()
         << []{
             auto def = Stream{"definition"sv};
             def << []{
                      auto fie = Stream{"Field"sv};
                      fie << add<Field<library::Definition<64>>>()
                           << add<Field<library::Definition<128>>>()
                           << add<Field<library::Definition<255>>>()
                           << END;
                      return fie;
                    }()
                 << []{
                      auto pol = Stream{"Polynomial"sv};
                      pol << add<Polynomial<typename library::Definition<64>::template Polynomial<4>>>()
                          << add<Polynomial<typename library::Definition<128>::template Polynomial<4>>>()
                          << add<Polynomial<typename library::Definition<255>::template Polynomial<4>>>()
                          << END;
                      return pol;
                    }()
                 << []{
                      auto vec = Stream{"Vector"sv};
                      vec << add<Vector<typename library::Definition<64>::template Vector<4>>>()
                          << add<Vector<typename library::Definition<128>::template Vector<4>>>()
                          << add<Vector<typename library::Definition<255>::template Vector<4>>>()
                          << END;
                      return vec;
                    }()
                 << END;
             return def;
         }()
         << END;
  return settle(series);
}
#endiv
