// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
namespace tests::unit::field { struct Fixture; }
#endiv
#divert <hpp>
#import tunitas.number.Integer
#import nonstd.uint128_t
#import std.uint32_t
#import std.uint64_t
struct tests::unit::field::Fixture : public rigging::suite::Fixture {
  static auto suite() -> Suite;
  //
  template<typename FIELD> auto test_usage_Generator() -> void;
  template<typename VECTOR> auto test_usage_Vector() -> void;
protected:
  using uint32_t = std::uint32_t;
  using uint64_t = std::uint64_t;
  using uint128_t = nonstd::uint128_t;
  using Integer = ::tunitas::number::Integer;
  inline static constexpr auto const DIMENSIONS = 3uz; // keep this reasonably small (this is a test rig)
};
#endiv
#divert <tpp>
#import tunitas.keyston.field.Field
#import tunitas.keyston.field.Vector
#import nonstd.int128.ostream
#import std.fill
namespace tests::unit::field {
  //
  // Source: the self-asserted computation herein
  //
  // Field<64>  1753635133440165772
  // Field<128> 145091266659756586618791329697897684742
  //
  template<typename FIELD> auto Fixture::test_usage_Generator() -> void {
    using Field = FIELD;
    auto g0 = Field::gen();
    using Generator = typename Field::Generator;
    auto generator = Generator{};
    auto g1 = generator();
    auto g2 = generator();
    auto g3 = generator();
#if 1
    require(ASSERTION, sizeof(g0));
    require(ASSERTION, sizeof(g1));
    require(ASSERTION, sizeof(g2));
    require(ASSERTION, sizeof(g3));
#else
    require(ASSERTION, g0 == g1);
    require(ASSERTION, g1 == g2);
    require(ASSERTION, g2 == g3);
    require(ASSERTION, g3 == g0);
    using nonstd::int128::operator<<;
    std::cerr << g0 << '\n';
#endif
  }
  template<typename VECTOR> auto Fixture::test_usage_Vector() -> void {
    using Subject = VECTOR;
    auto generate = [](int unsigned raw_initial) -> Subject {
      auto initial = typename Subject::Value{raw_initial};
      auto ret = Subject{};
      std::fill_n(ret.begin(), ret.size(), initial);
      return ret;
    };
    auto const one = generate(1);
    auto const two = generate(2);
    auto const three = generate(3);
#if 1
    require(ASSERTION, sizeof(one));
    require(ASSERTION, sizeof(two));
    require(ASSERTION, sizeof(three));
#else
    using Scalar = typename Subject::Value;
    require(ASSERTION, three == one + two);
    require(ASSERTION, two == three - one);
    require(ASSERTION, three == Scalar{3} * one);
    require(ASSERTION, one == three / Scalar{3});
    require(ASSERTION, one == three % Scalar{2});
#endif
  }
}
#endiv
#divert <cpp>
//
// Specializations must be presented before suite() so that it can see them when it takes their address
//
#import tests.unit.field.Element
#import tests.unit.field.Vector
auto tests::unit::field::Fixture::suite() -> Suite {
  auto series = Stream{"field"sv};
  series << []{
             auto use = Stream{"usage"sv};
             use << []{
                      auto gen = Stream{"Generator"sv};
                      gen << add("Field<64>", &Fixture::test_usage_Generator<library::Field<64>>)
                          << add("Field<128>", &Fixture::test_usage_Generator<library::Field<128>>)
                          << END;
                      return gen;
                    }()
                 << END;
             return use;
           }()
         << []{
             auto vec = Stream{"Field"sv};
             vec << add("Field<64>", &Fixture::test_usage_Vector<library::Vector<library::Field<64>::Value, DIMENSIONS>>)
                 << add("Field<128>", &Fixture::test_usage_Vector<library::Vector<library::Field<128>::Value, DIMENSIONS>>)
                 << END;
             return vec;
         }()
         << []{
             auto ele = Stream{"Element"sv};
             ele << add<Element<library::Field<64>::Element>>()
                 << add<Element<library::Field<128>::Element>>()
                 << add<Element<library::Field<255>::Element>>()
                 << END;
             return ele;
           }()
         << []{
             auto vec = Stream{"Vector"sv};
             vec << add<Vector<library::Vector<library::Field<64>::Element, DIMENSIONS>>>()
                 << add<Vector<library::Vector<library::Field<128>::Element, DIMENSIONS>>>()
                 << add<Vector<library::Vector<library::Field<255>::Element, DIMENSIONS>>>()
                 << END;
             return vec;
           }()
         << END;
  return settle(series);
}
#endiv
