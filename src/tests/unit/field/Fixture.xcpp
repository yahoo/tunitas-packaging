// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
namespace tests::unit::field { struct Fixture; }
#endiv
#divert <hpp>
#import tunitas.number.Integer
#import nonstd.uint128_t
#import std.uint32_t
#import std.uint64_t
struct tests::unit::field::Fixture : public rigging::suite::Fixture {
  static auto suite() -> Suite;
  //
  template<typename FIELD> auto test_usage_Generator() -> void;
  template<typename BASE, typename EXPONENT> auto test_usage_powm() -> void;
  template<typename VECTOR> auto test_usage_Vector() -> void;
protected:
  using uint32_t = std::uint32_t;
  using uint64_t = std::uint64_t;
  using uint128_t = nonstd::uint128_t;
  using Integer = ::tunitas::number::Integer;
  inline static constexpr auto const DIMENSIONS = 3uz; // keep this reasonably small (this is a test rig)
};
#endiv
#divert <tpp>
#import tunitas.keyston.field.Field
#import tunitas.keyston.field.Vector
#import tunitas.keyston.field.powm
#import nonstd.int128.ostream
#import std.fill
namespace tests::unit::field {
  //
  // Source: the self-asserted computation herein
  //
  // Field<64>  1753635133440165772
  // Field<128> 145091266659756586618791329697897684742
  //
  template<typename FIELD> auto Fixture::test_usage_Generator() -> void {
    using Field = FIELD;
    auto g0 = Field::gen();
    using Generator = typename Field::Generator;
    auto generator = Generator{};
    auto g1 = generator();
    auto g2 = generator();
    auto g3 = generator();
    require(ASSERTION, g0 == g1);
    require(ASSERTION, g1 == g2);
    require(ASSERTION, g2 == g3);
    require(ASSERTION, g3 == g0);
    using nonstd::int128::operator<<;
    std::cerr << g0 << '\n';
  }
  template<typename BASE, typename EXPONENT> auto Fixture::test_usage_powm() -> void {
    using Base = BASE;
    using Exponent = EXPONENT;
    using Modulus = Base;
    auto base = Base{4};
    auto exponent = Exponent{13};
    auto modulus = Modulus{497};
    auto observed = library::powm(base, exponent, modulus);
    auto expected = Base{445};
    require(ASSERTION, expected == observed);
  }
  template<typename VECTOR> auto Fixture::test_usage_Vector() -> void {
    using Subject = VECTOR;
    using Scalar = typename Subject::Value;
    auto generate = [](Subject::Value initial) -> Subject {
      auto ret = Subject{};
      std::fill_n(ret.begin(), ret.size(), initial);
      return ret;
    };
    auto const one = generate(1);
    auto const two = generate(2);
    auto const three = generate(3);
    require(ASSERTION, three == one + two);
    require(ASSERTION, two == three - one);
    require(ASSERTION, three == Scalar{3} * one);
    require(ASSERTION, one == three / Scalar{3});
    require(ASSERTION, one == three % Scalar{2});
  }
}
#endiv
#divert <cpp>
//
// Specializations must be presented before suite() so that it can see them when it takes their address
//
#import tests.unit.field.get.Fixture
#import tests.unit.field.Vector
auto tests::unit::field::Fixture::suite() -> Suite {
  auto series = Stream{"field"sv};
  series << []{
             auto use = Stream{"usage"sv};
             use << []{
                      auto gen = Stream{"Generator"sv};
                      gen << add("Field<64>", &Fixture::test_usage_Generator<library::Field<64>>)
                          << add("Field<128>", &Fixture::test_usage_Generator<library::Field<128>>)
                          << END;
                      return gen;
                    }()
                 << []{
                      auto pow = Stream{"powm"sv};
                      pow << add("uint32,uint32", &Fixture::test_usage_powm<uint32_t,uint32_t>)
                          << add("uint64,uint64", &Fixture::test_usage_powm<uint64_t, uint64_t>)
                          << add("uint128,uint128", &Fixture::test_usage_powm<uint128_t,uint128_t>)
                          << add("Integer,uint164", &Fixture::test_usage_powm<Integer,uint64_t>)
                          << add("Integer,uint128", &Fixture::test_usage_powm<Integer,uint128_t>)
                          << END;
                      return pow;
                    }()
                 << END;
             return use;
           }()
         << []{
             auto vec = Stream{"Field"sv};
             vec << add("Field<64>", &Fixture::test_usage_Vector<library::Vector<library::Field<64>::Value, DIMENSIONS>>)
                 << add("Field<128>", &Fixture::test_usage_Vector<library::Vector<library::Field<128>::Value, DIMENSIONS>>)
                 << END;
             return vec;
         }()
         << []{
           auto vec = Stream{"Vector"sv};
           vec << add<Vector<library::Vector<uint32_t, DIMENSIONS>>>()
               << add<Vector<library::Vector<uint64_t, DIMENSIONS>>>()
               << add<Vector<library::Vector<uint128_t, DIMENSIONS>>>()
               << add<Vector<library::Vector<Integer, DIMENSIONS>>>()
               << END;
           return vec;
         }()
         << add<get::Fixture>()
         << END;
  return settle(series);
}
#endiv
