// This is -*- c++ -*- nearly C++2a with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc, 2022.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-denniston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/services/denniston/tree/LICENSE
#divert <fpp>
#import tunitas.denniston.message.Packet
#import tunitas.denniston.network.channel.Ready
namespace tests::unit::network::socket {
  namespace [[eponymous]] fixture {
    class Fixture;
    namespace packet = ::tunitas::denniston::message::packet;
    using ::tunitas::denniston::message::Packet;
    using ::tunitas::denniston::network::channel::Ready;
  }
  using fixture::Fixture;
}
#endiv
#divert <hpp>
#import tunitas.denniston.network.Socket
#import std.vector
struct tests::unit::network::socket::Fixture : public rigging::suite::Fixture {
  static auto suite() -> Suite;
  //
  using Subject = library::Socket;
  //
  auto test_constructor_default() -> void;
  auto test_left() -> void;
  auto test_right() -> void;
  auto test_write_moving() -> void;
  auto test_write_copying() -> void;
  auto test_write_series() -> void;
  auto test_read() -> void;
  auto test_peek() -> void;
protected:
  Ready ready{}; 
  inline static constexpr auto const SERIES_COUNT = 10uz;
  using Inventory = std::vector<Packet>;
  static auto generate() -> Inventory;
  static auto fill(Subject::Interface) -> void;
};
#endiv
#divert <cpp>
auto tests::unit::network::socket::Fixture::suite() -> Suite {
  auto series = Stream{"Socket"sv};
  series << []{
              auto con = Stream{"constructor"sv};
              con << add("default", &Fixture::test_constructor_default)
                  << END;
              return con;
            }()
         << END;
  return settle(series);
}
#import tunitas.denniston.message.packet.make
#import tunitas.denniston.message.packet.Ping
#import std.make_move_iterator
namespace tests::unit::network::socket {
  auto Fixture::generate() -> Inventory {
    auto buf = std::vector<Packet>{};
    for (auto i{0uz}; SERIES_COUNT != i; ++i) {
      buf.push_back(packet::make<packet::Ping>());
    }
    return buf;
  }
  auto Fixture::fill(Subject::Interface where) -> void {
    auto prepared = generate();
    require(ASSERTION, 0 < prepared.size());
    where.write(std::make_move_iterator(prepared.begin()), std::make_move_iterator(prepared.end())); // <---------------------- test this (moving)
  }
  auto Fixture::test_constructor_default() -> void {
    auto subject = Subject{};
    require(ASSERTION, sizeof (subject));
  }
  auto Fixture::test_left() -> void {
    auto subject = Subject{};
    auto left = subject.left(&ready);
    require(ASSERTION, sizeof (left));   
  }
  auto Fixture::test_right() -> void {
    auto subject = Subject{};
    auto right = subject.right(&ready);
    require(ASSERTION, sizeof (right));   
  }
  auto Fixture::test_write_moving() -> void {
    auto subject = Subject{};
    auto right = subject.right(&ready);
    auto specimen = packet::make<packet::Ping>();
    right.write(move(specimen)); // <---------------------- test this (moving)
    require(ASSERTION);
  }
  auto Fixture::test_write_copying() -> void {
    auto delayed = [this]<typename VALUE>(VALUE const &specimen) {
      if constexpr (std::is_copy_constructible_v<VALUE>) {
        auto subject = Subject{};
        auto right = subject.right(&ready);
        right.write(specimen); // <---------------------- test this (copying)
        require(ASSERTION);
      }
    };
    delayed(packet::make<packet::Ping>());
  }
  auto Fixture::test_write_series() -> void {
    auto subject = Subject{};
    auto right = subject.right(&ready);
    auto prepared = generate();
    require(ASSERTION, 0 < prepared.size());
    right.write(std::make_move_iterator(prepared.begin()), std::make_move_iterator(prepared.end())); // <---------------------- test this (moving)
    auto drain = [](typename Subject::Interface face) {
                   auto items_read{0uz};
                   while (face.peek()) {
                     (void) face.read();
                     ++items_read;
                   }
                   return items_read;
                 };
    require(ASSERTION, SERIES_COUNT == drain(subject.right(&ready)));
  }
  auto Fixture::test_read() -> void {
    auto subject = Subject{};
    //
    // Prep: write into the left side.
    // Show: read out of the right side.
    //
    fill(subject.left(&ready));
    auto right = subject.right(&ready);
    auto items_read{0uz};
    while (right.peek()) {
      auto red = right.read();
      ++items_read;
    }
    require(ASSERTION, SERIES_COUNT == items_read);
  }
  auto Fixture::test_peek() -> void {
    // we just tested peek (above)
  }
}
#endiv
