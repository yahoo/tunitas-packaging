// This is -*- c++ -*- nearly C++2a with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
#import tunitas.keyston.protocol.query.Type
namespace tests::unit::protocol::query::similar {
  template<typename SUBJECT, template<library::Type> class RECORD> class Object;
}
#endiv
#divert <hpp>
#import tunitas.keyston.protocol.query.Visitor
namespace tests::unit::protocol::query {
  template<typename SUBJECT, template<library::Type> class RECORD> struct similar::Object : public rigging::suite::Fixture {
  public: static auto suite() -> Suite;
  protected:
    static auto stanza(string::View name) -> Stream;
    static auto stanza(std::type_info const &info) -> Stream { return stanza(info.name()); }
  public:
    using Subject = SUBJECT;
    using Type = library::Type;
    template<Type TYPE> using Record = RECORD<TYPE>;
    template<typename... TYPES> using Visitor = library::Visitor<TYPES...>;
    //
    auto test_constructor_default() -> void;
    auto test_type_default() -> void;
    auto test_visit_default() -> void;
    template<Type> auto test_constructor() -> void;
    template<Type> auto test_type() -> void;
    template<Type> auto test_visit() -> void;
  };
}
#endiv
#divert <tpp>
namespace tests::unit::protocol::query::similar {
  template<typename S, template<library::Type> class R> auto Object<S,R>::suite() -> Suite {
    auto series = stanza(typeid(Subject));
    return settle(series);
  }
  template<typename S, template<library::Type> class R> auto Object<S,R>::stanza(string::View name) -> Stream {
    auto series = Stream{"Object"sv}; // else it won't have a unique name in the tree
    series << [name]{
                auto sub = Stream{name};
                sub << []{
                         auto con = Stream{"constructor"sv};
                         con << add("default", &Object::test_constructor_default)
                             << add("RESERVED", &Object::test_constructor<Type::RESERVED>)
                             << add("TIME_INTERVAL", &Object::test_constructor<Type::TIME_INTERVAL>)
                             << add("FIXED_SIZE", &Object::test_constructor<Type::FIXED_SIZE>)
                             << END;
                         return con;
                       }()
                    << []{
                         auto res = Stream{"type"sv};
                         res << add("default", &Object::test_type_default)
                             << add("RESERVED", &Object::test_type<Type::RESERVED>)
                             << add("TIME_INTERVAL", &Object::test_type<Type::TIME_INTERVAL>)
                             << add("FIXED_SIZE", &Object::test_type<Type::FIXED_SIZE>)
                             << END;
                         return res;
                       }()
                    << []{
                         auto vis = Stream{"visit"sv};
                         vis << add("default", &Object::test_visit_default)
                             << add("RESERVED", &Object::test_visit<Type::RESERVED>)
                             << add("TIME_INTERVAL", &Object::test_visit<Type::TIME_INTERVAL>)
                             << add("FIXED_SIZE", &Object::test_visit<Type::FIXED_SIZE>)
                             << END;
                         return vis;
                       }()
                    << END;
                return sub;
              }()
           << END;
    return series;
  }
  template<typename S, template<library::Type> class R> auto Object<S,R>::test_constructor_default() -> void {
    auto subject = Subject{};
    require(ASSERTION, sizeof (subject));
  }
  template<typename S, template<library::Type> class R> auto Object<S,R>::test_type_default() -> void {
    auto specimen = Subject{};
    auto subject = specimen.type();
    require(ASSERTION, Type::RESERVED == subject);
  }
  template<typename S, template<library::Type> class R> auto Object<S,R>::test_visit_default() -> void {
    auto visitor = Visitor{[](Record<Type::RESERVED> const &)      { return true; },
                           // enumerate these all to prove we can.
                           [](Record<Type::TIME_INTERVAL> const &) { return false; },
                           [](Record<Type::FIXED_SIZE> const &)    { return false; },
                           [](auto const &)                        { return false; }};
    auto specimen = Subject{};
    auto subject = visit(visitor, specimen);
    require(ASSERTION, true == subject);
  }
  template<typename S, template<library::Type> class R> template<library::Type TYPE> auto Object<S,R>::test_constructor() -> void {
    auto subject = Subject{Record<TYPE>{}};
    require(ASSERTION, sizeof (subject));
  }
  template<typename S, template<library::Type> class R> template<library::Type TYPE> auto Object<S,R>::test_type() -> void {
    auto specimen = Subject{Record<TYPE>{}};
    auto subject = specimen.type();
    require(ASSERTION, TYPE == subject);
  }
  template<typename S, template<library::Type> class R> template<library::Type TYPE> auto Object<S,R>::test_visit() -> void {
    auto visitor = Visitor{[](Record<Type::RESERVED> const &)      { return Type::RESERVED == TYPE; },
                           [](Record<Type::TIME_INTERVAL> const &) { return Type::TIME_INTERVAL == TYPE; },
                           [](Record<Type::FIXED_SIZE> const &)    { return Type::FIXED_SIZE == TYPE; },
                           [](auto const &)                        { return false; }};
    auto specimen = Subject{Record<TYPE>{}};
    auto subject = visit(visitor, specimen);
    require(ASSERTION, true == subject);
  }
}
#endiv
