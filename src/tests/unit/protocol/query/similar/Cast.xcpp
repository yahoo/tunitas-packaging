// This is -*- c++ -*- nearly C++2a with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
#import tunitas.keyston.protocol.query.Type
namespace tests::unit::protocol::query::similar {
  //
  // Reminder:
  //
  //   There is no library::cast<...>(...) because the whole point of this test is to use multiple "libraries"
  //   Thus the utterance cast<...>(...) must be found by ADL from the declarations available at the call site.
  //
  template<typename SUBJECT, template<library::Type> class RECORD> class Cast;
}
#endiv
#divert <hpp>
#import tunitas.keyston.protocol.exception.Cast
#import tunitas.keyston.exception.Aspect
#import tunitas.exception.Aspect
namespace tests::unit::protocol::query {
  template<typename SUBJECT, template<library::Type> class RECORD> struct similar::Cast : public rigging::suite::Fixture {
  public: static auto suite() -> Suite;
  protected:
    static auto stanza(string::View name) -> Stream;
    static auto stanza(std::type_info const &info) -> Stream { return stanza(info.name()); }
  public:
    //
    using Subject = SUBJECT;
    using Type = library::Type;
    template<Type TYPE> using Record = RECORD<TYPE>;
    //
    auto test_reference_default_good() -> void;
    auto test_reference_default_fail() -> void;
    auto test_pointer_default_good() -> void;
    auto test_pointer_default_fail() -> void;
    template<Type> auto test_reference_good() -> void;
    template<Type> auto test_reference_fail() -> void;
    template<Type> auto test_pointer_good() -> void;
    template<Type> auto test_pointer_fail() -> void;
  protected:
    using Failure = ::tunitas::keyston::protocol::exception::Cast;
    using Backup = ::tunitas::keyston::exception::Aspect;
    using Failsafe = ::tunitas::exception::Aspect;
  };
}
#endiv
#divert <tpp>
namespace tests::unit::protocol::query::similar {
  template<typename S, template<library::Type> class R> auto Cast<S,R>::suite() -> Suite {
    auto series = stanza(typeid(Subject));
    return settle(series);
  }
  template<typename S, template<library::Type> class R> auto Cast<S,R>::stanza(string::View name) -> Stream {
    auto series = Stream{"cast"sv}; // else it won't have a unique name in the tree
    series << [name]{
                auto sub = Stream{name};
                sub << []{
                         auto ref = Stream{"reference"};
                         ref << []{
                                  auto ast = Stream{"default"sv};
                                  ast << add("good", &Cast::test_reference_default_good)
                                      << add("fail", &Cast::test_reference_default_fail)
                                      << END;
                                  return ast;
                                }()
                             << []{
                                  auto ast = Stream{"RESERVED"sv};
                                  ast << add("good", &Cast::test_reference_good<Type::RESERVED>)
                                      << add("fail", &Cast::test_reference_fail<Type::RESERVED>)
                                      << END;
                                  return ast;
                                }()
                             << []{
                                  auto ast = Stream{"TIME_INTERVAL"sv};
                                  ast << add("good", &Cast::test_reference_good<Type::TIME_INTERVAL>)
                                      << add("fail", &Cast::test_reference_fail<Type::TIME_INTERVAL>)
                                      << END;
                                  return ast;
                                }()
                             << []{
                                  auto ast = Stream{"FIXED_SIZE"sv};
                                  ast << add("good", &Cast::test_reference_good<Type::FIXED_SIZE>)
                                      << add("fail", &Cast::test_reference_fail<Type::FIXED_SIZE>)
                                      << END;
                                  return ast;
                                }()
                             << END;
                         return ref;
                       }()
                    << []{
                         auto poi = Stream{"pointer"sv};
                         poi << []{
                                  auto ast = Stream{"default"sv};
                                  ast << add("good", &Cast::test_pointer_default_good)
                                      << add("fail", &Cast::test_pointer_default_fail)
                                      << END;
                                  return ast;
                                }()
                             << []{
                                  auto ast = Stream{"RESERVED"sv};
                                  ast << add("good", &Cast::test_pointer_good<Type::RESERVED>)
                                      << add("fail", &Cast::test_pointer_fail<Type::RESERVED>)
                                      << END;
                                  return ast;
                                }()
                             << []{
                                  auto ast = Stream{"TIME_INTERVAL"sv};
                                  ast << add("good", &Cast::test_pointer_good<Type::TIME_INTERVAL>)
                                      << add("fail", &Cast::test_pointer_fail<Type::TIME_INTERVAL>)
                                      << END;
                                  return ast;
                                }()
                             << []{
                                  auto ast = Stream{"FIXED_SIZE"sv};
                                  ast << add("good", &Cast::test_pointer_good<Type::FIXED_SIZE>)
                                      << add("fail", &Cast::test_pointer_fail<Type::FIXED_SIZE>)
                                      << END;
                                  return ast;
                                }()
                             << END;
                         return poi;
                       }()
                    << END;
                return sub;
              }()
           << END;
    return series;
  }
  template<typename S, template<library::Type> class R> auto Cast<S,R>::test_reference_default_good() -> void {
    auto subject = Subject{};
    {
      auto const &got = cast<Record<Type::RESERVED> const &>(subject);
      require(ASSERTION, sizeof (got));
    } {
      auto &got = cast<Record<Type::RESERVED> &>(subject);
      require(ASSERTION, sizeof (got));
    }
  }
  template<typename S, template<library::Type> class R> auto Cast<S,R>::test_reference_default_fail() -> void {
    auto subject = Subject{};
    try {
      cast<Record<Type::FIXED_SIZE> const &>(subject);
      impossible(ASSERTION);
    } catch (Failure const &) {
      require(ASSERTION);
    }
    try {
      cast<Record<Type::FIXED_SIZE> &>(subject);
      impossible(ASSERTION);
    } catch (Failure const &) {
      require(ASSERTION);
    }
  }
  template<typename S, template<library::Type> class R> auto Cast<S,R>::test_pointer_default_good() -> void {
    auto subject = Subject{};
    {
      auto const *got = cast<Record<Type::RESERVED> const *>(subject);
      require(ASSERTION, nullptr != got);
    } {
      auto *got = cast<Record<Type::RESERVED> *>(subject);
      require(ASSERTION, nullptr != got);
    }
  }
  template<typename S, template<library::Type> class R> auto Cast<S,R>::test_pointer_default_fail() -> void {
    auto subject = Subject{};
    {
      auto const *got = cast<Record<Type::FIXED_SIZE> const *>(subject);
      require(ASSERTION, nullptr == got);
    } {
      auto *got = cast<Record<Type::FIXED_SIZE> *>(subject);
      require(ASSERTION, nullptr == got);
    }
  }
  template<typename S, template<library::Type> class R> template<library::Type TYPE> auto Cast<S,R>::test_reference_good() -> void {
    auto subject = Subject{Record<TYPE>{}};
    {
      auto const &got = cast<Record<TYPE> const &>(subject);
      require(ASSERTION, sizeof (got));
    } {
      auto &got = cast<Record<TYPE> &>(subject);
      require(ASSERTION, sizeof (got));
    }
  }
  template<typename S, template<library::Type> class R> template<library::Type TYPE> auto Cast<S,R>::test_reference_fail() -> void {
    constexpr auto const OTHER = Type{(1+underlying(TYPE)) % 3};
    auto subject = Subject{Record<TYPE>{}};
    try {
      cast<Record<OTHER> const &>(subject);
      impossible(ASSERTION);
    } catch (Failure const &) {
      require(ASSERTION);
    }
    try {
      cast<Record<OTHER> &>(subject);
      impossible(ASSERTION);
    } catch (Failure const &) {
      require(ASSERTION);
    }
  }
  template<typename S, template<library::Type> class R> template<library::Type TYPE> auto Cast<S,R>::test_pointer_good() -> void {
    auto subject = Subject{Record<TYPE>{}};
    {
      auto const *got = cast<Record<TYPE> const *>(subject);
      require(ASSERTION, nullptr != got);
    } {
      auto *got = cast<Record<TYPE> *>(subject);
      require(ASSERTION, nullptr != got);
    }
  }
  template<typename S, template<library::Type> class R> template<library::Type TYPE> auto Cast<S,R>::test_pointer_fail() -> void {
    constexpr auto const OTHER = Type{(1+underlying(TYPE)) % 3};
    auto subject = Subject{Record<TYPE>{}};
    {
      auto const *got = cast<Record<OTHER> const *>(subject);
      require(ASSERTION, nullptr == got);
    } {
      auto *got = cast<Record<OTHER> *>(subject);
      require(ASSERTION, nullptr == got);
    }
  }
}
#endiv
