// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc. 2022.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-denniston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/services/denniston/tree/LICENSE
#divert <fpp>
namespace tests::unit::concurrent::dictionary::sample {
  //
  // Some sample keys and values for the dictionary exercises.
  //
  enum Key : char;
  enum Index : unsigned;
  struct Value;
}
#endiv
#divert <hpp>
#import std.underlying_type
namespace tests::unit::concurrent::dictionary {
  namespace sample {
    inline constexpr auto underlying(Key k) { return std::underlying_type_t<Key>(k); }
    inline constexpr auto underlying(Index i) { return std::underlying_type_t<Index>(i); }
    inline auto key_from(Value const &self) -> string::Storage const &;
    //
    inline auto operator==(Key const &, Value const &) -> bool;
    inline auto operator==(Value const &, Key const &) -> bool;
  }
  class sample::Value : public string::Storage {
    using Ancestor = string::Storage;
  public:
    Value() = default;
    using Ancestor::basic_string;
    Value(Ancestor a) : Ancestor{move(a)} { }
    Value(Value const &) = default;
    Value(Value &&) = default;
    Value &operator=(Value const &) = default;
    Value &operator=(Value &&) = default;
    auto operator=(Ancestor a) -> Value & { Ancestor::operator=(move(a)); return *this; }
  };
}
#endiv
#divert <ipp>
namespace tests::unit::concurrent::dictionary {
  auto sample::key_from(Value const &self) -> string::Storage const & { return self; }
  auto sample::operator==(Key const &k, Value const &v) -> bool { return operator==(v, k); }
  auto sample::operator==(Value const &v, Key const &k) -> bool { return !v.empty() && v.front() == underlying(k); }
}
#endiv
#divert <cpp>
#import tunitas.denniston.concurrent.dictionary.required.Keyable
#import tunitas.denniston.concurrent.dictionary.required.Indexable
#import tunitas.denniston.concurrent.dictionary.required.Valuable
#import tunitas.denniston.concurrent.dictionary.usage.Key_From
namespace {
  namespace testate {
    namespace required = tests::unit::concurrent::dictionary::library::required;
    namespace usage = tests::unit::concurrent::dictionary::library::usage;
    using namespace tests::unit::concurrent::dictionary::sample;
    static_assert(required::Keyable<Key>);
    static_assert(required::Indexable<Index>);
    static_assert(required::Valuable<Value>);
    static_assert(usage::Key_From<Value>);
  }
}
#endiv
