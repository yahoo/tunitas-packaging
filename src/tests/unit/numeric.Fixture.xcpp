// This is -*- c++ -*- nearly C++2a with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
#import tunitas.keyston.numeric
namespace tests::unit::numeric {
  namespace [[eponymous]] fixture {
    class Fixture;
    namespace library = ::tunitas::keyston::numeric;
  }
  using fixture::Fixture;
}
#endiv
#divert <hpp>
#import tunitas.number.Integer
#import tunitas.keyston.measurement.Specimen
#import tunitas.keyston.measurement.Result
#import std.make_signed
#import std.make_unsigned
namespace tests::unit::numeric {
  struct fixture::Fixture : public rigging::suite::Fixture {
    static auto suite() -> Suite;
    //
    using Integer = ::tunitas::number::Integer;
    using Result = ::tunitas::keyston::measurement::Result;
    using Specimen = ::tunitas::keyston::measurement::Specimen;
    //
    auto test_enbiggen_easy() -> void;
    auto test_enbiggen_hard() -> void;
    //
    auto test_ensmallen_easy() -> void;
    auto test_ensmallen_hard() -> void;
    auto test_ensmallen_negative() -> void;
    auto test_ensmallen_clipped() -> void;
  protected:
    struct Hard {
      // This is "hard" because Integer is signed and we're going to be putting big unsigned values into it.
      using Type = int unsigned long long;
      struct Limits {
        using Signed = std::numeric_limits<std::make_signed_t<Type>>;
        using Unsigned = std::numeric_limits<Type>;
      };
      class Special {
        using Signed = std::make_signed_t<Type>;
        using Unsigned = std::make_unsigned_t<Type>;
      public:
        inline static constexpr auto WHOLE = Limits::Unsigned::max() - 1234; // any number Limits::Signed::max() < candidate <= Limits::Unsigned::max() will work
        inline static constexpr Signed FRAG = WHOLE / 2;
        inline static constexpr Signed MENT = WHOLE - FRAG;
        template<typename RESULT> inline static auto whole() -> RESULT = delete;
        static_assert(WHOLE == Unsigned{FRAG} + Unsigned{MENT});
      };
    };
  };
  namespace fixture {
    template<> inline auto Fixture::Hard::Special::whole<Fixture::Integer>()                -> Integer { return Integer{FRAG} + Integer{MENT}; }
    template<> inline auto Fixture::Hard::Special::whole<Fixture::Specimen>()     -> Fixture::Specimen { return Specimen{Hard::Special::WHOLE}; }
    template<> inline auto Fixture::Hard::Special::whole<Fixture::Result>()         -> Fixture::Result { return Result{Hard::Special::WHOLE}; }
    template<> inline auto Fixture::Hard::Special::whole<Fixture::Hard::Type>() -> Fixture::Hard::Type { return Hard::Special::WHOLE; }
  }
}
#endiv
#divert <cpp>
auto tests::unit::numeric::fixture::Fixture::suite() -> Suite {
  auto series = Stream{"numeric"sv};
  series << []{
              auto en = Stream{"enbiggen"sv};
              en << add("easy", &Fixture::test_enbiggen_easy)
                 << add("hard", &Fixture::test_enbiggen_hard)
                 << END;
              return en;
            }()
         << []{
              auto en = Stream{"ensmallen"sv};
              en << add("easy", &Fixture::test_ensmallen_easy)
                 << add("hard", &Fixture::test_ensmallen_hard)
                 << add("negative", &Fixture::test_ensmallen_negative)
                 << add("clipped", &Fixture::test_ensmallen_clipped)
                 << END;
              return en;
            }()
         << END;
  return settle(series);
}
#import tunitas.keyston.numeric.enbiggen
#import tunitas.keyston.numeric.ensmallen
namespace tests::unit::numeric::fixture { 
  auto Fixture::test_enbiggen_easy() -> void {
    constexpr auto SMALL = 3u;
    constexpr auto specimen = Specimen{SMALL};
    constexpr auto expected = Result{SMALL};
    auto intermediate = library::enbiggen(specimen);
    require(ASSERTION, SMALL == intermediate.get<int>());
    auto [observed, clipped] = library::ensmallen(intermediate);
    require(ASSERTION, expected == observed);
    require(ASSERTION, false == clipped);
  }
  auto Fixture::test_enbiggen_hard() -> void {
    auto const specimen = Hard::Special::whole<Specimen>();
    std::cerr << "specimen=" << underlying(specimen) << '\n';
    auto const expected_value = Hard::Special::whole<Result>();
    auto const expected_clipped = false;
    std::cerr << "expected=" << underlying(expected_value) << '\n';
    auto intermediate = library::enbiggen(specimen);
    std::cerr << "intermediate=" << intermediate << '\n';
    auto [observed_value, observed_clipped] = library::ensmallen(intermediate); // this will clip
    std::cerr << "observed=" << underlying(observed_value) << '\n';
    require(ASSERTION, expected_value == observed_value);
    require(ASSERTION, expected_clipped == observed_clipped);
  }
  auto Fixture::test_ensmallen_easy() -> void {
    constexpr auto SMALL = 3;
    auto const specimen = Integer{SMALL};
    auto const expected = Integer{SMALL};
    auto intermediate0 = library::ensmallen(library::Clip::SILENTLY, specimen);
    require(ASSERTION, SMALL == underlying(intermediate0));
    auto intermediate1 = Specimen{underlying(intermediate0)};
    auto observed = library::enbiggen(intermediate1);
    require(ASSERTION, SMALL == observed.get<int>());
    require(ASSERTION, expected == observed);
  }
  auto Fixture::test_ensmallen_hard() -> void {
    std::cerr << "FRAG=" << Hard::Special::FRAG << ' ' << Integer{Hard::Special::FRAG} << '\n';
    std::cerr << "MENT=" << Hard::Special::MENT << ' ' << Integer{Hard::Special::MENT} << '\n';
    std::cerr << "more=" << (1+Hard::Special::MENT) << ' ' << (1+Integer{Hard::Special::MENT}) << '\n';
    Integer const specimen = Integer{Hard::Special::FRAG} + Integer{Hard::Special::MENT};
    std::cerr << "specimen=" << specimen << '\n';
    auto const expected = Hard::Special::whole<Hard::Type >();
    std::cerr << "expected=" << expected << '\n';
    auto [observed, clipped] = library::ensmallen(specimen);
    require(ASSERTION, false == clipped);
    std::cerr << "observed=" << underlying(observed) << '\n';
    require(ASSERTION, expected == underlying(observed));
  }
  auto Fixture::test_ensmallen_negative() -> void {
    constexpr auto NEGATIVE = -3;
    auto const specimen = Integer{NEGATIVE};
    constexpr auto const expected_value = Result{0};
    constexpr auto const expected_clipped = true;
    auto [observed_value, observed_clipped] = library::ensmallen(specimen);
    require(ASSERTION, expected_value == observed_value);
    require(ASSERTION, expected_clipped == observed_clipped);
  }
  auto Fixture::test_ensmallen_clipped() -> void {
    // WATCHOUT - do not use 'auto' here because that will leave the unevaluated expressions on the stack with dangling references into their sub-expressions.
    Integer const WOOFA = 2 * Hard::Special::whole<Integer>() + 37; // any biggie value will work
    Integer const copy0 = WOOFA;
    Integer const copy1 = Integer{WOOFA};
    auto const specimen = Integer{WOOFA};
    std::cerr << "whole<Integer>=" << Hard::Special::whole<Integer>() << '\n';
    std::cerr << "WOOFA=" << WOOFA << '\n';
    std::cerr << "copy0=" << copy0 << '\n';
    std::cerr << "copy1=" << copy1 << '\n';
    std::cerr << "specimen=" << specimen << '\n';
    constexpr auto const expected_value = Result{Hard::Limits::Unsigned::max()};
    constexpr auto const expected_clipped = true;
    std::cerr << "expected=" << underlying(expected_value) << ' ' << (expected_clipped ? "clipped" : "correct") << '\n';
    auto [observed_value, observed_clipped] = library::ensmallen(specimen);
    std::cerr << "observed=" << underlying(observed_value) << ' ' << (observed_clipped ? "clipped" : "correct") << '\n';
    require(ASSERTION, expected_value == observed_value);
    require(ASSERTION, expected_clipped == observed_clipped);
  }
}
#endiv
