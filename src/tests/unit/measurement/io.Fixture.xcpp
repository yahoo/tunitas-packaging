// This is -*- c++ -*- nearly C++2a with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc, 2022.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
namespace tests::unit::measurement::io { class Fixture; }
#endiv
#divert <hpp>
#import tunitas.keyston.histogram.Histogram
#import tunitas.keyston.popularity.Popularity
#import nonstd.units.memory.scale // Bits
struct tests::unit::measurement::io::Fixture : public rigging::suite::Fixture {
  static auto suite() -> Suite;
  //
  auto test_Specimen() -> void;
  auto test_Histogram1() -> void;
  auto test_Histogram2() -> void;
  auto test_Popularity1() -> void;
  auto test_Popularity2() -> void;
protected:
  template<typename TYPE> static auto exhibit(TYPE const &) -> string::Storage;
  template<typename SUBJECT> static auto singleton(string::Storage expected, SUBJECT specimen) -> void;
  using Histogram = ::tunitas::keyston::histogram::Histogram;
  using Popularity = ::tunitas::keyston::popularity::Popularity;
  using Bits = ::nonstd::units::memory::Bits;
};
#endiv
#divert <tpp>
#import std.ostringstream
namespace tests::unit::measurement::io {
  template<typename TYPE> auto Fixture::exhibit(TYPE const &specimen) -> string::Storage {
    auto buf = std::ostringstream{};
    buf << format(specimen); // <---------------------------------------- test this
    return buf.str();
  }
  template<typename SUBJECT> auto Fixture::singleton(string::Storage expected, SUBJECT specimen) -> void {
    auto observed = exhibit(specimen);
    require(ASSERTION, expected == observed);
  }
}
#endiv
#divert <cpp>
auto tests::unit::measurement::io::Fixture::suite() -> Suite {
  auto series = Stream{"io"sv};
  series << add("Specimen", &Fixture::test_Specimen)
         << []{
              auto his = Stream{"Histogram"sv};
              his << add("alone", &Fixture::test_Histogram1)
                  << add("context", &Fixture::test_Histogram2)
                  << END;
              return his;
            }()
         << []{
              auto pop = Stream{"Popularity"sv};
              pop << add("alone", &Fixture::test_Popularity1)
                  << add("context", &Fixture::test_Popularity2)
                  << END;
              return pop;
            }()
         << END;
  return settle(series);
}
#import tunitas.keyston.measurement.Specimen
#import tunitas.keyston.measurement.Boundaries
#import tunitas.keyston.measurement.Prefixes
#import std.views.iota
namespace tests::unit::measurement::io { 
  auto Fixture::test_Specimen() -> void { singleton("2"s, library::Specimen{2u}); }
  auto Fixture::test_Histogram1() -> void {
    auto subject = Histogram{};
    // Gonna have to inspect these on the console
    std::cerr << format(subject) << '\n'; // <---------------------------------------- test this
    for (auto percent : std::views::iota(0u, subject.size())) {
      subject.at(percent) = Histogram::Value{1000 * percent};
    }
    std::cerr << format(subject) << '\n'; // <---------------------------------------- test this
  }
  auto Fixture::test_Histogram2() -> void {
    auto boundaries = library::Boundaries{};
    auto histogram = Histogram{};
    {
      for (auto percent : std::views::iota(0u, boundaries.size())) {
        boundaries.at(percent) = library::Boundaries::Value{percent};
        histogram.at(percent) = Histogram::Value{1000 * percent};
      }
    }
    std::cerr << format(boundaries, histogram) << '\n'; // <---------------------------- test this
  }
  auto Fixture::test_Popularity1() -> void {
    {
      auto subject = Popularity{};
      // Gonna have to inspect these on the console
      std::cerr << format(subject) << '\n'; // <---------------------------------------- test this
    } {
      auto subject = Popularity{};
      for (auto percent : std::views::iota(0u, subject.size())) {
        subject.at(percent) = Popularity::Value{1000 * percent};
      }
      std::cerr << format(subject) << '\n'; // <---------------------------------------- test this
    }
  }
  auto Fixture::test_Popularity2() -> void {
    constexpr auto SIZE = 10u;
    auto prefix_length = Bits{7};
    auto prefixes = library::Prefixes(SIZE, library::Prefixes::Value{});
    auto population = Popularity(SIZE, Popularity::Value{});
    {
      for (auto percent : std::views::iota(0u, prefixes.size())) {
        prefixes.at(percent) = library::Prefixes::Value{100 * percent};
        population.at(percent) = Popularity::Value{1000 * percent};
      }
    }
    std::cerr << format(prefix_length, prefixes, population) << '\n'; // <--------------- test this
  }
}
#endiv
