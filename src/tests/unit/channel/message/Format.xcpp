// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc. 2022.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-denniston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/services/denniston/tree/LICENSE
#divert <fpp>
namespace tests::unit::channel::message {
  //
  // Format the body of a Message.  Not for the public.
  //
  // Usage:
  //
  //   auto m = Message{a, b, c};
  //   cerr << format(m);
  //
  struct Format;
}
#endiv
#divert <hpp>
#import std.ostream
#forward tests.unit.channel.Message
namespace tests::unit::channel {
  namespace message {
    auto format(Message const &) -> message::Format;
    auto operator<<(std::ostream &, Format const &) -> std::ostream &;
  }
  using message::format; // so it is easy to find

  struct message::Format {
    inline Format(Message const &message) : message{message} { }
    Message const &message;
    // Whereas Format is a friend of Body, we can access its private members from here.
    auto to_stream(std::ostream &) const -> std::ostream &;
  };
}
#endiv
#divert <ipp>
#import tests.unit.channel.Message
#endiv
#divert <cpp>
namespace tests::unit::channel {
  auto message::format(Message const &m) -> Format { return Format{m}; }
  auto message::operator<<(std::ostream &o, Format const &f) -> std::ostream & { return f.to_stream(o); }
  namespace message {
    auto Format::to_stream(std::ostream &o) const -> std::ostream & { return o << message.body->a << '/' << message.body->b << '/' << message.body->c; }
  }
}
#endiv
