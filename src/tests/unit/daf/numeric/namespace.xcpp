// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
#import tests.unit.daf
#import tunitas.keyston.daf.numeric
#import tunitas.keyston.daf.numeric.zero
#import tunitas.keyston.daf.numeric.constant
#import tunitas.keyston.daf.numeric.count
#import tunitas.keyston.daf.numeric.sum
#import tunitas.keyston.daf.numeric.histogram
#import tunitas.keyston.daf.numeric.popularity
//
#import tunitas.keyston.daf.Configuration
#import tunitas.keyston.Slice
#import tunitas.keyston.Shards
#import tunitas.keyston.shards.literals
#import tunitas.array.Series
#import tunitas.keyston.field.Element
#import tunitas.keyston.measurement.Specimen
#import tunitas.keyston.aggregation.Count
#import tunitas.keyston.measurement.Records
namespace tests::unit::daf::numeric {
  namespace library = ::tunitas::keyston::daf::numeric;
  //
  using namespace ::tunitas::keyston::shards::literals;
  using Configuration = ::tunitas::keyston::daf::Configuration<Transport::NUMERIC>;
  using ::tunitas::keyston::field::Element;
  template<::tunitas::keyston::shards::required::Shardable TYPE> using Shards = ::tunitas::keyston::Shards<TYPE>;
  template<::tunitas::array::required::Arrayable TYPE> using Series = ::tunitas::array::Series<TYPE>;
  using enum ::tunitas::keyston::Slice;
  using ::tunitas::keyston::measurement::Specimen;
  using ::tunitas::keyston::aggregation::Count; // [[FIXTHIS]] why is this here and not also Summation, Histogram, Popularity?
  using ::tunitas::keyston::measurement::Records;
  namespace [[nodirectory]] defaults { }
  namespace [[nodirectory]] zero       { namespace library = ::tunitas::keyston::daf::numeric::zero; }
  namespace [[nodirectory]] constant   { namespace library = ::tunitas::keyston::daf::numeric::constant; }
  namespace [[nodirectory]] count      { namespace library = ::tunitas::keyston::daf::numeric::count; }
  namespace [[nodirectory]] sum        { namespace library = ::tunitas::keyston::daf::numeric::sum; }
  namespace [[nodirectory]] histogram  { namespace library = ::tunitas::keyston::daf::numeric::histogram; }
  namespace [[nodirectory]] popularity { namespace library = ::tunitas::keyston::daf::numeric::popularity; }
}
#endiv
#divert <hpp>
#import tunitas.keyston.nonce.Bits
#import nonstd.uint128_t
#import nonstd.int128.ostream
#import std.numeric_limits
namespace tests::unit::daf::numeric {
  using nonstd::int128::operator<<; // for the lulz (debugging) and the convenience.
  namespace defaults {
    // have some "randomness" which gives bits in the full 16 bytes of the randomness.
    inline constexpr auto RANDOMNESS = ::tunitas::keyston::nonce::Bits<128>{(nonstd::uint128_t{0x0'fedc'ba98'7654'3210llu} << 64) | nonstd::uint128_t{0x0'0123'4567'89ab'cdefllu}};
    // selfcheck: if the high-64 bits equal the low-64 bits then the test is moot (tests nothing
    static_assert((RANDOMNESS.value >> 64) != (RANDOMNESS.value & std::numeric_limits<std::uint64_t>::max()));
  }
}
#endiv
