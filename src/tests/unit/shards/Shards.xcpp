// This is -*- c++ -*- nearly C++2a with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
#import tunitas.keyston.shards
namespace tests::unit::shards { class Shards; }
#endiv
#divert <hpp>
#import tunitas.keyston.Shards
#import tunitas.keyston.Shard
#import tunitas.keyston.exception.Aspect
struct tests::unit::shards::Shards : public rigging::suite::Fixture {
  static auto suite() -> Suite;
  //
  using Subject = library::Shards<int>;
  using Shard = library::Shard;
  //
  auto test_constructor_default() -> void;
  auto test_at_constie_good() -> void;
  auto test_at_constie_fail() -> void;
  auto test_at_mutable_good() -> void;
  auto test_at_mutable_fail() -> void;
  auto test_iota() -> void;
  auto test_swap() -> void;
protected:
  using Failure = ::tunitas::keyston::exception::Aspect;
  inline static constexpr auto const INVALID_INDEX = Shard{99};
};
#endiv
#divert <cpp>
auto tests::unit::shards::Shards::suite() -> Suite {
  auto series = Stream{"Shards<int>"sv};
  series << []{
              auto con = Stream{"constructor"sv};
              con << add("default", &Shards::test_constructor_default)
                  << END;
              return con;
            }()
         << []{
           auto at = Stream{"at"sv};
           at << []{
                   auto con = Stream{"constie"sv};
                   con << add("good", &Shards::test_at_constie_good)
                       << add("fail", &Shards::test_at_constie_fail) 
                       << END;
                   return con;
                 }()
              << []{
                auto mut = Stream{"mutable"sv};
                mut << add("good", &Shards::test_at_mutable_good)
                    << add("fail", &Shards::test_at_mutable_fail) 
                    << END;
                return mut;
              }()
              << END;
           return at;
         }()
         << add("iota", &Shards::test_iota) 
         << add("swap", &Shards::test_swap) 
         << END;
  return settle(series);
}
namespace tests::unit::shards {
  auto Shards::test_constructor_default() -> void {
    auto subject = Subject{};
    require(ASSERTION, library::SHARD_COUNT.count() == subject.size());
  }
  auto Shards::test_at_constie_good() -> void {
    auto subject = Subject{Subject::Inplace{}, -1,-2};
    require(ASSERTION, -1 == subject.at(Shard{0})); // <------------------------------ test this (constie)
    require(ASSERTION, -2 == subject.at(Shard{1})); // <------------------------------ test this (constie)
  }
  auto Shards::test_at_constie_fail() -> void try {
    auto subject = Subject{};
    subject.at(INVALID_INDEX); // <------------------------------ test this (constie)
    impossible(ASSERTION);
  } catch (Failure const &)  {
    require(ASSERTION);
  }
  auto Shards::test_at_mutable_good() -> void {
    auto subject = Subject{Subject::Inplace{}, -3,-4};
    require(ASSERTION, -3 == subject.at(Shard{0})); // <------------------------------ test this (constie)
    require(ASSERTION, -4 == subject.at(Shard{1})); // <------------------------------ test this (constie)
    subject.at(Shard{0}) = - subject.at(Shard{0});
    subject.at(Shard{1}) = - subject.at(Shard{1});
    require(ASSERTION, 3 == subject.at(Shard{0})); // <------------------------------ test this (constie)
    require(ASSERTION, 4 == subject.at(Shard{1})); // <------------------------------ test this (constie)
  }
  auto Shards::test_at_mutable_fail() -> void try {
    auto subject = Subject{};
    subject.at(INVALID_INDEX); // <------------------------------ test this (mutable)
    impossible(ASSERTION);
  } catch (Failure const &)  {
    require(ASSERTION);
  }
  auto Shards::test_iota() -> void {
    auto subject = Subject{};
    unsigned count{};
    for (auto shard : iota(subject)) { // <-------------------- test this
      ++count;
      require(ASSERTION, sizeof(shard)); // gratuitously use the loop variable
    }
    require(ASSERTION, library::SHARD_COUNT.count() == count);
  }
  auto Shards::test_swap() -> void {
    auto subject0 = Subject{};
    auto subject1 = Subject{Subject::Inplace{}, 88,99};
    require(ASSERTION, 0 == subject0.at(Shard{0}));
    require(ASSERTION, 0 == subject0.at(Shard{1}));
    swap(subject0, subject1); // <------------------------------ test this (constie)
    require(ASSERTION, 88 == subject0.at(Shard{0}));
    require(ASSERTION, 99 == subject0.at(Shard{1}));
  }
}
#endiv
