// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-denniston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/services/denniston/tree/LICENSE
#divert <fpp>
#import tests.unit.service.partial.required.Controllable
namespace tests::unit::service::partial {
  //
  // A (sub)Driver.
  // The (generic) owner; specializations are possible.
  //
  // Specification:
  //
  //   Just enough like the big driver (tunitas::denniston::driver::Driver> to show testability.
  //   Need the control channel (one socket)
  //
  // Design:
  //
  //   Just what you see.
  //   This is within namespace tests::unit so the global qualifier ::tunitas is mandatory.
  //
  //   The destrutor (~Driver()) MUST be public so that Supervisor<...> can use it in unique_ptr
  //
  // Usage:
  //
  //   Construct with RAII hold in the Supervisor.
  //
  template<required::Controllable> struct Driver;
}
#endiv
#divert <hpp>
#import tests.unit.service.partial.Background
#forward tests.unit.service.partial.Supervisor
namespace tests::unit::service {
  template<partial::required::Controllable SUBJECT> struct partial::Driver : public Background {
    using Ancestor = Background;
  public:
    using Subject = SUBJECT;
    Subject subject;
    auto start() -> void override { start_background(subject); }
    auto stop() -> void override;
    ~Driver();
  protected:
    friend class partial::Supervisor<Subject>;
    template<typename... ARGUMENT> explicit Driver(ARGUMENT &&...);
  };
}
#endiv
#divert <tpp>
namespace tests::unit::service::partial {
  template<required::Controllable _> template<typename... ARGUMENT> Driver<_>::Driver(ARGUMENT &&...argument)
    : subject{source, world, forward<ARGUMENT>(argument)...} {
    Ancestor::linkup(subject);
  }
  template<required::Controllable _> Driver<_>::~Driver() {
    // We must stop-idempotent in case an exception is thrown (a test fails an assertion) and left it running.
    //
    // This MUST be done in d Driver::~Driver() and not in Driver::Ancestor, i.e. Background::~Background()
    // It is only here that the subject is still living and linked into the simulation communication network.
    //
    if (running) {
      stop();
    }
  }
  template<required::Controllable _> auto Driver<_>::stop() -> void {
#if 0 // redundant in the subprocesses destructor
    subject.subprocesses.request_for_all_to_finish();
    subject.subprocesses.wait_for_all_to_finish();
#endif
    stop_background();
    block_until_the_quit_packet_is_processed(subject);
  }
}
#endiv
