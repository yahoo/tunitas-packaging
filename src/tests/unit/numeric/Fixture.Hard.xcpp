// This is -*- c++ -*- nearly C++2a with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
#include <hpp/tests.unit.numeric.Fixture>
#endiv
#divert <hpp>
#import std.make_signed
#import std.make_unsigned
#import std.numeric_limits
namespace tests::unit::numeric {
  struct [[deprecated("REMOVETHIS")]] Fixture::Hard {
    using Type = int unsigned long long;
    struct Limits {
      using Signed = std::numeric_limits<std::make_signed_t<Type>>;
      using Unsigned = std::numeric_limits<Type>;
    };
    class Special {
      using Signed = std::make_signed_t<Type>;
      using Unsigned = std::make_unsigned_t<Type>;
    public:
      inline static constexpr auto WHOLE = Limits::Unsigned::max() - 1234; // any number Limits::Signed::max() < candidate <= Limits::Unsigned::max() will work
      inline static constexpr Signed FRAG = WHOLE / 2;
      inline static constexpr Signed MENT = WHOLE - FRAG;
      template<typename RESULT> inline static auto whole() -> RESULT = delete;
      static_assert(WHOLE == Unsigned{FRAG} + Unsigned{MENT});
    };
  };
  template<> inline auto Fixture::Hard::Special::whole<Fixture::Specimen>()     -> Fixture::Specimen { return Specimen{Hard::Special::WHOLE}; }
  template<> inline auto Fixture::Hard::Special::whole<Fixture::Simple>()         -> Fixture::Simple { return Simple{Hard::Special::WHOLE}; }
  template<> inline auto Fixture::Hard::Special::whole<Fixture::Hard::Type>() -> Fixture::Hard::Type { return Hard::Special::WHOLE; }
}
#endiv
