// This is -*- c++ -*- nearly C++2a with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
#import tests.exhibition.inventory.required.Callable
namespace tests::exhibition::inventory {
  //
  // The inventory of exhibitions.
  //
  // Specification:
  //
  //   It's a map, lookup by name.
  //   Call the exhibition function to emit on an ostream
  //
  // Design:
  //
  //   Obvious, when you think bout it.
  //   std::less<> is std::less<void> which allows for deduced comparisons (since C++14)
  //
  // Usage:
  //
  //   Hack The Spew (this is a test, rig after all)
  //
  //   Also, see tests::exhibition::main(...)
  //   To wit:
  //        auto inventory = Inventory{};
  //        auto found = inventory.find(word);
  //        if (INVENTORY.end() == found) {
  //          ...complain...
  //        } else {
  //          found->second();
  //        }
  //      }
  //
  //
  template<required::Callable> struct Function;
}
#endiv
#divert <hpp>
#import tunitas.string.Storage
#import std.function
#import std.less
#import std.ostream
#import std.map
#import tunitas.keyston.formatter.Formatter
namespace tests::exhibition {
  namespace inventory {
    template<required::Callable CALLABLE> inline constexpr auto format(Function<CALLABLE> const &i) -> tunitas::keyston::formatter::Formatter<Function<CALLABLE>, Function<CALLABLE> const &> { return {i}; }
  }
  template<inventory::required::Callable CALLABLE> struct inventory::Function : private std::map<tunitas::string::Storage, std::function<CALLABLE>, std::less<>> {
    using Ancestor = std::map<tunitas::string::Storage, std::function<CALLABLE>, std::less<>>;
  protected:
    ~Function() = default;
  public:
    using Key = Ancestor::key_type;
    using Mapped = Ancestor::mapped_type;
    using Value = Ancestor::value_type;
    using Ancestor::map;
    Function(Function const &) = delete; // why would you need to copy-assign one of these?
    //
    using Ancestor::find;
    using Ancestor::begin;
    using Ancestor::end;
  };
}
#import tests.exhibition.inventory.io
#endiv
