// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc. 2022.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-denniston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/services/denniston/tree/LICENSE
#divert <fpp>
namespace app::flow {
  namespace package_main {
    namespace body::exported { }
    namespace interface = body::exported;
  }
  using namespace package_main::interface;
}
#import cli.exits.constants
namespace app::flow::package_main {
  namespace body {
    using namespace cli::exits::constants;
  }
}
#import cli.controllability.Through
#import cli.exits.Code
#import cli.options.c.Argv
#import cli.experience.Console
#import cli.options.Program
namespace app::flow::package_main {
  using Exit = cli::exits::Code;
  using cli::options::c::Argv;
  using cli::experience::Console;
  namespace body {
    using cli::controllability::Through;
    using cli::options::Program;
  }
}
#endiv
#divert <hpp>
#import app.flow.Configuration
namespace app::flow::package_main {
  namespace body {
    namespace exported {
      inline auto main(int, char *[]) -> Exit;
      auto main(Argv) -> Exit;
      auto main([[inout]] Console &, [[inout]] Configuration &, Argv) -> Exit;
    }
  }
}
#endiv
#divert <ipp>
namespace app::flow::package_main {
  auto interface::main(int cc, char *vv[]) -> Exit { return main(Argv(cc, vv)); }
}
#endiv
#divert <cpp>
#import std.cerr
#import app.exception.Testing
#import app.flow.run
#import app.flow.options.Specification
#import app.flow.options.Parser
#import cli.exception.feature.Quitting
namespace app::flow::package_main {
  auto interface::main(Argv argv) -> Exit try {
    auto program = Program{argv};
    auto cfg = Configuration{};
    auto exp = Console{move(program), cfg};
    return main(exp, cfg, argv);
  } catch (substd::exception::Exception const &e) {
    std::cerr << "error: unexpected exception " << e.what() << '\n';
    return SOFTWARE;
  }
  auto interface::main(Console &exp, Configuration &cfg, Argv argv) -> Exit try {
    auto const spec = options::Specification{};
    auto parser = options::Parser{exp, spec};
    if (auto parsed=parser.parse(cfg, argv); fail(parsed)) {
      return CONFIGURATION;
    } else {
      if (testing(cfg) <= Through::OPTIONS) {
        throw exception::Testing{exp};
      }
      debug(exp) << "running!\n";
      return run(exp, cfg);
    }
  } catch (cli::exception::feature::Quitting const &q) {
    q.stream() << q.what() << '\n';
    return q.exit();
  }
}
#endiv
