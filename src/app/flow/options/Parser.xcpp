// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-alambique/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/services/alambique/tree/LICENSE
#divert <fpp>
#import cli.exits.constants
#import cli.experience.Console
#import cli.options.dualie
namespace app::flow::options {
  //
  // The options parser.
  //
  // Specification:
  //
  //   Whatever the usage says.
  //   Accepts a c::Argv
  //   Reorders the Argv according to the machinations within getopt(3).
  //
  // Design:
  //
  //   Yes.
  //
  // Lifetimes:
  //
  //   lifetime(Parser) < lifetime(cfg)
  //   lifetime(Parser) < lifetime(spec)
  //
  //   The lifetime of the Configuration (cfg) must be longer than the Parser.
  //   The lifetime of the Specification (spec) must be longer than the Parser.
  //
  // Usage:
  //
  //   auto spec = Specification{};
  //   auto parser = Parser{cfg, spec};
  //   auto parsed = parser.parse(args);
  //   if (ok(parsed)) {
  //     ...etc...
  //   }
  //
  namespace [[eponymous]] parser {
    class Parser;
    using namespace cli::exits::constants;
    using cli::experience::Console;
    namespace dualie = cli::options::dualie;
  }
  using parser::Parser;
}
#endiv
#divert <hpp>
#import app.flow.Configuration
#import app.flow.options.Specification
#import cli.experience.Console
#import tunitas.application.options.Args
#import tunitas.application.options.get.filepath
namespace app::flow::options {
  namespace parser {
    // any?
  }
  struct parser::Parser {
    inline explicit Parser([[inout]] Console &, Specification const &);
    // disallow temporaries in places where the lifetimes matter
    inline Parser(Specification &&) = delete;
    struct Result;
    auto parse([[inout]] Configuration &, [[inout]] Args &) -> Result;
  protected:
    Console &exp;
    Specification const &specification;
  };
}
#import app.flow.options.Parser.Result
#endiv
#divert <ipp>
#import app.flow.options.Specification
namespace app::flow::options::parser {
  Parser::Parser(Console &exp, Specification const &specification)
    : exp{exp}
    , specification{specification}
  { }
}
#endiv
#divert <cpp>
#import app.exception.Quitting
#import app.exception.quitting.Programmatic
#import app.exception.Version
#import app.flow.exception.Usage
#import app.flow.options.indicator.constants
#import app.flow.options.get.aggregation_function_mode
#import app.flow.options.get.aggregation_function_name
#import cli.options.dualie.Getter
namespace app::flow::options::parser {
  auto Parser::parse(Configuration &cfg, Args &args) -> Result {
    auto getter = dualie::Getter{specification.shortish(), specification.longish(), args};
    for (auto step=getter(); more(step); step=getter()) {
      namespace oi = indicator;
      switch (code(step)) {
      case oi::CHR_D:
      case oi::DEBUG_MODE:
        cfg.debug_mode = true;
        break;
      case oi::OLD_DEBUG_MODE:
        warning(exp) << "instead prefer " << std::quoted("--DEBUG"sv, '\'') << " (upper case)\n";
        cfg.debug_mode = true;
        break;
      case oi::CHR_h:
      case oi::USAGE_SUBCOMMAND:
        throw exception::Usage{exp, OK};
      case oi::CHR_i:
      case oi::INTERACTIVE_MODE:
        cfg.interactive_mode = true;
        break;
      case oi::CHR_p:
      case oi::PROGRAMMATIC_MODE:
        cfg.programmatic_mode = true;
        break;
      case oi::CHR_q:
      case oi::QUIET_MODE:
        cfg.quiet_mode = true;
        break;
      case oi::CHR_v:
      case oi::VERBOSE_MODE:
        cfg.verbose_mode = true;
        break;
      case oi::CHR_w:
      case oi::WARNINGS_MODE:
        cfg.warning_mode = true;
        break;
      case oi::CHR_V:
      case oi::VERSION_SUBCOMMAND:
        throw exception::Version{exp};
      case oi::CHR_y:
      case oi::DRYRUN_MODE:
        cfg.dry_run_mode = true;
        break;
      {
        using tunitas::alambique::function::Mode;
        case oi::USE_AF_MODE:
          cfg.aggregation_function_mode = Mode::AF;
          break;
        case oi::USE_DAF_MODE:
          cfg.aggregation_function_mode = Mode::DAF;
          break;
        case oi::USE_VDAF_MODE:
          cfg.aggregation_function_mode = Mode::VDAF;
          break;
        case oi::USE_VIDAF_MODE:
          cfg.aggregation_function_mode = Mode::VIDAF;
          break;
        case oi::CHR_f:
        case oi::MEASUREMENT_DATA_FILEPATH:
          cfg.measurement_data_filepath = get::filepath<exception::quitting::Programmatic>(exp, step, "measurement-data-filepath"s);
          break;
        case oi::CHR_m:
        case oi::AGGREGATION_FUNCTION_MODE:
          cfg.aggregation_function_mode = get::aggregation_function_mode<exception::quitting::Programmatic>(exp, step, "aggregation-function-mode"s);
          break;
        case oi::CHR_n:
        case oi::AGGREGATION_FUNCTION_NAME:
          {
            auto names = get::aggregation_function_name<exception::quitting::Programmatic>(exp, step, "aggregation-function-name"s);
            cfg.aggregation_function_names = names;
            //
            // Because we're inferring something here, we warn and error if the inference contradicts previous work.
            if (auto resolved=resolve(names); resolved) {
              auto proposed = *resolved;
              auto assessed = assess(names).value();
              if (!cfg.aggregation_function_mode) {
                cfg.aggregation_function_mode = assessed;
              } else if (auto previously=*cfg.aggregation_function_mode; previously != assessed) {
                auto q = [](auto const &item) { return std::quoted(to_string(tunitas::error::by::Exception{}, item), '\''); };
                notice(exp) << "the aggregation-function-mode was already established as " << q(previously) << '\n';
                error(exp) << "the function-aggregation-modes are conflicting: " << q(previously) << " and " << q(proposed) << '\n';
                throw exception::Quitting{exp, CONFIGURATION};
              }
            }
          }
          break;
      }
      case oi::MISSING:
        error(exp) << "missing value for " << word_in_error(step) << '\n';
        throw exception::Quitting{exp, USAGE};
        // return USAGE;
      case oi::UNKNOWN:
        error(exp) << "unknown option " << word_in_error(step) << '\n';
        throw exception::Quitting{exp, USAGE};
        // return USAGE;
      default:
        // This is a programmer error (reasonably it is a logic_error) because some option from the argv line wasn't configured.
        // It is also substantially untestable in a correctly configured system.
        error(exp) << "unconfigured option '" << char(code(step)) << "'\n";
        throw exception::Quitting{exp, SOFTWARE};
      }
    }
    if (getter.size()) {
      error(exp) << "there may not be any words after the options\n";
      throw exception::Quitting{exp, USAGE};
    } else {
      return {getter.begin(), getter.end()};
    }
  }
}
#endiv
