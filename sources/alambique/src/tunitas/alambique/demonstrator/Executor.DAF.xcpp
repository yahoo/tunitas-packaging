// This is -*- c++ -*- nearly C++2a with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-alambique/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/services/alambique/tree/LICENSE
#divert <fpp>
#import tunitas.alambique.demonstrator.Executor.template
namespace tunitas::alambique::demonstrator {
  //
  // The executor for a generic (Distributed Aggregation) Function
  //
  // Specification:
  //
  //   I-D.irtf-cfrg-daf
  //   https://www.ietf.org/archive/id/draft-irtf-cfrg-daf-03.html
  //   https://www.ietf.org/archive/id/draft-irtf-cfrg-daf-04.html
  //   https://www.ietf.org/archive/id/draft-irtf-cfrg-daf-05.html
  //   Verifiable Distributed Aggregation Function
  //   Section 4. Definition of a DAF (Disaggregated Aggregation Function)
  //
  //   The interface, as stated:
  //
  //   (a noun form)
  //   disassembly ........... Daf.measurement_to_input_shares(measurement: Measurement) -> (Bytes, Vec[Bytes])
  //   computation ........... Daf.prep(agg_id: Unsigned, agg_param: AggParam, public_share: Bytes, input_share: Bytes) -> Vec[OutShare];
  //   amalgamation .......... Daf.out_shares_to_agg_share(agg_param: AggParam, out_shares: Vec[OutShare]) -> agg_share: Bytes
  //   reassembly ............ Daf.agg_shares_to_result(agg_param: AggParam, agg_shares: Vec[Bytes], num_measurements: Unsigned) -> AggResult
  //
  // Design:
  //
  //   Executors MUST not to maintain internal state call-to-call
  //   Be able to copy around the whole interface cluster of dafs.
  //
  // Usage:
  //
  //   Yes, but via the descendants; some magic occurs in the inherited constructor
  //
  //   auto executor = Executor<NUMERIC>{};
  //   auto executor = Executor<NUMERIC>{Name::ZERO};
  //   auto executor = Executor<NUMERIC>{Name::CONSTANT};
  //   auto executor = Executor<NUMERIC>{Name::COUNT};
  //   auto executor = Executor<NUMERIC>{Name::SUM};
  //   auto executor = Executor<NUMERIC>{Name::HISTOGRAM};
  //   auto executor = Executor<NUMERIC>{Name::POPULARITY};
  //
  //   auto disassembled = executor.disassembly(...arguments...);
  //   auto computed = executor.computation(...arguments...);
  //   auto disgorged = executor.amalgamation(...arguments...);
  //   auto reassembled = executor.reassembly(...arguments...);
  //
  template<> struct Executor<DAF, Polymorphic>;
}
#endiv
#divert <hpp>
#import tunitas.array.Series
#import tunitas.keyston.nonce.Bits
#import tunitas.keyston.Shard
#import tunitas.keyston.Shards
#import tunitas.keyston.Slice
#import tunitas.keyston.daf.constants
#import tunitas.keyston.daf.Name
#import tunitas.keyston.daf.Parameters
#import tunitas.keyston.daf.Public
#import tunitas.keyston.daf.Input
#import tunitas.keyston.daf.Output
#import tunitas.keyston.daf.Aggregation
#import tunitas.keyston.daf.Disassembled
#import tunitas.keyston.quantity.Records
namespace tunitas::alambique::demonstrator {
  template<> struct Executor<DAF, Polymorphic> {
    using Name = keyston::daf::Name;
    using enum Name;
    //
    explicit Executor() = default;
    explicit Executor(Name);
    //
    using Shard = keyston::Shard;
    using Slice = keyston::Slice;
    using enum Slice;
    //
    // In lieu of Function<SCHEME, NAME> which contains all of these declarations
    // and because this is Paulymorphic, can independently declare these here.
    //
    template<keyston::shards::required::Shardable TYPE> using Shards = keyston::Shards<TYPE>;
    template<array::required::Arrayable TYPE> using Series = array::Series<TYPE>;
    using Parameters = keyston::daf::Parameters;
    using Randomness = keyston::nonce::Bits<keyston::daf::constants::RANDOMNESS_BIT_COUNT.count()>;
    using Processed = keyston::quantity::Records;
    template<Slice SLICE> using Public = keyston::daf::Public<SLICE>;
    template<Slice SLICE> using Input = keyston::daf::Input<SLICE>;
    template<Slice SLICE> using Output = keyston::daf::Output<SLICE>;
    template<Slice SLICE> using Aggregation = keyston::daf::Aggregation<SLICE>;
    //
    //
    using Disassembled = keyston::daf::Disassembled;
    using Disassembly = Disassembled (*)(Parameters const &, Input<WHOLE> const &, Randomness const &);
    //
    using Computed = Output<SHARE>;
    using Computation = Computed (*)(Parameters const &, Shard, Public<SHARE> const &, Input<SHARE> const &);
    //
    using Amalgamated = Aggregation<SHARE>;
    using Amalgamation = Amalgamated (*)(Parameters const &, Series<Output<SHARE>> const &);
    //
    using Reassembled = Aggregation<WHOLE>;
    using Reassembly = Reassembled (*)(Parameters const &, Shards<Aggregation<SHARE>> const &, Processed);
    //
    inline auto disassembly(Parameters const &, Input<WHOLE> const &, Randomness const &) const -> Disassembled;
    inline auto computation(Parameters const &, Shard, Public<SHARE> const &, Input<SHARE> const &) const -> Computed;
    inline auto amalgamation(Parameters const &, Series<Output<SHARE>> const &) const -> Amalgamated;
    inline auto reassembly(Parameters const &, Shards<Aggregation<SHARE>> const &, Processed) const -> Reassembled;
  protected:
    Disassembly disassembly_function{};
    Computation computation_function{};
    Amalgamation amalgamation_function{};
    Reassembly reassembly_function{};
  };
}
#endiv
#divert <ipp>
#import tunitas.alambique.exception.Null
namespace tunitas::alambique::demonstrator {
  auto Executor<DAF, Polymorphic>::disassembly(Parameters const &p, Input<WHOLE> const &i, Randomness const &r) const -> Disassembled {
    if (nullptr == disassembly_function) {
      throw exception::Null{};
    } else {
      return disassembly_function(p, i, r);
    }
  }
  auto Executor<DAF, Polymorphic>::computation(Parameters const &p, Shard s, Public<SHARE> const &u, Input<SHARE> const &i) const -> Computed {
    if (nullptr == computation_function) {
      throw exception::Null{};
    } else {
      return computation_function(p, s, u, i);
    }
  }
  auto Executor<DAF, Polymorphic>::amalgamation(Parameters const &p, Series<Output<SHARE>> const &v) const -> Amalgamated {
    if (nullptr == amalgamation_function) {
      throw exception::Null{};
    } else {
      return amalgamation_function(p, v);
    }
  }
  auto Executor<DAF, Polymorphic>::reassembly(Parameters const &p, Shards<Aggregation<SHARE>> const &v, Processed c) const -> Reassembled {
    if (nullptr == reassembly_function) {
      throw exception::Null{};
    } else {
      return reassembly_function(p, v, c);
    }
  }
}
#endiv
#divert <cpp>
#import tunitas.alambique.exception.Invalid
#import tunitas.keyston.daf.Function
namespace tunitas::alambique::demonstrator {
  Executor<DAF, Polymorphic>::Executor(Name name) {
    switch (name) {
      using keyston::daf::Function;
      using enum keyston::Scheme;
    case ZERO:
      disassembly_function  = Function<ADHOC, ZERO>::disassembly;
      computation_function  = Function<ADHOC, ZERO>::computation;
      amalgamation_function = Function<ADHOC, ZERO>::amalgamation;
      reassembly_function   = Function<ADHOC, ZERO>::reassembly;
      break;
    case CONSTANT:
      disassembly_function  = Function<ADHOC, CONSTANT>::disassembly;
      computation_function  = Function<ADHOC, CONSTANT>::computation;
      amalgamation_function = Function<ADHOC, CONSTANT>::amalgamation;
      reassembly_function   = Function<ADHOC, CONSTANT>::reassembly;
      break;
    case COUNT:
      disassembly_function  = Function<PRIO, COUNT>::disassembly;
      computation_function  = Function<PRIO, COUNT>::computation;
      amalgamation_function = Function<PRIO, COUNT>::amalgamation;
      reassembly_function   = Function<PRIO, COUNT>::reassembly;
      break;
    case SUM:
      disassembly_function  = Function<PRIO, SUM>::disassembly;
      computation_function  = Function<PRIO, SUM>::computation;
      amalgamation_function = Function<PRIO, SUM>::amalgamation;
      reassembly_function   = Function<PRIO, SUM>::reassembly;
      break;
    case HISTOGRAM:
      disassembly_function  = Function<PRIO, HISTOGRAM>::disassembly;
      computation_function  = Function<PRIO, HISTOGRAM>::computation;
      amalgamation_function = Function<PRIO, HISTOGRAM>::amalgamation;
      reassembly_function   = Function<PRIO, HISTOGRAM>::reassembly;
      break;
    case POPULARITY:
      disassembly_function  = Function<POPLAR, POPULARITY>::disassembly;
      computation_function  = Function<POPLAR, POPULARITY>::computation;
      amalgamation_function = Function<POPLAR, POPULARITY>::amalgamation;
      reassembly_function   = Function<POPLAR, POPULARITY>::reassembly;
      break;
    default:
      throw exception::Invalid{"daf name"};
    }
  }
}
#endiv
