// This is -*- c++ -*- nearly C++2a with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-alambique/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/services/alambique/tree/LICENSE
#divert <fpp>
namespace tests::unit::function { class Estimates; }
#endiv
#divert <hpp>
#import tunitas.alambique.function.Estimates
#import tunitas.alambique.function.Resolved
#import tunitas.error.by.required.Indicator
#import tunitas.exception.Aspect
#import tunitas.error.by.Optional
#import tunitas.error.by.Outcome
#import tests.unit.function.Palette
struct tests::unit::function::Estimates : public rigging::suite::Fixture {
  static auto suite() -> Suite;
  //
  using Subject = library::Estimates;
  using Resolved = library::Resolved;
  using Mode = library::Mode;
  using AF = Palette<library::Mode::AF>;
  using DAF = Palette<library::Mode::DAF>;
  using VDAF = Palette<library::Mode::VDAF>;
  //
  auto test_constructor_default() -> void;
  template<unsigned> auto test_constructor_each() -> void;
  template<bool, bool, bool> auto test_resolve() -> void;
  template<bool, bool, bool> auto test_assess() -> void;
protected:
  inline static constexpr auto OPTIONAL = ::tunitas::error::by::Optional{};
  inline static constexpr auto OUTCOME = ::tunitas::error::by::Outcome{};
};
#endiv
#divert <cpp>
//
// specializations come first so that suite() can see them
//
namespace tests::unit::function {
  template<> auto Estimates::test_constructor_each<0>() -> void {
    auto subject = Subject{};
    require(ASSERTION, sizeof (subject));
    require(ASSERTION, false == (bool)get<0>(subject));
    require(ASSERTION, false == (bool)get<1>(subject));
    require(ASSERTION, false == (bool)get<2>(subject));
  }
  template<> auto Estimates::test_constructor_each<1>() -> void {
    auto subject = Subject{AF::GOOD, DAF::GOOD, VDAF::GOOD};
    require(ASSERTION, sizeof (subject));
    require(ASSERTION, true == (bool)get<0>(subject));
    require(ASSERTION, true == (bool)get<1>(subject));
    require(ASSERTION, true == (bool)get<2>(subject));
    require(ASSERTION, AF::GOOD == get<0>(subject));
    require(ASSERTION, DAF::GOOD == get<1>(subject));
    require(ASSERTION, VDAF::GOOD == get<2>(subject));
  }
  namespace {
    inline constexpr auto CONSTRUCTOR_COUNT{2uz};
  }
}
#import tunitas.alambique.function.resolve
namespace tests::unit::function {
  template<> auto Estimates::test_resolve<false, false, false>() -> void {
    constexpr auto const v1 = AF::Optional{};
    constexpr auto const v2 = DAF::Optional{};
    constexpr auto const v3 = VDAF::Optional{};
    auto specimen = Subject{v1, v2, v3};
    auto resolved = library::resolve(OPTIONAL, specimen);
    require(ASSERTION, false == (bool) resolved);
  }
  template<> auto Estimates::test_resolve<false, false, true>() -> void {
    constexpr auto const v1 = AF::Optional{};
    constexpr auto const v2 = DAF::Optional{};
    constexpr auto const v3 = VDAF::GOOD;
    auto specimen = Subject{v1, v2, v3};
    auto resolved = library::resolve(OPTIONAL, specimen);
    require(ASSERTION, true == (bool) resolved);
    require(ASSERTION, Resolved{v3} == *resolved);
  }
  template<> auto Estimates::test_resolve<false, true, false>() -> void {
    constexpr auto const v1 = AF::Optional{};
    constexpr auto const v2 = DAF::GOOD;
    constexpr auto const v3 = VDAF::Optional{};
    auto specimen = Subject{v1, v2, v3};
    auto resolved = library::resolve(OPTIONAL, specimen);
    require(ASSERTION, true == (bool) resolved);
    require(ASSERTION, Resolved{v2} == *resolved);
  }
  template<> auto Estimates::test_resolve<false, true, true>() -> void {
    constexpr auto const v1 = AF::Optional{};
    constexpr auto const v2 = DAF::GOOD;
    constexpr auto const v3 = VDAF::GOOD;
    auto specimen = Subject{v1, v2, v3};
    auto resolved = library::resolve(OPTIONAL, specimen);
    require(ASSERTION, false == (bool) resolved);
  }
  template<> auto Estimates::test_resolve<true, false, false>() -> void {
    constexpr auto const v1 = AF::GOOD;
    constexpr auto const v2 = DAF::Optional{};
    constexpr auto const v3 = VDAF::Optional{};
    auto specimen = Subject{v1, v2, v3};
    auto resolved = library::resolve(OPTIONAL, specimen);
    require(ASSERTION, true == (bool) resolved);
    require(ASSERTION, Resolved{v1} == *resolved);
  }
  template<> auto Estimates::test_resolve<true, false, true>() -> void {
    constexpr auto const v1 = AF::GOOD;
    constexpr auto const v2 = DAF::Optional{};
    constexpr auto const v3 = VDAF::GOOD;
    auto specimen = Subject{v1, v2, v3};
    auto resolved = library::resolve(OPTIONAL, specimen);
    require(ASSERTION, false == (bool) resolved);
  }
  template<> auto Estimates::test_resolve<true, true, false>() -> void {
    constexpr auto const v1 = AF::GOOD;
    constexpr auto const v2 = DAF::GOOD;
    constexpr auto const v3 = VDAF::Optional{};
    auto specimen = Subject{v1, v2, v3};
    auto resolved = library::resolve(OPTIONAL, specimen);
    require(ASSERTION, false == (bool) resolved);
  }
  template<> auto Estimates::test_resolve<true, true, true>() -> void {
    constexpr auto const v1 = AF::GOOD;
    constexpr auto const v2 = DAF::GOOD;
    constexpr auto const v3 = VDAF::GOOD;
    auto specimen = Subject{v1, v2, v3};
    auto resolved = library::resolve(OPTIONAL, specimen);
    require(ASSERTION, false == (bool) resolved);
  }
}
#import tunitas.alambique.function.assess
namespace tests::unit::function {
  template<> auto Estimates::test_assess<false, false, false>() -> void {
    constexpr auto const v1 = AF::Optional{};
    constexpr auto const v2 = DAF::Optional{};
    constexpr auto const v3 = VDAF::Optional{};
    auto specimen = Subject{v1, v2, v3};
    auto assessd = library::assess(OPTIONAL, specimen);
    require(ASSERTION, false == (bool) assessd);
  }
  template<> auto Estimates::test_assess<false, false, true>() -> void {
    constexpr auto const v1 = AF::Optional{};
    constexpr auto const v2 = DAF::Optional{};
    constexpr auto const v3 = VDAF::GOOD;
    auto specimen = Subject{v1, v2, v3};
    auto assessd = library::assess(OPTIONAL, specimen);
    require(ASSERTION, true == (bool) assessd);
    require(ASSERTION, Mode::VDAF == *assessd);
  }
  template<> auto Estimates::test_assess<false, true, false>() -> void {
    constexpr auto const v1 = AF::Optional{};
    constexpr auto const v2 = DAF::GOOD;
    constexpr auto const v3 = VDAF::Optional{};
    auto specimen = Subject{v1, v2, v3};
    auto assessd = library::assess(OPTIONAL, specimen);
    require(ASSERTION, true == (bool) assessd);
    require(ASSERTION, Mode::DAF == *assessd);
  }
  template<> auto Estimates::test_assess<false, true, true>() -> void {
    constexpr auto const v1 = AF::Optional{};
    constexpr auto const v2 = DAF::GOOD;
    constexpr auto const v3 = VDAF::GOOD;
    auto specimen = Subject{v1, v2, v3};
    auto assessd = library::assess(OPTIONAL, specimen);
    require(ASSERTION, false == (bool) assessd);
  }
  template<> auto Estimates::test_assess<true, false, false>() -> void {
    constexpr auto const v1 = AF::GOOD;
    constexpr auto const v2 = DAF::Optional{};
    constexpr auto const v3 = VDAF::Optional{};
    auto specimen = Subject{v1, v2, v3};
    auto assessd = library::assess(OPTIONAL, specimen);
    require(ASSERTION, true == (bool) assessd);
    require(ASSERTION, Mode::AF == *assessd);
  }
  template<> auto Estimates::test_assess<true, false, true>() -> void {
    constexpr auto const v1 = AF::GOOD;
    constexpr auto const v2 = DAF::Optional{};
    constexpr auto const v3 = VDAF::GOOD;
    auto specimen = Subject{v1, v2, v3};
    auto assessd = library::assess(OPTIONAL, specimen);
    require(ASSERTION, false == (bool) assessd);
  }
  template<> auto Estimates::test_assess<true, true, false>() -> void {
    constexpr auto const v1 = AF::GOOD;
    constexpr auto const v2 = DAF::GOOD;
    constexpr auto const v3 = VDAF::Optional{};
    auto specimen = Subject{v1, v2, v3};
    auto assessd = library::assess(OPTIONAL, specimen);
    require(ASSERTION, false == (bool) assessd);
  }
  template<> auto Estimates::test_assess<true, true, true>() -> void {
    constexpr auto const v1 = AF::GOOD;
    constexpr auto const v2 = DAF::GOOD;
    constexpr auto const v3 = VDAF::GOOD;
    auto specimen = Subject{v1, v2, v3};
    auto assessd = library::assess(OPTIONAL, specimen);
    require(ASSERTION, false == (bool) assessd);
  }
}
#import std.to_string
#import std.index_sequence
#import std.make_index_sequence
auto tests::unit::function::Estimates::suite() -> Suite {
  auto series = Stream{"Estimates"sv};
  series << []{
             auto con = Stream{"constructor"sv};
             con << add("default", &Estimates::test_constructor_default);
             [&con]<std::size_t... INDEX>(std::index_sequence<INDEX...>) {
               ((con << add(std::to_string(INDEX), &Estimates::test_constructor_each<INDEX>)), ... );
             }(std::make_index_sequence<CONSTRUCTOR_COUNT>{});
             return con;
            }()
         << []{
             auto res = Stream{"resolve"sv};
             res << add("false,false,false", &Estimates::test_resolve<false, false, false>)
                 << add("false,false,true", &Estimates::test_resolve<false, false, true>)
                 << add("false,true,false", &Estimates::test_resolve<false, true, false>)
                 << add("false,true,true", &Estimates::test_resolve<false, true, true>)
                 << add("true,false,false", &Estimates::test_resolve<true, false, false>)
                 << add("true,false,true", &Estimates::test_resolve<true, false, true>)
                 << add("true,true,false", &Estimates::test_resolve<true, true, false>)
                 << add("true,true,true", &Estimates::test_resolve<true, true, true>)
                 << END;
             return res;
           }()
         << []{
             auto ass = Stream{"assess"sv};
             ass << add("false,false,false", &Estimates::test_assess<false, false, false>)
                 << add("false,false,true", &Estimates::test_assess<false, false, true>)
                 << add("false,true,false", &Estimates::test_assess<false, true, false>)
                 << add("false,true,true", &Estimates::test_assess<false, true, true>)
                 << add("true,false,false", &Estimates::test_assess<true, false, false>)
                 << add("true,false,true", &Estimates::test_assess<true, false, true>)
                 << add("true,true,false", &Estimates::test_assess<true, true, false>)
                 << add("true,true,true", &Estimates::test_assess<true, true, true>)
                 << END;
             return ass;
           }()
         << END;
  return settle(series);
}
namespace tests::unit::function {
  auto Estimates::test_constructor_default() -> void {
    auto subject = Subject{};
    require(ASSERTION, sizeof(subject));
  }
}
#endiv
