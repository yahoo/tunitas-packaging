OPTION// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-alambique/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/services/alambique/tree/LICENSE
#divert <fpp>
namespace app::flow {
  namespace package_main {
    namespace body::exported { }
    namespace interface = body::exported;
  }
  using namespace package_main::interface;
}
#import cli.exits.constants
#import langu.age
namespace app::flow::package_main {
  namespace body {
    using namespace cli::exits::constants;
    using namespace langu::age;
  }
}
#import cli.controllability.Through
#import cli.exits.Code
#import cli.options.c.Argv
#import cli.experience.Console
#import cli.options.Program
namespace app::flow::package_main {
  using Exit = cli::exits::Code;
  using cli::options::c::Argv;
  using cli::experience::Console;
  namespace body {
    using cli::controllability::Through;
    using cli::options::Program;
  }
}
#endiv
#divert <hpp>
#import app.flow.Configuration
#import tunitas.alambique.function.resolve
#import tunitas.error.by.Outcome
#import tunitas.error.by.Exception
namespace app::flow::package_main::body {
  namespace exported {
    inline auto main(int, char *[]) -> Exit;
    auto main(Argv) -> Exit;
    auto main([[inout]] Console &, [[inout]] Configuration &, Argv) -> Exit;
  }
  using tunitas::alambique::function::resolve;
  inline constexpr auto OUTCOME = tunitas::error::by::Outcome{};
  inline constexpr auto EXCEPTION = tunitas::error::by::Exception{};
}
#endiv
#divert <ipp>
namespace app::flow::package_main {
  auto interface::main(int cc, char *vv[]) -> Exit { return main(Argv(cc, vv)); }
}
#endiv
#divert <cpp>
#import std.cerr
#import app.exception.Quitting
#import app.exception.Testing
#import app.flow.run
#import app.flow.options.Specification
#import app.flow.options.Parser
#import cli.exception.feature.Quitting
#import langu.age.q
namespace app::flow::package_main {
  auto interface::main(Argv argv) -> Exit try {
    auto program = Program{argv};
    auto cfg = Configuration{};
    auto exp = Console{move(program), cfg};
    return main(exp, cfg, argv);
  } catch (substd::exception::Exception const &e) {
    std::cerr << "error: unexpected exception " << e.what() << '\n';
    return SOFTWARE;
  }
  auto interface::main(Console &exp, Configuration &cfg, Argv argv) -> Exit try {
    auto const spec = options::Specification{};
    auto parser = options::Parser{exp, spec};
    auto parsed = parser.parse(cfg, argv);
    // parsed is unused because there are no words allowed after the options
    if (cfg.interactive_mode) {
      error(exp) << "interactive mode is not implemented\n";
      throw exception::Quitting{exp, UNIMPLEMENTED};
    }
    if (cfg.programmatic_mode) {
      error(exp) << "programmatic mode is not implemented\n";
      throw exception::Quitting{exp, UNIMPLEMENTED};
    }
    if (!parsed.empty()) {
      notice(exp) << "there are words after the options\n";
      error(exp) << "there must be no extra words after the options\n";
      return USAGE;
    }
    if (testing(cfg) <= Through::OPTIONS) { throw exception::Testing{exp}; }
    // the options have been parsed.  Examining the options for consistency is part of Through::SETUP
    if (!cfg.measurement_data_filepath) {
      notice(exp) << "use " << q("--measurement-data-filepath=FILEPATH"sv) << " or " << q("--usage"sv) << '\n';
      error(exp) << "the measurement-data file is not defined\n";
      return CONFIGURATION;
    } else if (!cfg.aggregation_function_names) {
      error(exp) << "an aggregation-function has not been named\n";
      return CONFIGURATION;
    } else if (auto resolved=resolve(OUTCOME, cfg.aggregation_function_mode, *cfg.aggregation_function_names); fail(resolved)) {
      debug(exp) << "aggregation-function-mode " << q(to_string(EXCEPTION, *cfg.aggregation_function_mode)) << '\n';
      error(exp) << "cannot intuit the aggregation-function mode and name because " << error_code(resolved).message() << '\n';
      return CONFIGURATION;
    } else {
      debug(exp) << "running!\n";
      return run(exp, cfg, *cfg.measurement_data_filepath, value(resolved));
    }
  } catch (cli::exception::feature::Quitting const &q) {
    q.stream() << q.what() << '\n';
    return q.exit();
  }
}
#endiv
