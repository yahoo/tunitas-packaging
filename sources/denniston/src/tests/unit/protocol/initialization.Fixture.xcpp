// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc. 2022.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-denniston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/services/denniston/tree/LICENSE
#divert <fpp>
#import tunitas.denniston.protocol.initialization
namespace tests::unit::protocol::initialization {
  class Fixture;
  namespace library = ::tunitas::denniston::protocol::initialization;
}
#endiv
#divert <hpp>
struct tests::unit::protocol::initialization::Fixture : public rigging::suite::Fixture {
  static auto suite() -> Suite;
  //
  auto test_Slicer() -> void;
  auto test_Computer() -> void;
};
#endiv
#divert <cpp>
auto tests::unit::protocol::initialization::Fixture::suite() -> Suite {
  auto series = Stream{"initialization"sv};
  series << add("Slicer", &Fixture::test_Slicer)
         << add("Computer", &Fixture::test_Computer)
         << END;
  return settle(series);
}
#import tunitas.denniston.exception.Aspect
#import tunitas.denniston.protocol.initialization.Slicer
#import tunitas.denniston.protocol.initialization.Computer
#import tunitas.keyston.vdaf.Parameters
#import tunitas.keyston.vdaf.Nonce
#import tunitas.keyston.vdaf.Secret
#import tunitas.keyston.nonce.generator
#import tunitas.keyston.literals
#import std.views.iota
#import nonstd.exception.Unimplemented
namespace tests::unit::protocol::initialization {
  auto Fixture::test_Slicer() -> void {
    auto task_id = ::tunitas::rheem::protocol::id::Task{};
    auto job_id = ::tunitas::rheem::protocol::id::Job{};
    auto parameters = ::tunitas::keyston::vdaf::Parameters{};
    auto query = ::tunitas::rheem::protocol::query::Partial{};
    auto reports = ::tunitas::denniston::report::Series<::tunitas::denniston::report::Definition>{};
    using namespace ::tunitas::keyston::literals;
    //
    auto subject = library::Slicer{task_id, job_id, parameters, query, reports};
    auto count{0uz};
    for (auto idx : std::views::iota(0_shard, ::tunitas::keyston::shards::SHARD_COUNT.count())) {
      ++count;
      auto got = subject(idx);
      require(ASSERTION, sizeof (got));
    }
    require(ASSERTION, 2uz >= count);
  }
  auto Fixture::test_Computer() -> void try {
    auto index = ::tunitas::denniston::index::Processor{};
    auto function = ::tunitas::keyston::vdaf::Name::ZERO;
    auto verify_key = ::tunitas::keyston::vdaf::Secret{};
    auto source = ::tunitas::entropy::Source{};
    auto nonce = ::tunitas::keyston::nonce::Generator<::tunitas::keyston::vdaf::Nonce, ::tunitas::entropy::Source>{source}();
    auto task_id = ::tunitas::rheem::protocol::id::Task{};
    auto parameters = ::tunitas::keyston::vdaf::Parameters{};
    auto query = ::tunitas::rheem::protocol::initialization::Request::Query{};
    auto reports = ::tunitas::rheem::protocol::initialization::Request::Report_Shares{};
    //
    auto subject = library::Computer{index, function, verify_key, nonce, task_id, parameters, query, reports};
    auto got = subject();
    require(ASSERTION, sizeof (got));
  } catch (nonstd::exception::Unimplemented const &) {
    // Yeah no, no yeah.  Never mind.
    require(ASSERTION);
  }
}
#endiv
