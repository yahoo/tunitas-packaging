// This is -*- c++ -*- nearly C++2a with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-denniston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/services/denniston/tree/LICENSE
#divert <fpp>
namespace tests::unit::scheduler { class Watchdog; }
#endiv
#divert <hpp>
#import tunitas.denniston.scheduler.Watchdog
#import tunitas.time.Clock
struct tests::unit::scheduler::Watchdog : public rigging::suite::Fixture {
  static auto suite() -> Suite;
  //
  using Subject = library::Watchdog;
  //
  auto test_constructor_duration() -> void;
  auto test_constructor_point() -> void;
  auto test_constructor_duration_precision() -> void;
  auto test_constructor_point_precision() -> void;
  //
  auto test_disarm() -> void;
  auto test_stop_waiting() -> void;
  auto test_action_completed() -> void;
  auto test_action_disarmed() -> void;
protected:
  static constexpr auto const HOW_MANY = 10uz;
  using Clock = ::tunitas::time::Clock;
};
#endiv
#divert <cpp>
auto tests::unit::scheduler::Watchdog::suite() -> Suite {
  auto series = Stream{"Watchdog"sv};
  series << []{
             auto con = Stream{"constructor"sv};
             con << add("Duration", &Watchdog::test_constructor_duration)
                 << add("Point", &Watchdog::test_constructor_point)
                 << add("Duration,Precision", &Watchdog::test_constructor_duration_precision)
                 << add("Point,Precision", &Watchdog::test_constructor_point_precision)
                 << END;
             return con;
           }()
         << add("disarm", &Watchdog::test_disarm)
         << []{
           auto act = Stream{"action"sv};
           act << add("completed", &Watchdog::test_action_completed)
               << add("disarmed", &Watchdog::test_action_completed)
               << END;
           return act;
         }()
         << END;
  return settle(series);
}
namespace tests::unit::scheduler {
  auto Watchdog::test_constructor_duration() -> void {
    auto has_run{false};
    auto action = [&has_run]{
      std::cerr << "watchdog duration constructor!\n";
      has_run = true;
    };
    Subject{10ns, action}; // <-------------------- test this
    require(ASSERTION, has_run);
  }
  auto Watchdog::test_constructor_point() -> void {
    auto has_run{false};
    auto const then = Clock::now() + 10ns;
    auto action = [&has_run]{
      std::cerr << "watchdog point constructor!\n";
      has_run = true;
    };
    Subject{then, action}; // <-------------------- test this
    require(ASSERTION, has_run);
  }
  auto Watchdog::test_constructor_duration_precision() -> void {
    auto has_run{false};
    auto action = [&has_run]{
      std::cerr << "watchdog duration precision constructor!\n";
      has_run = true;
    };
    Subject{1000ns, 10ns, action}; // <-------------------- test this
    require(ASSERTION, has_run);
  }
  auto Watchdog::test_constructor_point_precision() -> void {
    auto has_run{false};
    auto const then = Clock::now() + 1000ns;
    Subject{then, 10ns, [&has_run]{
      std::cerr << "watchdog point precision constructor!\n";
      has_run = true;
    }};
    require(ASSERTION, has_run);
  }
  auto Watchdog::test_disarm() -> void {
    auto has_run{false};
    auto const then = Clock::now() + 20ms;
    auto dog = Subject{then, [&has_run]{
      std::cerr << "watchdog disarm!\n";
      has_run = true;
    }};
    dog.disarm(); // <------------------------------ test this
    require(ASSERTION, !has_run);
  }
  auto Watchdog::test_stop_waiting() -> void {
    auto has_run{false};
    auto const then = Clock::now() + 100ms;
    auto dog = Subject{then, [&has_run]{
      std::cerr << "running watchdog of stop_waiting!\n";
      has_run = true;
    }};
    dog.stop_waiting(true); // <------------------------------ test this
    require(ASSERTION, has_run);
  }
  auto Watchdog::test_action_completed() -> void {
    auto dog_failed_to_run_after_stop_waiting{false};
    {
      auto cat = Subject{100ms, [&]{ dog_failed_to_run_after_stop_waiting = true; }};
      auto dog_has_run{false};
      {
        auto dog = Subject{10s, [&dog_has_run]{ dog_has_run = true; }};
        dog.stop_waiting(true); // <---------------------------------------- test this (that it doesn't wait for the full 10s)
        //
        std::this_thread::sleep_for(1ns); // let the scheduler settle out and replan
      }
      require(ASSERTION, dog_has_run);
      cat.disarm();
    }
    require(ASSERTION, !dog_failed_to_run_after_stop_waiting);
  }
  auto Watchdog::test_action_disarmed() -> void {
    auto dog_failed_to_disarm{false};
    {
      auto cat = Subject{10ms, [&]{ dog_failed_to_disarm = true; }};
      auto dog_has_run{false};
      {
        auto dog = Subject{10s, [&dog_has_run]{ dog_has_run = true; }};
        dog.disarm(); // <---------------------------------------- test this (that it doesn't wait for the full 10s)
        cat.disarm();
        //
        std::this_thread::sleep_for(1ns); // let the scheduler settle out and replan
      }
      require(ASSERTION, !dog_has_run);
    }
    require(ASSERTION, !dog_failed_to_disarm);
  }
}
#endiv
