// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc, 2022.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
#import fmt.formatter
#import tunitas.denniston.role.Species
#import nonstd.required.Character
namespace fmt {
  template<nonstd::required::Character CHAR> struct formatter<tunitas::denniston::role::Species, CHAR>;
}
#endiv
#divert <hpp>
#import std.false_type
namespace fmt {
  //
  // Specification:
  //
  //   https://en.cppreference.com/w/cpp/utility/format/formatter
  //   https://en.cppreference.com/w/cpp/named_req/Formatter
  //   https://en.cppreference.com/w/cpp/named_req/BasicFormatter
  //   callables parse(...) and format(...)
  //   ParseContext, an alias of std::basic_format_parse_context<CharT>
  //   FormatContext, an alias of std::basic_format_context<OutputIt, CharT>
  //   ParseContext::iterator
  //   FormatContext::iterator
  // 
  template<nonstd::required::Character CHAR> struct formatter<tunitas::denniston::role::Species, CHAR> {
    using Value = tunitas::denniston::role::Species;
    template<typename ParseContext> inline constexpr auto parse(ParseContext &ctx) -> decltype(ctx.begin());
    template<typename FormatContext> inline auto format(Value const &, FormatContext &ctx) const -> decltype(ctx.out());
  };
  //
  // WATCHOUT - in fmtlib v9.0.0, if a type T has a to_string_view(t) then it "is a string" and you will get unformattable_char
  //
  //   /exp/fmt/include/fmt/core.h:1753:17: error: static assertion failed: Mixing character types is disallowed.
  //    1753 |   static_assert(formattable_char, "Mixing character types is disallowed.");
  //         |                 ^~~~~~~~~~~~~~~~
  //
  namespace detail { template<> struct is_string<tunitas::denniston::role::Species> : public std::false_type { }; }
}
#endiv
#divert <ipp>
#import tunitas.denniston.role.package_io.Species
#import std.copy
namespace fmt {
  template<nonstd::required::Character C> 
  template<typename ParseContext> 
  constexpr auto formatter<tunitas::denniston::role::Species,C>::parse(ParseContext &ctx) -> decltype(ctx.begin()) {
    //
    // {} only
    //
    if (auto end=ctx.end(); end != ctx.begin()) {
      throw fmt::format_error{"only the trivial format {} is supported"};
    } else {
      return end;
    }
  }
  template<nonstd::required::Character C> 
  template<typename FormatContext> 
  auto formatter<tunitas::denniston::role::Species,C>::format(Value const &specimen, FormatContext &ctx) const -> decltype(ctx.out()) {
    auto got = to_string(specimen);
    return std::copy(got.begin(), got.end(), ctx.out());
  }
}
#endiv
