// This is -*- c++ -*- nearly C++2a with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
namespace tunitas::octets {
  //
  // A fixed array of octets (bytes)
  //
  // Specification:
  //
  //   Just what it says on the label
  //   With subrange(...)
  //
  // Design:
  //
  //   Obvious.
  //
  // Usage:
  //
  //   As one does.
  //
  template<Size CAPACITY> struct Fixed;
}
#endiv
#divert <hpp>
#import tunitas.array.Fixed
#forward tunitas.octets.Variable
#import tunitas.octets.Octet
namespace tunitas {
  namespace octets {
    using std::move;
  }
  template<octets::Size CAPACITY> class octets::Fixed : public array::Fixed<Octet, CAPACITY> {
    using Ancestor = array::Fixed<Octet, CAPACITY>;
  public:
    Fixed() = default;
    using Ancestor::Fixed;
    constexpr Fixed(Ancestor const &a) : Ancestor{a} { }
    using Index = Size;
    inline auto subrange(Index lo, Index hi) const -> Variable;
    template<Size SUBCAPACITY> inline auto subrange(Index lo) const -> Fixed<SUBCAPACITY>;
  protected:
    template<typename RECOVERED> inline auto recover(Index lo, Index hi) const -> RECOVERED;
  };
}
#endiv
#divert <ipp>
#import tunitas.array.Fixed
#import tunitas.exception.Bound
#import tunitas.octets.Variable
#import std.copy
namespace tunitas::octets {
  template<octets::Size _> auto Fixed<_>::subrange(Index lo, Index hi) const                            -> Variable { return recover<Variable>(lo, hi); }
  template<octets::Size _> template<Size SUBCAPACITY> auto Fixed<_>::subrange(Index lo) const -> Fixed<SUBCAPACITY> { return recover<Fixed<SUBCAPACITY>>(lo, lo + SUBCAPACITY); }
  template<octets::Size _> template<typename RECOVERED> auto Fixed<_>::recover(Index lo, Index hi) const -> RECOVERED {
    if (auto size=Ancestor::size(); hi < lo || size < lo || size < hi) {
      throw exception::Bound{"index out of range"};
    } else {
      auto begin = Ancestor::begin();
      if constexpr (std::same_as<RECOVERED, Variable>) {
        return {begin+lo, begin+hi};
      } else {
        auto ret = RECOVERED{};
        // ew already know size==hi-lo
        std::copy(begin+lo, begin+hi, ret.begin());
        return ret;
      }
    }
  }
}
#endiv
