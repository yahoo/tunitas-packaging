// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
#import tunitas.keyston.prio.flp.gadget.recorder.required.Element
namespace tunitas::keyston::prio::flp::gadget::recorder::cursor {
  //
  // The output is a span on the size-M output array which is equipped with indirect assignment and an "advance" operation.
  //
  // Specification:
  //
  //   Advance
  //   throw if exhausted
  //   These are G-gates so there is only one output
  //
  // Design:
  //
  //   Sure, why do you ask?  We are using the Best Available Means and Methods (UBAMM)  We uuse patterns and behavior-driven- design and design-driven-behavior and scrum, and agile and we are agnostic to whether requirements-driven waterfall chains are tied scoped into our the best practices of our continuous integration.  Our practice statement is available in the department office along with the many compliance certifications that we have achieved.
  //
  // Usage: see Recorder<ELEMENT, ELEMENT, ARITY>
  //
  //   auto output = Output{log.circuit.output};
  //   *output = ...something...;
  //   ++output;

  template<required::Element ELEMENT> struct Output;
}
#endiv
#divert <hpp>
#import tunitas.span.md.Variable
namespace tunitas::keyston::prio::flp::gadget::recorder {
  template<recorder::required::Element ELEMENT> class cursor::Output {
    inline static constexpr auto const M = std::dynamic_extent;
  public:
    using Element = ELEMENT;
    using Reference = span::md::Variable<ELEMENT, std::extents<Size, M>>; // the extent(s) MUST the same order as Log<...>::Circuit::Output
    explicit Output(Reference r) : reference{r} { }
    constexpr operator bool() const          { return here < reference.extent(0); }
    constexpr auto operator!() const -> bool { return !operator bool(); }
    inline constexpr auto operator++() -> Output &;
    inline constexpr auto operator++(int) -> Output;
    constexpr auto operator*() const -> Element const & { return reference[here]; } // constexpr mdspan::operator[] will range-check?
    constexpr auto operator*() -> Element &             { return reference[here]; } // eadem ratione
  protected:
    Reference reference{};
    Size here{}; // m of M
  };
}
#endiv
#divert <ipp>
#import tunitas.keyston.prio.exception.Exhausted
namespace tunitas::keyston::prio::flp::gadget::recorder::cursor {
  template<required::Element E> constexpr auto Output<E>::operator++() -> Output & {
    if (here == reference.extent(0)) {
      throw exception::Exhausted{};
    } else {
      ++here;
      return *this;
    }
  }
  template<required::Element E> constexpr auto Output<E>::operator++(int) -> Output {
    auto old = *this;
    operator++();
    return old;
  }
}
#endiv
