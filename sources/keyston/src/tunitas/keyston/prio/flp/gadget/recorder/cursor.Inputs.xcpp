// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
#import tunitas.keyston.prio.flp.gadget.recorder.required.Element
namespace tunitas::keyston::prio::flp::gadget::recorder::cursor {
  //
  // The inputs are a span on the size(L \times M) input array equipped with indirect assignment and an "advance" operation.
  //
  // Specification:
  //
  //   Advance
  //   throw if exhausted
  //
  // Design:
  //
  //   Sure, why do you ask?  We are using the Best Available Means and Methods (UBAMM)  We uuse patterns and behavior-driven- design and design-driven-behavior and scrum, and agile and we are agnostic to whether requirements-driven waterfall chains are tied scoped into our the best practices of our continuous integration.  Our practice statement is available in the department office along with the many compliance certifications that we have achieved.
  //
  // Usage: see Recorder<ELEMENT, ELEMENT, ARITY>
  //
  //   auto inputs = Inputs{log.circuit.inputs};
  //   inputs[
  //   [indexed = Tuple<std::remove_cvref_t<EACH> const &...>{packed...}]<Size... INDEX>(Sequence::Pack<INDEX...>) {
  //     ((inputs[INDEX] = get<INDEX>(indexed)), ... );
  //   }(Sequence::make<sizeof...(EACH)>());
  //   ++inputs;

  template<required::Element ELEMENT, Arity ARITY> struct Inputs;
}
#endiv
#divert <hpp>
#import tunitas.span.md.Variable
namespace tunitas::keyston::prio::flp::gadget::recorder {
  template<recorder::required::Element ELEMENT, Arity THE_ARITY> class cursor::Inputs {
    inline static constexpr auto const M = std::dynamic_extent;
    inline static constexpr auto const L = underlying(THE_ARITY);
  public:
    using Element = ELEMENT;
    using Reference = span::md::Variable<ELEMENT, std::extents<Size, M, L>>; // the extents MUST be in the same order as Log<...>::Circuit::Inputs
    explicit Inputs(Reference r) : reference{r} { }
    constexpr operator bool() const          { return here < reference.extent(0); }
    constexpr auto operator!() const -> bool { return !operator bool(); }
    inline constexpr auto operator++() -> Inputs &;
    inline constexpr auto operator++(int) -> Inputs;
    constexpr auto operator[](Size index) const -> Element const & { return reference[here, index]; } // constexpr mdspan::opeator[] will range-check?
    constexpr auto operator[](Size index) -> Element &             { return reference[here, index]; } // eadem ratione
  protected:
    Reference reference{};
    Index here{}; // m of M
  };
}
#endiv
#divert <ipp>
#import tunitas.keyston.prio.exception.Exhausted
namespace tunitas::keyston::prio::flp::gadget::recorder::cursor {
  template<required::Element E, Arity A> constexpr auto Inputs<E,A>::operator++() -> Inputs & {
    if (here == reference.extent(0)) {
      throw exception::Exhausted{};
    } else {
      ++here;
      return *this;
    }
  }
  template<required::Element E, Arity A> constexpr auto Inputs<E,A>::operator++(int) -> Inputs {
    auto old = *this;
    operator++();
    return old;
  }
}
#endiv
