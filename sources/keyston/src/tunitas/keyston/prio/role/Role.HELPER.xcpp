// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
#import tunitas.keyston.prio.role.Role.template
namespace tunitas::keyston::prio::role {
  //
  // Specification:
  //
  //   Yes.
  //
  // Design:
  //
  //   The helpers work with encoded Seeds.
  //
  template<required::Definition DEFINITION> struct Role<HELPER, DEFINITION>;
}
#endiv
#divert <hpp>
#import tunitas.keyston.Shard
#import tunitas.keyston.prio.role.Literal
#import tunitas.keyston.prio.role.Uncoded
#import tunitas.keyston.prio.role.Outline
namespace tunitas::keyston::prio::role {
  template<required::Definition DEFINITION> struct Role<HELPER, DEFINITION> : public Outline<HELPER, DEFINITION> {
    Role() = delete;
    Role(Role const &) = delete;
    //
    // because we're in a template so either we redeclare these or we use a longer pathname to get at them
    using Definition = DEFINITION;
    using Uncoded = role::Uncoded<HELPER, DEFINITION>;
    using Decoded = typename Outline<HELPER, DEFINITION>::Decoded;
    using Encoded = typename Outline<HELPER, DEFINITION>::template Encoded<DEFINITION::Amplifier::Seed::SIZE.count(), Literal<1uz>>;
    //
    // def encode_helper_share(Prio3, meas_share, proof_share, k_blind):
    inline static constexpr auto encode(typename Uncoded::Input::View::Fixed, typename Uncoded::Proof::View::Fixed, typename Uncoded::Blind::View::Fixed) -> typename Encoded::Storage;
    //
    // def decode_helper_share(Prio3, 3, agg_id: Unsigned, encoded: Bytes) -> Tuple<Input, Proof, Blind>;
    inline static constexpr auto decode(Shard, typename Encoded::View::Variable) -> typename Decoded::Triple;
  };
}
#endiv
#divert <ipp>
#import tunitas.keyston.prio.binder
#import tunitas.keyston.prio.Usage
namespace tunitas::keyston::prio::role {
  template<required::Definition _> constexpr auto Role<HELPER, _>::encode(typename Uncoded::Input::View::Fixed input, typename Uncoded::Proof::View::Fixed proof, typename Uncoded::Blind::View::Fixed blind) -> typename Encoded::Storage {
    if constexpr (Definition::use_joint_randomness()) {
      return octets::concatenate(input, proof, blind);
    } else {
      return octets::concatenate(input, proof);
    }
  }
  template<required::Definition _> constexpr auto Role<HELPER, _>::decode(Shard shard, typename Encoded::View::Variable encoded0) -> typename Decoded::Triple {
    auto [k_input_share, encoded1] = octets::slice_off<typename Encoded::Input::View::Fixed, exception::Decode>(encoded0);
    auto c_input_share = Definition::Customizer::template domain_separation_tag<Usage::INPUT_SHARE>();
    auto input_share = Definition::Amplifier::template expand_as<typename Decoded::Input::Storage>(k_input_share, c_input_share, binder(shard));
    //
    auto [k_proof_share, encoded2] = octets::slice_off<typename Encoded::Proof::View::Fixed, exception::Decode>(encoded1);
    auto c_proof_share = Definition::Customizer::template domain_separation_tag<Usage::PROOF_SHARE>();
    auto proof_share = Definition::Amplifier::template expand_as<typename Decoded::Proof::Storage>(k_proof_share, c_proof_share, binder(shard));
    //
    if constexpr (!Definition::use_joint_randomness()) {
      if (!encoded2.empty()) {
        throw exception::Decode{};
      } else {
        return {move(input_share), move(proof_share), typename Decoded::Blind::Storage{}};
      }
    } else {
      auto [k_blind, encoded3] = octets::slice_off<typename Encoded::Blind::View::Fixed, exception::Decode>(encoded2);
      if (!encoded3.empty()) {
        throw exception::Decode{};
      } else {
        return {move(input_share), move(proof_share), move(k_blind)};
      }
    }
  }
}
#endiv
