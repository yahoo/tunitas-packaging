// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
#import tunitas.keyston.vdaf.Check.template
namespace tunitas::keyston::vdaf::check {
  //
  // This is a "prep_msg" in the nomenclature of the (draft) standard
  //
  template<required::Definition DEFINITION> struct Check<WHOLE, DEFINITION>;
}
#endiv
#divert <hpp>
namespace tunitas::keyston::vdaf::check {
  template<required::Definition DEFINITION> class Check<WHOLE, DEFINITION> : public octets::Fixed<Outline<DEFINITION>::whole_size()> {
    using Outline = check::Outline<DEFINITION>;
    using Ancestor = octets::Fixed<Outline::whole_size()>;
  public:
    Check() = default;
    using Ancestor::Fixed;
    constexpr Check(Ancestor const &a) : Ancestor{a} { }
    //
    using Uncoded = typename Outline::Uncoded;
    using Decoded = typename Outline::Decoded;
    using Encoded = typename Outline::Encoded;
    //
    // def encode_prep_msg(Prio3, k_joint_rand_check): -> Bytes
    inline static constexpr auto encode(typename Uncoded::Randomness::View::Fixed) -> Check;
    //
    // def decode_prep_msg(Prio3, encoded): -> Bytes
    inline static constexpr auto decode(Check const &c) -> typename Decoded::Randomness::Storage { return decode(static_cast<view::Variable<Octet>>(c)); }
    inline static constexpr auto decode(view::Variable<Octet>) -> typename Decoded::Randomness::Storage;
  };
}
#endiv
#divert <ipp>
#import tunitas.octets.slice_off
#import tunitas.keyston.prio.exception.Decode
namespace tunitas::keyston::vdaf::check {
  //
  // Section 7.2.6.1 Message Serialization
  //
  template<required::Definition _> constexpr auto Check<WHOLE, _>::encode(typename Uncoded::Randomness::View::Fixed joint) -> Check {
    if constexpr (!Outline::use_joint_randomness()) {
      return {};
    } else {
      return {joint};
    }
  }
  template<required::Definition _> constexpr auto Check<WHOLE, _>::decode(view::Variable<Octet> encoded0) -> typename Decoded::Randomness::Storage {
    if constexpr (!Outline::use_joint_randomness()) {
      if (!encoded0.empty()) {
        throw prio::exception::Decode{};
      } else {
        return typename Decoded::Randomness::Storage{};
      }
    } else {
      auto [randomness_view, encoded1] = octets::slice_off<typename Encoded::Randomness::View::Fixed, prio::exception::Decode>(encoded0);
      if (!encoded1.empty()) {
        throw prio::exception::Decode{};
      } else {
        return typename Decoded::Randomness::Storage{randomness_view};
      }
    }
  }
}
#endiv
