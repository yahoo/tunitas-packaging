// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <hpp>
#import tunitas.keyston.field.element.Element
#import tunitas.keyston.field.element.required.Element
#import std.remove_cvref
namespace tunitas::keyston::field::element {
  //
  // The field element operations.
  //
  // Authorities:
  //
  //   Any field theory textbook will do.
  //   But specifically, for this work
  //
  //   Verifiable Distributed Aggregation Functions
  //   https://www.ietf.org/archive/id/draft-irtf-cfrg-vdaf-05.html#name-preliminaries
  //   Section 6 Preliminaries
  //   Section 6.1 Finite fields
  //
  // Specification:
  //
  //   As-stated.
  //
  // Design:
  //
  //   These operators are found by ADL.
  //   The enumerations at issue are the class-scoped ELEMENT enumerators in the Field<INDEX> descriptor. 
  //
  // Usage:
  //
  //   You know how to add, subtract, multiply and divide, yes?
  //   Good for you!
  //
  template<typename ELEMENT> requires required::Element<std::remove_cvref_t<ELEMENT>> constexpr auto operator+(ELEMENT &&) -> ELEMENT;
  template<required::Element ELEMENT> inline constexpr auto operator+(ELEMENT const &) -> ELEMENT;
  template<required::Element ELEMENT> inline constexpr auto operator+(ELEMENT &&) -> ELEMENT;
  template<required::Element ELEMENT> inline constexpr auto operator-(ELEMENT const &) -> ELEMENT;
  //
  template<required::Element ELEMENT> inline constexpr auto operator+(ELEMENT const &, ELEMENT const &) -> ELEMENT;
  template<required::Element ELEMENT> inline constexpr auto operator-(ELEMENT const &, ELEMENT const &) -> ELEMENT;
  template<required::Element ELEMENT> inline constexpr auto operator*(ELEMENT const &, ELEMENT const &) -> ELEMENT;
  template<required::Element ELEMENT> inline constexpr auto pow(ELEMENT const &, int long unsigned exponent) -> ELEMENT;
  template<required::Element ELEMENT> inline constexpr auto inv(ELEMENT const &) -> ELEMENT;
  //
  template<required::Element ELEMENT> inline constexpr auto operator+=(ELEMENT &, ELEMENT const &) -> ELEMENT &;
  template<required::Element ELEMENT> inline constexpr auto operator-=(ELEMENT &, ELEMENT const &) -> ELEMENT &;
  template<required::Element ELEMENT> inline constexpr auto operator*=(ELEMENT &, ELEMENT const &) -> ELEMENT &;
  //
  template<required::Element ELEMENT> inline constexpr auto operator==(ELEMENT const &, ELEMENT const &) -> bool;
}
#endiv
#divert <ipp>
#import nonstd.required.Enumeration
#import tunitas.integer.invm
#import tunitas.integer.powm
#import tunitas.keyston.field.required.Element // ease the exposition
#import tunitas.keyston.field.element.traits.Element
#import tunitas.keyston.field.Limits
#import tunitas.keyston.exception.Domain
#import tunitas.keyston.exception.Overflow
#import std.derived_from
#import substd.exception.Domain
namespace tunitas::keyston::field {
  template<required::Element ELEMENT> inline constexpr auto element::operator==(ELEMENT const &a, ELEMENT const &b) -> bool { return underlying(a) == underlying(b); }
  template<typename ELEMENT> requires required::Element<std::remove_cvref_t<ELEMENT>> constexpr auto element::operator+(ELEMENT &&e) -> ELEMENT { return forward<ELEMENT>(e); }
  template<required::Element ELEMENT> constexpr auto element::operator-(ELEMENT const &e) -> ELEMENT {
    using Field = typename traits::Element<ELEMENT>::Field;
    if (ELEMENT{} == e) {
      return e;
    } else {
      return ELEMENT{Field::MODULUS - underlying(e)};
    }
  }
  //
  // Diagram of A + B (avoiding overflow)
  //
  //   let A+B < MODULUS
  //   <---------MODULUS ---------->
  //   <---A----<-----B----->
  //
  //   let A+B >= MODULUS
  //   <---------MODULUS ---------->
  //   <--------A-------><----------B---------->
  //                     <----B1---><----B2---->
  // 
  //
  template<required::Element ELEMENT> constexpr auto element::operator+(ELEMENT const &a, ELEMENT const &b) -> ELEMENT {
    using Field = traits::Element<ELEMENT>::Field;
    auto const &ua = underlying(a);
    auto const &ub = underlying(b);
    if (ua < Field::MODULUS - ub) {
      return ELEMENT{ua + ub};
    } else {
      auto b1 = Field::MODULUS - ua;
      auto b2 = ub - b1;
      return ELEMENT{b2};
    }
  }
  //
  // Diagram of A - B (avoiding overflow)
  //
  //   let A >= B
  //   <--------------------MODULUS-------------------->
  //   <---------------A--------------->
  //   <-----B----->
  //                <-------A-B-------->
  //
  //   let A < B
  //   <--------------------MODULUS--------------------><--------------------MODULUS-------------------->
  //   <-----A----->
  //   <---------------B--------------->
  //                                    <-----M-B------>
  //                                                    <-----A----->
  //                                    <----------M-B+A------------>
  //
  //     C = A - B     (mod M) 
  // M + C = M + A - B (mod M)
  //     C = M + A - B (mod M)
  //     C = M - B + A (mod M)
  //     C = (M-B) + A (mod M)
  //
  template<required::Element ELEMENT> constexpr auto element::operator-(ELEMENT const &a, ELEMENT const &b) -> ELEMENT {
    using Field = traits::Element<ELEMENT>::Field;
    static_assert(Limits<ELEMENT>::max() <= Limits<ELEMENT>::Numeric::max());
    auto const &ua = underlying(a);
    auto const &ub = underlying(b);
    if (ua < ub) {
      return ELEMENT{Field::MODULUS - ub + ua};
    } else {
      return ELEMENT{ua - ub};
    }
  }
  template<required::Element ELEMENT> constexpr auto element::operator*(ELEMENT const &a, ELEMENT const &b) -> ELEMENT {
    using Field = traits::Element<ELEMENT>::Field;
    using Temporary = typename Field::Temporary;
    static_assert(Limits<ELEMENT>::max() + Limits<ELEMENT>::max() <= Limits<ELEMENT>::Numeric::max()); // unsigned "overflow" is defined to wrap around (even for bignums), so this doesn't prove anything.
    static_assert(Temporary{Limits<ELEMENT>::max()} + Temporary{Limits<ELEMENT>::max()} <= Temporary{2} * Temporary{Limits<ELEMENT>::Numeric::max()}); // this does prove something.
    auto ua = Temporary{underlying(a)};
    auto ub = Temporary{underlying(b)};
    auto widened = (ua * ub) % Field::MODULUS;
    auto narrowed = narrow<typename Field::Underlying>(error::by::Exception{}, widened);
    return ELEMENT{narrowed};
  }
  template<required::Element ELEMENT> constexpr auto element::operator+=(ELEMENT &lhs, ELEMENT const &rhs) -> ELEMENT & {
    lhs = lhs + rhs;
    return lhs;
  }
  template<required::Element ELEMENT> constexpr auto element::operator-=(ELEMENT &lhs, ELEMENT const &rhs) -> ELEMENT & {
    lhs = lhs - rhs;
    return lhs;
  }
  template<required::Element ELEMENT> constexpr auto element::operator*=(ELEMENT &lhs, ELEMENT const &rhs) -> ELEMENT & {
    lhs = lhs * rhs;
    return lhs;
  }
  template<required::Element ELEMENT> constexpr auto element::inv(ELEMENT const &a) -> ELEMENT try {
    using Field = traits::Element<ELEMENT>::Field;
    return ELEMENT{invm<typename Field::Underlying>(error::by::Exception{}, underlying(a), Field::MODULUS)};
  } catch (substd::exception::Domain const &e) {
    throw exception::Domain{e.what()};
  }
  template<required::Element ELEMENT> constexpr auto element::pow(ELEMENT const &a, int long unsigned e) -> ELEMENT {
    using Field = traits::Element<ELEMENT>::Field;
    if constexpr (required::Enumeration<ELEMENT>) {
      if (ELEMENT{2} == a && e < 8*sizeof(ELEMENT)) {
        //
        // special case 2^e
        //
        auto candidate = typename Field::Underlying{1u} << e;
        if (candidate < Field::MODULUS) {
          return ELEMENT{candidate};
        } else {
          return ELEMENT{candidate % Field::MODULUS};
        }
      }
    }
    return ELEMENT{powm<typename Field::Underlying>(underlying(a), e, Field::MODULUS)};
  }
}
#endiv
#divert <cpp>
#import tunitas.keyston.field.element.traits.Element
#import std.derived_from
namespace {
  namespace testate {
    namespace traits = tunitas::keyston::field::element::traits;
    using tunitas::keyston::field::element::Element;
    using X = Element<255>;
    using Y = traits::Element<Element<255>>::Underlying;
    static_assert(std::derived_from<X, Y>);
    static_assert(std::derived_from<Element<255>, traits::Element<Element<255>>::Underlying>);
  }
}
#endiv
