// This is -*- c++ -*- nearly C++2a with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
#import tunitas.keyston.shards
namespace tests::unit::shards { class Shard; }
#endiv
#divert <hpp>
#import tunitas.keyston.Shard
#import tunitas.keyston.exception.Aspect
struct tests::unit::shards::Shard : public rigging::suite::Fixture {
  static auto suite() -> Suite;
  //
  using Subject = library::Shard;
  //
  // Most of this is tested in constexpr in tunitas.keyston.shard.Shard.xcpp
  auto test_operator_inc_pre_good() -> void;
  auto test_operator_inc_pre_fail() -> void;
  auto test_operator_inc_post() -> void;
  auto test_operator_minus() -> void;
protected:
  using Failure = ::tunitas::keyston::exception::Aspect;
};
#endiv
#divert <cpp>
auto tests::unit::shards::Shard::suite() -> Suite {
  auto series = Stream{"Shard"sv};
  series << []{
              auto inc = Stream{"operator++"sv};
              inc << []{
                      auto pre = Stream{"pre"sv};
                      pre << add("good", &Shard::test_operator_inc_pre_good)
                          << add("fail", &Shard::test_operator_inc_pre_fail)
                          << END;
                      return pre;
                    }()
                   << add("post", &Shard::test_operator_inc_post)
                   << END;
              return inc;
           }()
         << add("operator-", &Shard::test_operator_minus)
         << END;
  return settle(series);
}
namespace tests::unit::shards {
  auto Shard::test_operator_inc_pre_good() -> void {
    auto subject = Subject{};
    ++subject;
    ++subject;
    require(ASSERTION, Subject{2} == subject);
  }
  auto Shard::test_operator_inc_pre_fail() -> void try {
    auto subject = Subject{};
    ++subject;
    ++subject;
    require(ASSERTION, Subject{2} == subject);
    ++subject;
    impossible(ASSERTION);
  } catch (Failure const &) {
    require(ASSERTION);
  }
  auto Shard::test_operator_inc_post() -> void {
    auto subject = Subject{};
    auto zero = subject++;
    auto one = subject++;
    require(ASSERTION, Subject{2} == subject);
    require(ASSERTION, Subject{1} == one);
    require(ASSERTION, Subject{0} == zero);
  }
  auto Shard::test_operator_minus() -> void {
    auto const zero = Subject{0};
    auto const one = Subject{1};
    auto positive = one - zero;
    require(ASSERTION, 1 == positive);
    auto negative = zero - one;
    require(ASSERTION, -1 == negative);
  }
}
#endiv
