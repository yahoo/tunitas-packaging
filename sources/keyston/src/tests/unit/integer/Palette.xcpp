// This is -*- c++ -*- nearly C++23 with Modules TS but in the S.C.O.L.D. stylings that are so popular these days.
// Copyright Yahoo Inc.
// Licensed under the terms of the Apache-2.0 license.
// For terms, see the LICENSE file at https://github.com/yahoo/tunitas-keyston/blob/master/LICENSE
// For terms, see the LICENSE file at https://git.tunitas.technology/all/components/keyston/tree/LICENSE
#divert <fpp>
namespace tests::unit::integer {
  //
  // A palette of types, values and generators
  // Descendants only
  //
  struct Palette;
}
#endiv
#divert <hpp>
#import tunitas.integer.from.Bytes
#import tunitas.integer.traits.SizeOf
#import tunitas.octets.Variable
#import tunitas.octets.Fixed
#include <ipp/tunitas.octets.Fixed> // because cast<...>(...) uses it
#import tunitas.octets.View
#import tunitas.units.Bytes
#import std.ostream
namespace tests::unit {
  class integer::Palette {
  protected:
    ~Palette() = default;
  public:
    using Bytes = ::tunitas::units::Bytes;
    struct Integer {
      template<Size BIT_WIDTH> using Type = typename library::from::Bits<BIT_WIDTH>::Unsigned;
      template<Size BIT_WIDTH> inline static constexpr auto const SIZE = library::traits::SizeOf<typename library::from::Bits<BIT_WIDTH>::Unsigned>::VALUE;
      template<Size BIT_WIDTH> inline static constexpr auto const INTERESTING_CONSTANT = 0u;
    };
    struct Octets {
      using Octet = ::tunitas::octets::Octet;
      using View = ::tunitas::octets::View;
      using Variable = ::tunitas::octets::Variable;
      template<Size CAPACITY> using Fixed = ::tunitas::octets::Fixed<CAPACITY>;
      template<std::endian> struct Endian {
        template<Size BIT_WIDTH> inline static constexpr auto const INTERESTING_CONSTANT = ::tunitas::octets::Fixed<BIT_WIDTH/8>{};
      };
    private:
      // for fixed-length views & spans, the constructor is explicit (no implicit conversion from a bare initializer list)
      template<Size BIT_WIDTH, Size ACTUAL_LENGTH> requires (BIT_WIDTH/8 == ACTUAL_LENGTH-1u) inline static constexpr auto cast(char const (&literal)[ACTUAL_LENGTH]) -> ::tunitas::octets::Fixed<BIT_WIDTH/8> {
        auto ret = ::tunitas::octets::Fixed<BIT_WIDTH/8>{};
        for (auto i{0uz}, e{ACTUAL_LENGTH-1}; e != i; ++i) {
          ret.at(i) = Octet(literal[i]);
        }
        return ret;
      }
    };
    static auto dump(std::ostream &, Octets::View) -> void;
    template<required::Unsigned  UNSIGNED> static auto dump(std::ostream &, UNSIGNED const &) -> void;
  };
  namespace integer {
    template<> inline constexpr auto const Palette::Integer::INTERESTING_CONSTANT<8uz> = integers::uint8_t{0b1001'0110u};
    template<> inline constexpr auto const Palette::Integer::INTERESTING_CONSTANT<16uz> = integers::uint16_t{0b1100'0011'1001'0110u};
    template<> inline constexpr auto const Palette::Integer::INTERESTING_CONSTANT<32uz> = integers::uint32_t{0x7654'3210u};
    template<> inline constexpr auto const Palette::Integer::INTERESTING_CONSTANT<64uz> = integers::uint64_t{0x7654'3210'fedc'ba98lu};
    template<> inline constexpr auto const Palette::Integer::INTERESTING_CONSTANT<128uz> = (integers::uint128_t{0x7654'3210'fedc'ba98lu} << 64) | integers::uint128_t{0xfedc'ba98'7654'3210lu};
    template<> inline constexpr auto const Palette::Integer::INTERESTING_CONSTANT<256uz> = ((integers::uint256_t{0x7654'3210'fedc'ba98lu} << 192) |
                                                                                            (integers::uint256_t{0xfedc'ba98'7654'3210lu} << 128) | 
                                                                                            (integers::uint256_t{0x1122'3344'5566'7788lu} << 64) |
                                                                                            (integers::uint256_t{0xfedc'ba98'7654'3210lu} << 0));
    template<> template<> inline constexpr auto const Palette::Octets::Endian<std::endian::big>::INTERESTING_CONSTANT<8uz>    = cast<8uz>("\x96");
    template<> template<> inline constexpr auto const Palette::Octets::Endian<std::endian::little>::INTERESTING_CONSTANT<8uz> = cast<8uz>("\x96");
    template<> template<> inline constexpr auto const Palette::Octets::Endian<std::endian::big>::INTERESTING_CONSTANT<16uz>    = cast<16uz>("\xb3\x96");
    template<> template<> inline constexpr auto const Palette::Octets::Endian<std::endian::little>::INTERESTING_CONSTANT<16uz> = cast<16uz>("\x96\xb3");
    template<> template<> inline constexpr auto const Palette::Octets::Endian<std::endian::big>::INTERESTING_CONSTANT<32uz>    = cast<32uz>("\x76\x54\x32\x10");
    template<> template<> inline constexpr auto const Palette::Octets::Endian<std::endian::little>::INTERESTING_CONSTANT<32uz> = cast<32uz>("\x10\x32\x54\x76");
    template<> template<> inline constexpr auto const Palette::Octets::Endian<std::endian::big>::INTERESTING_CONSTANT<64uz>    = cast<64uz>("\x76\x54\x32\x10\xfe\xdc\xba\x98");
    template<> template<> inline constexpr auto const Palette::Octets::Endian<std::endian::little>::INTERESTING_CONSTANT<64uz> = cast<64uz>("\x98\xba\xdc\xfe\x10\x32\x54\x76");
    template<> template<> inline constexpr auto const Palette::Octets::Endian<std::endian::big>::INTERESTING_CONSTANT<128uz>    = cast<128uz>("\x76\x54\x32\x10\xfe\xdc\xba\x98\xfe\xdc\xba\x98\x76\x54\x32\x10");
    template<> template<> inline constexpr auto const Palette::Octets::Endian<std::endian::little>::INTERESTING_CONSTANT<128uz> = cast<128uz>("\x10\x32\x54\x76\x98\xba\xdc\xfe\x98\xba\xdc\xfe\x10\x32\x54\x76");
    template<> template<> inline constexpr auto const Palette::Octets::Endian<std::endian::big>::INTERESTING_CONSTANT<256uz>    = cast<256uz>("\x76\x54\x32\x10\xfe\xdc\xba\x98\xfe\xdc\xba\x98\x76\x54\x32\x10\x11\x22\x33\x44\x55\x66\x77\x88\xfe\xdc\xba\x98\x76\x54\x32\x10");
    template<> template<> inline constexpr auto const Palette::Octets::Endian<std::endian::little>::INTERESTING_CONSTANT<256uz> = cast<256uz>("\x10\x32\x54\x76\x98\xba\xdc\xfe\x88\x77\x66\x55\x44\x33\x22\x11\x10\x32\x54\x76\x98\xba\xdc\xfe\x98\xba\xdc\xfe\x10\x32\x54\x76");
  }
}
#endiv
#divert <tpp>
#import nonstd.setwidth
#import nonstd.setfill
#import std.hex
#import std.same_as
#import std.underlying_type
#import tunitas.integer.traits.SizeOf
#import nonstd.int128.ostream // for operator<< against uint128_t
namespace tests::unit::integer {
  template<required::Unsigned UNSIGNED> auto Palette::dump(std::ostream &o, UNSIGNED const &u) -> void {
    o << std::hex << nonstd::setfill('0') << nonstd::setwidth(2*::tunitas::integer::traits::SizeOf<UNSIGNED>::VALUE.count());
    if constexpr (std::same_as<uint8_t, UNSIGNED>) {
      o << static_cast<unsigned>(u); // the bug here being that unsignec char inserts as a "character" not as a small integer.
    } else {
      using nonstd::int128::operator<<;
      o << u;
    }
  }
}
#endiv
#divert <cpp>
#import std.hex
#import std.dec
#import nonstd.setfill
#import nonstd.setwidth
namespace tests::unit::integer {
  auto Palette::dump(std::ostream &outbound, Octets::View specimen) -> void {
    outbound << std::hex;
    for (auto each : specimen) {
      outbound << nonstd::setfill('0') << nonstd::setwidth(2) << static_cast<unsigned>(each);
    }
    outbound << std::dec;
  }
}
#endiv
  
